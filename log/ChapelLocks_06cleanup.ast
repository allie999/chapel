AST dump for ChapelLocks after pass cleanup.
Module use list: 

{
  (187305 'use' Atomics)
  (187307 'use' ChapelBase)
  (187310 'use' MemConsistency)
  function chpl_LocalSpinlock[187432].lock[187323](arg _mt[187436]:_MT[238], arg this[187434]:chpl_LocalSpinlock[187432]) : _unknown[51] "inline" "method" "primary method" "no return value for void"
  {
    const tmp[187402] "const" "temp"
    (187404 'move' tmp[187402](187400 'deref'(187399 '_wide_get_locale' this)))
    {
      {
        unknown tmp[187348] "temp"
        (187396 'move' tmp[187348](187379 call _cond_test(187381 call ||(187386 call(187383 call . l c"read"))(187391 call(187388 call . l c"testAndSet")(187393 call . memoryOrder c"acquire")))))
        WhileDo[187353]
        {
          (187346 call chpl_task_yield)
          label _continueLabel[187351]
          (187374 'move' tmp[187348](187357 call _cond_test(187359 call ||(187364 call(187361 call . l c"read"))(187369 call(187366 call . l c"testAndSet")(187371 call . memoryOrder c"acquire")))))
          tmp[187348]
        }
        label _breakLabel[187352]
      }
      (187407 'on block' 0 tmp[187402])
    }
  }
  function chpl_LocalSpinlock[187432].unlock[187415](arg _mt[187440]:_MT[238], arg this[187438]:chpl_LocalSpinlock[187432]) : _unknown[51] "inline" "method" "primary method" "no return value for void"
  {
    (187426 call(187418 call . l c"clear")(187422 call . memoryOrder c"release"))
  }
  type chpl_LocalSpinlock[187432] unknown l[187317](187316 call chpl__processorAtomicType bool[10])
}