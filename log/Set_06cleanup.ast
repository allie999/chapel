AST dump for Set after pass cleanup.
Module use list: 

{
  (353114 'use' ChapelStandard)
  (331340 'import' ChapelLocks)
  (331344 'use' IO)
  (331347 'use' Reflection)
  (331350 'use' ChapelHashtable)
  unknown _sanityChecks[331353] "no doc" "param" "private" 1
  (331356 'end of statement')
  function _sanity[331363](arg expr[331360] :
  bool[10]) : _unknown[51] "inline" "private" "no return value for void"
  {
    if(331371 call _cond_test _sanityChecks)
    {
      (331369 call assert expr)
    }
  }
  unknown _lockType[331383] "no doc" "type variable"(331380 call . ChapelLocks c"chpl_LocalSpinlock")
  function _LockWrapper[331424].lock[331397](arg _mt[331428]:_MT[238], arg this[331426]:_LockWrapper[331424]) : _unknown[51] "inline" "method" "primary method" "no return value for void"
  {
    (331404 call(331400 call . lock$ c"lock"))
  }
  function _LockWrapper[331424].unlock[331411](arg _mt[331432]:_MT[238], arg this[331430]:_LockWrapper[331424]) : _unknown[51] "inline" "method" "primary method" "no return value for void"
  {
    (331418 call(331414 call . lock$ c"unlock"))
  }
  type _LockWrapper[331424] unknown lock$[331391](331387 'new'(331390 call _lockType))
  function _checkElementType[331439](arg t[331437]:_any[178](?)) : _unknown[51] "no doc" "no return value for void"
  {
    if(331496 call _cond_test(331444 call isGenericType t))
    {
      (331471 call compilerWarning(331467 call + "creating a set with element type "(331465 call _cast string[26] t)) 2)
      (331494 call compilerError "set element type cannot currently be generic" 2)
    }
  }
  function set[333197](?).init[331538](arg _mt[333201]:_MT[238], arg this[333199]:set[333197](?), arg eltType[331536]:_any[178](?), param arg parSafe[331541] =
  0) : _unknown[51] "method" "primary method" "no return value for void"
  {
    (331547 call _checkElementType eltType)
    (331555 call =(331551 call . this c"eltType") eltType)
    (331563 call =(331559 call . this c"parSafe") parSafe)
  }
  function set[333197](?)._addElem[331574](arg _mt[333205]:_MT[238], arg this[333203]:set[333197](?), in arg elem[331571] :
  eltType) : _unknown[51] "method" "primary method" "no doc"
  {
    unknown tmp[331589] "temp"(331588 call(331583 call . _htb c"findAvailableSlot") elem)
    (331596 call _check_tuple_var_decl tmp[331589] 2)
    unknown isFullSlot[331577](331590 call tmp[331589] 0)
    unknown idx[331579](331593 call tmp[331589] 1)
    (331601 'end of statement')
    if(331607 call _cond_test isFullSlot)
    {
      (331605 return 0)
    }
    (331620 call(331613 call . _htb c"fillSlot") idx elem none[57])
    (331623 return 1)
  }
  { scopeless type
    bool[10]
  }
  function set[333197](?).init[331632](arg _mt[333209]:_MT[238], arg this[333207]:set[333197](?), arg eltType[331630]:_any[178](?), arg iterable[331634]:_any[178](?), param arg parSafe[331637] =
  0) : _unknown[51] "method" "primary method" "no return value for void"
  {
    (331654 call _checkElementType eltType)
    (331662 call =(331658 call . this c"eltType") eltType)
    (331670 call =(331666 call . this c"parSafe") parSafe)
    (331678 call(331674 call . this c"complete"))
    {
      unknown _indexOfInterest[331687] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[331688] "expr temp" "temp"
      (331697 'move' _iterator[331688](331695 call _getIterator iterable))
      Defer
      {
        {
          (331713 call _freeIterator _iterator[331688])
        }
      }
      { scopeless type
        (331702 'move' _indexOfInterest[331687](331699 call iteratorIndex _iterator[331688]))
      }
      ForLoop[331689]
      {
        unknown elem[331706] "index var" "insert auto destroy"
        (331708 'move' elem[331706] _indexOfInterest[331687])
        (331685 call _addElem elem)
        label _continueLabel[331692]
        _indexOfInterest[331687]
        _iterator[331688]
      }
      label _breakLabel[331693]
    }
  }
  where {
    (331644 call canResolveMethod iterable "these")
  }
  {
    (331649 call <(331646 'lifetime_of' this)(331648 'lifetime_of' iterable))
  }
  function set[333197](?).init=[331735](arg _mt[333213]:_MT[238], arg this[333211]:set[333197](?), const  ref arg other[331732] :
  (331731 call set unknown t[331727] ?[260])) : _unknown[51] "method" "primary method" "no return value for void"
  {
    (331748 call =(331744 call . this c"eltType") t)
    (331760 call =(331753 call . this c"parSafe")(331757 call . other c"parSafe"))
    (331768 call(331764 call . this c"complete"))
    if(331858 call _cond_test(331774 call !(331773 call isCopyableType eltType)))
    {
      (331856 call compilerError(331853 call +(331834 call +(331828 call +(331809 call +(331802 call +(331799 call + "Cannot initialize "(331797 call _cast string[26](331795 'typeof' this))) " from ")(331807 call _cast string[26](331805 'typeof' other))) " because element type ")(331832 call _cast string[26] eltType)) " is not copyable"))
    }
    {
      unknown _indexOfInterest[331870] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[331871] "expr temp" "temp"
      (331880 'move' _iterator[331871](331878 call _getIterator other))
      Defer
      {
        {
          (331896 call _freeIterator _iterator[331871])
        }
      }
      { scopeless type
        (331885 'move' _indexOfInterest[331870](331882 call iteratorIndex _iterator[331871]))
      }
      ForLoop[331872]
      {
        unknown elem[331889] "index var" "insert auto destroy"
        (331891 'move' elem[331889] _indexOfInterest[331870])
        (331868 call _addElem elem)
        label _continueLabel[331875]
        _indexOfInterest[331870]
        _iterator[331871]
      }
      label _breakLabel[331876]
    }
  }
  {
    (331741 call <(331738 'lifetime_of' this)(331740 'lifetime_of' other))
  }
  function set[333197](?)._enter[331908](arg _mt[333217]:_MT[238], arg this[333215]:set[333197](?)) : _unknown[51] "inline" "method" "primary method" "no doc" "no return value for void"
  {
    if(331931 call _cond_test parSafe)
    {
      const tmp[331923] "const" "temp"
      (331925 'move' tmp[331923](331921 'deref'(331920 '_wide_get_locale' this)))
      {
        {
          (331917 call(331913 call . _lock$ c"lock"))
        }
        (331928 'on block' 0 tmp[331923])
      }
    }
  }
  function set[333197](?)._leave[331941](arg _mt[333221]:_MT[238], arg this[333219]:set[333197](?)) : _unknown[51] "inline" "method" "primary method" "no doc" "no return value for void"
  {
    if(331964 call _cond_test parSafe)
    {
      const tmp[331956] "const" "temp"
      (331958 'move' tmp[331956](331954 'deref'(331953 '_wide_get_locale' this)))
      {
        {
          (331950 call(331946 call . _lock$ c"unlock"))
        }
        (331961 'on block' 0 tmp[331956])
      }
    }
  }
  function set[333197](?).add[331978](arg _mt[333225]:_MT[238], ref arg this[333223]:set[333197](?), in arg x[331975] :
  eltType) : _unknown[51] "method" "primary method" "no return value for void"
  {
    (331988 call _enter)
    Defer
    {
      { scopeless
        (331993 call _leave)
      }
    }
    (332000 call _addElem x)
  }
  {
    (331984 call <(331981 'lifetime_of' this)(331983 'lifetime_of' x))
  }
  function set[333197](?).contains[332011](arg _mt[333229]:_MT[238], const arg this[333227]:set[333197](?), const  ref arg x[332008] :
  eltType) : _unknown[51] "method" "primary method"
  {
    unknown result[332015] 0
    (332018 'end of statement')
    const tmp[332062] "const" "temp"
    (332064 'move' tmp[332062](332060 'deref'(332059 '_wide_get_locale' this)))
    {
      {
        (332023 call _enter)
        Defer
        {
          { scopeless
            (332028 call _leave)
          }
        }
        unknown tmp[332044] "temp"(332043 call(332038 call . _htb c"findFullSlot") x)
        (332048 call _check_tuple_var_decl tmp[332044] 2)
        unknown hasFoundSlot[332032](332045 call tmp[332044] 0)
        (332053 'end of statement')
        (332056 call = result hasFoundSlot)
      }
      (332067 'on block' 0 tmp[332062])
    }
    (332071 return result)
  }
  { scopeless type
    bool[10]
  }
  function set[333197](?).isDisjoint[332086](arg _mt[333233]:_MT[238], const arg this[333231]:set[333197](?), const  ref arg other[332083] :
  (332082 call set eltType ?[260])) : _unknown[51] "method" "primary method"
  {
    unknown result[332090] 1
    (332093 'end of statement')
    const tmp[332185] "const" "temp"
    (332187 'move' tmp[332185](332183 'deref'(332182 '_wide_get_locale' this)))
    {
      {
        (332098 call _enter)
        Defer
        {
          { scopeless
            (332103 call _leave)
          }
        }
        if(332178 call _cond_test(332120 call !(332118 call ||(332109 call == size 0)(332116 call ==(332112 call . other c"size") 0))))
        {
          {
            unknown _indexOfInterest[332144] "an _indexOfInterest or chpl__followIdx variable" "temp"
            unknown _iterator[332145] "expr temp" "temp"
            (332154 'move' _iterator[332145](332152 call _getIterator other))
            Defer
            {
              {
                (332170 call _freeIterator _iterator[332145])
              }
            }
            { scopeless type
              (332159 'move' _indexOfInterest[332144](332156 call iteratorIndex _iterator[332145]))
            }
            ForLoop[332146]
            {
              unknown x[332163] "index var" "insert auto destroy"
              (332165 'move' x[332163] _indexOfInterest[332144])
              if(332140 call _cond_test(332130 call(332125 call . this c"contains") x))
              {
                (332133 call = result 0)
                break nil[44]
              }
              label _continueLabel[332149]
              _indexOfInterest[332144]
              _iterator[332145]
            }
            label _breakLabel[332150]
          }
        }
      }
      (332190 'on block' 0 tmp[332185])
    }
    (332194 return result)
  }
  { scopeless type
    bool[10]
  }
  function set[333197](?).isIntersecting[332209](arg _mt[333237]:_MT[238], const arg this[333235]:set[333197](?), const  ref arg other[332206] :
  (332205 call set eltType ?[260])) : _unknown[51] "method" "primary method"
  {
    (332218 return(332216 call !(332215 call isDisjoint other)))
  }
  { scopeless type
    bool[10]
  }
  function set[333197](?).remove[332230](arg _mt[333241]:_MT[238], ref arg this[333239]:set[333197](?), const  ref arg x[332227] :
  eltType) : _unknown[51] "method" "primary method"
  {
    unknown result[332234] 0
    (332237 'end of statement')
    const tmp[332317] "const" "temp"
    (332319 'move' tmp[332317](332315 'deref'(332314 '_wide_get_locale' this)))
    {
      {
        (332242 call _enter)
        Defer
        {
          { scopeless
            (332247 call _leave)
          }
        }
        unknown tmp[332263] "temp"(332262 call(332257 call . _htb c"findFullSlot") x)
        (332270 call _check_tuple_var_decl tmp[332263] 2)
        unknown hasFoundSlot[332251](332264 call tmp[332263] 0)
        unknown idx[332253](332267 call tmp[332263] 1)
        (332275 'end of statement')
        if(332310 call _cond_test hasFoundSlot)
        {
          unknown key[332278] eltType
          (332281 'end of statement')
          unknown val[332284] nothing[7]
          (332287 'end of statement')
          (332296 call(332289 call . _htb c"clearSlot") idx key val)
          (332303 call(332299 call . _htb c"maybeShrinkAfterRemove"))
          (332307 call = result 1)
        }
      }
      (332322 'on block' 0 tmp[332317])
    }
    (332326 return result)
  }
  { scopeless type
    bool[10]
  }
  function set[333197](?).clear[332333](arg _mt[333245]:_MT[238], ref arg this[333243]:set[333197](?)) : _unknown[51] "method" "primary method" "no return value for void"
  {
    const tmp[332443] "const" "temp"
    (332445 'move' tmp[332443](332441 'deref'(332440 '_wide_get_locale' this)))
    {
      {
        (332338 call _enter)
        Defer
        {
          { scopeless
            (332343 call _leave)
          }
        }
        {
          unknown _indexOfInterest[332390] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[332391] "expr temp" "temp"
          (332400 'move' _iterator[332391](332398 call _getIterator(332410 call chpl_direct_counted_range_iter 0(332406 call . _htb c"tableSize"))))
          Defer
          {
            {
              (332426 call _freeIterator _iterator[332391])
            }
          }
          { scopeless type
            (332415 'move' _indexOfInterest[332390](332412 call iteratorIndex _iterator[332391]))
          }
          ForLoop[332392]
          {
            unknown idx[332419] "index var" "insert auto destroy"
            (332421 'move' idx[332419] _indexOfInterest[332390])
            {
              if(332385 call _cond_test(332363 call(332358 call . _htb c"isSlotFull") idx))
              {
                unknown key[332365] eltType
                (332368 'end of statement')
                unknown val[332371] nothing[7]
                (332374 'end of statement')
                (332383 call(332376 call . _htb c"clearSlot") idx key val)
              }
            }
            label _continueLabel[332395]
            _indexOfInterest[332390]
            _iterator[332391]
          }
          label _breakLabel[332396]
        }
        (332438 call(332434 call . _htb c"maybeShrinkAfterRemove"))
      }
      (332448 'on block' 0 tmp[332443])
    }
  }
  function set[333197](?).these[332456](arg _mt[333249]:_MT[238], const arg this[333247]:set[333197](?)) : _unknown[51] "iterator fn" "method" "primary method" "no return value for void"
  {
    {
      unknown _indexOfInterest[332492] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[332493] "expr temp" "temp"
      (332502 'move' _iterator[332493](332500 call _getIterator(332512 call chpl_direct_counted_range_iter 0(332508 call . _htb c"tableSize"))))
      Defer
      {
        {
          (332528 call _freeIterator _iterator[332493])
        }
      }
      { scopeless type
        (332517 'move' _indexOfInterest[332492](332514 call iteratorIndex _iterator[332493]))
      }
      ForLoop[332494]
      {
        unknown idx[332521] "index var" "insert auto destroy"
        (332523 'move' idx[332521] _indexOfInterest[332492])
        if(332487 call _cond_test(332474 call(332469 call . _htb c"isSlotFull") idx))
        {
          (332485 yield(332482 call .(332481 call(332476 call . _htb c"table") idx) c"key"))
        }
        label _continueLabel[332497]
        _indexOfInterest[332492]
        _iterator[332493]
      }
      label _breakLabel[332498]
    }
  }
  function set[333197](?).these[332542](arg _mt[333253]:_MT[238], const arg this[333251]:set[333197](?), param arg tag[332540]:_any[178](?)) : _unknown[51] "iterator fn" "method" "primary method" "no doc" "no return value for void"
  {
    unknown space[332560](332558 call #(332552 call chpl_build_low_bounded_range 0)(332555 call . _htb c"tableSize"))
    (332563 'end of statement')
    {
      unknown _indexOfInterest[332597] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[332598] "expr temp" "temp"
      (332607 'move' _iterator[332598](332605 call _getIterator(332572 call(332567 call . space c"these") tag)))
      Defer
      {
        {
          (332624 call _freeIterator _iterator[332598])
        }
      }
      { scopeless type
        (332613 'move' _indexOfInterest[332597](332610 call iteratorIndex _iterator[332598]))
      }
      ForLoop[332599]
      {
        unknown idx[332617] "index var" "insert auto destroy"
        (332619 'move' idx[332617] _indexOfInterest[332597])
        if(332592 call _cond_test(332579 call(332574 call . _htb c"isSlotFull") idx))
        {
          (332590 yield(332587 call .(332586 call(332581 call . _htb c"table") idx) c"key"))
        }
        label _continueLabel[332602]
        _indexOfInterest[332597]
        _iterator[332598]
      }
      label _breakLabel[332603]
    }
  }
  where {
    (332549 call == tag(332546 call . iterKind c"standalone"))
  }
  function set[333197](?).these[332638](arg _mt[333257]:_MT[238], const arg this[333255]:set[333197](?), param arg tag[332636]:_any[178](?)) : _unknown[51] "iterator fn" "method" "primary method" "no doc" "no return value for void"
  {
    unknown space[332656](332654 call #(332648 call chpl_build_low_bounded_range 0)(332651 call . _htb c"tableSize"))
    (332659 'end of statement')
    {
      unknown _indexOfInterest[332673] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[332674] "expr temp" "temp"
      (332683 'move' _iterator[332674](332681 call _getIterator(332668 call(332663 call . space c"these") tag)))
      Defer
      {
        {
          (332700 call _freeIterator _iterator[332674])
        }
      }
      { scopeless type
        (332689 'move' _indexOfInterest[332673](332686 call iteratorIndex _iterator[332674]))
      }
      ForLoop[332675]
      {
        unknown followThis[332693] "index var" "insert auto destroy"
        (332695 'move' followThis[332693] _indexOfInterest[332673])
        {
          (332670 yield followThis)
        }
        label _continueLabel[332678]
        _indexOfInterest[332673]
        _iterator[332674]
      }
      label _breakLabel[332679]
    }
  }
  where {
    (332645 call == tag(332642 call . iterKind c"leader"))
  }
  function set[333197](?).these[332714](arg _mt[333261]:_MT[238], const arg this[333259]:set[333197](?), param arg tag[332712]:_any[178](?), arg followThis[332716]:_any[178](?)) : _unknown[51] "iterator fn" "method" "primary method" "no doc" "no return value for void"
  {
    {
      unknown _indexOfInterest[332754] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[332755] "expr temp" "temp"
      (332764 'move' _iterator[332755](332762 call _getIterator(332729 call followThis 0)))
      Defer
      {
        {
          (332781 call _freeIterator _iterator[332755])
        }
      }
      { scopeless type
        (332770 'move' _indexOfInterest[332754](332767 call iteratorIndex _iterator[332755]))
      }
      ForLoop[332756]
      {
        unknown idx[332774] "index var" "insert auto destroy"
        (332776 'move' idx[332774] _indexOfInterest[332754])
        if(332749 call _cond_test(332736 call(332731 call . _htb c"isSlotFull") idx))
        {
          (332747 yield(332744 call .(332743 call(332738 call . _htb c"table") idx) c"key"))
        }
        label _continueLabel[332759]
        _indexOfInterest[332754]
        _iterator[332755]
      }
      label _breakLabel[332760]
    }
  }
  where {
    (332723 call == tag(332720 call . iterKind c"follower"))
  }
  function set[333197](?).writeThis[332798](arg _mt[333265]:_MT[238], const arg this[333263]:set[333197](?), arg ch[332795] :
  channel) : _unknown[51] throws "method" "primary method" "no return value for void"
  {
    const tmp[332900] "const" "temp"
    (332902 'move' tmp[332900](332898 'deref'(332897 '_wide_get_locale' this)))
    {
      {
        (332803 call _enter)
        Defer
        {
          { scopeless
            (332808 call _leave)
          }
        }
        unknown count[332813] 1
        (332816 'end of statement')
        (332819 call <~> ch "{")
        {
          unknown _indexOfInterest[332859] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[332860] "expr temp" "temp"
          (332869 'move' _iterator[332860](332867 call _getIterator this))
          Defer
          {
            {
              (332885 call _freeIterator _iterator[332860])
            }
          }
          { scopeless type
            (332874 'move' _indexOfInterest[332859](332871 call iteratorIndex _iterator[332860]))
          }
          ForLoop[332861]
          {
            unknown x[332878] "index var" "insert auto destroy"
            (332880 'move' x[332878] _indexOfInterest[332859])
            {
              if(332854 call _cond_test(332832 call <= count(332830 call -(332826 call . _htb c"tableNumFullSlots") 1)))
              {
                (332836 call += count 1)
                (332845 call <~>(332842 call <~> ch x) ", ")
              }
              {
                (332850 call <~> ch x)
              }
            }
            label _continueLabel[332864]
            _indexOfInterest[332859]
            _iterator[332860]
          }
          label _breakLabel[332865]
        }
        (332894 call <~> ch "}")
      }
      (332905 'on block' 0 tmp[332900])
    }
  }
  function set[333197](?).isEmpty[332913](arg _mt[333269]:_MT[238], const arg this[333267]:set[333197](?)) : _unknown[51] "inline" "method" "primary method"
  {
    unknown result[332917] 0
    (332920 'end of statement')
    const tmp[332948] "const" "temp"
    (332950 'move' tmp[332948](332946 'deref'(332945 '_wide_get_locale' this)))
    {
      {
        (332925 call _enter)
        Defer
        {
          { scopeless
            (332930 call _leave)
          }
        }
        (332942 call = result(332940 call ==(332936 call . _htb c"tableNumFullSlots") 0))
      }
      (332953 'on block' 0 tmp[332948])
    }
    (332957 return result)
  }
  { scopeless type
    bool[10]
  }
  function set[333197](?).size[332964](arg _mt[333273]:_MT[238], const arg this[333271]:set[333197](?)) : _unknown[51] "inline" "method" "primary method" "no parens"
  {
    unknown result[332967] 0
    (332970 'end of statement')
    const tmp[332995] "const" "temp"
    (332997 'move' tmp[332995](332993 'deref'(332992 '_wide_get_locale' this)))
    {
      {
        (332975 call _enter)
        Defer
        {
          { scopeless
            (332980 call _leave)
          }
        }
        (332989 call = result(332986 call . _htb c"tableNumFullSlots"))
      }
      (333000 'on block' 0 tmp[332995])
    }
    (333004 return result)
  }
  function set[333197](?).toArray[333010](arg _mt[333277]:_MT[238], const arg this[333275]:set[333197](?)) : _unknown[51] "method" "primary method"
  {
    (333018 call _enter)
    Defer
    {
      { scopeless
        (333023 call _leave)
      }
    }
    unknown result[333042](333040 call chpl__buildArrayRuntimeType(333038 call chpl__ensureDomainExpr(333034 call #(333028 call chpl_build_low_bounded_range 0)(333031 call . _htb c"tableNumFullSlots"))) eltType)
    (333045 'end of statement')
    if(333082 call _cond_test(333050 call !(333049 call isCopyableType eltType)))
    {
      (333080 call compilerError(333077 call +(333074 call + "Cannot create array because set element type "(333072 call _cast string[26] eltType)) " is not copyable"))
    }
    const tmp[333182] "const" "temp"
    (333184 'move' tmp[333182](333180 'deref'(333179 '_wide_get_locale' this)))
    {
      {
        if(333174 call _cond_test(333093 call !=(333089 call . _htb c"tableNumFullSlots") 0))
        {
          unknown count[333096] 0
          (333099 'end of statement')
          unknown array[333116](333114 call chpl__buildArrayRuntimeType(333112 call chpl__ensureDomainExpr(333108 call #(333102 call chpl_build_low_bounded_range 0)(333105 call . _htb c"tableNumFullSlots"))) eltType)
          (333119 'end of statement')
          {
            unknown _indexOfInterest[333136] "an _indexOfInterest or chpl__followIdx variable" "temp"
            unknown _iterator[333137] "expr temp" "temp"
            (333146 'move' _iterator[333137](333144 call _getIterator this))
            Defer
            {
              {
                (333162 call _freeIterator _iterator[333137])
              }
            }
            { scopeless type
              (333151 'move' _indexOfInterest[333136](333148 call iteratorIndex _iterator[333137]))
            }
            ForLoop[333138]
            {
              unknown x[333155] "index var" "insert auto destroy"
              (333157 'move' x[333155] _indexOfInterest[333136])
              {
                (333127 call =(333125 call array count) x)
                (333133 call += count 1)
              }
              label _continueLabel[333141]
              _indexOfInterest[333136]
              _iterator[333137]
            }
            label _breakLabel[333142]
          }
          (333171 call = result array)
        }
      }
      (333187 'on block' 0 tmp[333182])
    }
    (333191 return result)
  }
  { scopeless type
    (333013 call chpl__buildArrayRuntimeType nil[44] eltType)
  }
  type set[333197](?) unknown eltType[331504] "type variable" unknown parSafe[331508] "param" 0 unknown _lock$[331521] "no doc"(331518 IfExpr  parSafe then
  { scopeless
    (331513 'new'(331516 call _LockWrapper))
  } else
  { scopeless
    none[57]
  } ) unknown _htb[331530] "no doc"(331529 call chpl__hashtable eltType nothing[7])
  function =[333291](ref arg lhs[333288] :
  (333287 call set unknown t[333283] ?[260]), const  ref arg rhs[333298] :
  (333297 call set t ?[260])) : _unknown[51] "assignop" "no return value for void"
  {
    (333306 call(333302 call . lhs c"clear"))
    {
      unknown _indexOfInterest[333319] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[333320] "expr temp" "temp"
      (333329 'move' _iterator[333320](333327 call _getIterator rhs))
      Defer
      {
        {
          (333345 call _freeIterator _iterator[333320])
        }
      }
      { scopeless type
        (333334 'move' _indexOfInterest[333319](333331 call iteratorIndex _iterator[333320]))
      }
      ForLoop[333321]
      {
        unknown x[333338] "index var" "insert auto destroy"
        (333340 'move' x[333338] _indexOfInterest[333319])
        (333317 call(333312 call . lhs c"add") x)
        label _continueLabel[333324]
        _indexOfInterest[333319]
        _iterator[333320]
      }
      label _breakLabel[333325]
    }
  }
  function |[333365](const  ref arg a[333362] :
  (333361 call set unknown t[333357] ?[260]), const  ref arg b[333372] :
  (333371 call set t ?[260])) : _unknown[51]
  {
    unknown result[333393](333392 call set t(333390 call ||(333383 call . a c"parSafe")(333387 call . b c"parSafe")))
    (333396 'end of statement')
    (333400 call = result a)
    (333405 call |= result b)
    (333409 return result)
  }
  { scopeless type
    (333378 call set t)
  }
  function |=[333425](ref arg lhs[333422] :
  (333421 call set unknown t[333417] ?[260]), const  ref arg rhs[333432] :
  (333431 call set t ?[260])) : _unknown[51] "assignop" "no return value for void"
  {
    {
      unknown _indexOfInterest[333445] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[333446] "expr temp" "temp"
      (333455 'move' _iterator[333446](333453 call _getIterator rhs))
      Defer
      {
        {
          (333471 call _freeIterator _iterator[333446])
        }
      }
      { scopeless type
        (333460 'move' _indexOfInterest[333445](333457 call iteratorIndex _iterator[333446]))
      }
      ForLoop[333447]
      {
        unknown x[333464] "index var" "insert auto destroy"
        (333466 'move' x[333464] _indexOfInterest[333445])
        (333443 call(333438 call . lhs c"add") x)
        label _continueLabel[333450]
        _indexOfInterest[333445]
        _iterator[333446]
      }
      label _breakLabel[333451]
    }
  }
  function +[333492](const  ref arg a[333489] :
  (333488 call set unknown t[333484] ?[260]), const  ref arg b[333499] :
  (333498 call set t ?[260])) : _unknown[51]
  {
    (333511 return(333509 call | a b))
  }
  { scopeless type
    (333506 call set t ?[260])
  }
  function +=[333528](ref arg lhs[333525] :
  (333524 call set unknown t[333520] ?[260]), const  ref arg rhs[333535] :
  (333534 call set t ?[260])) : _unknown[51] "assignop" "no return value for void"
  {
    (333540 call |= lhs rhs)
  }
  function -[333557](const  ref arg a[333554] :
  (333553 call set unknown t[333549] ?[260]), const  ref arg b[333564] :
  (333563 call set t ?[260])) : _unknown[51]
  {
    unknown result[333586](333571 'new'(333585 call set t(333583 call ||(333576 call . a c"parSafe")(333580 call . b c"parSafe"))))
    (333589 'end of statement')
    if(333689 call _cond_test(333599 call &&(333592 call . a c"parSafe")(333596 call . b c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[333626] "index var" "insert auto destroy"
        iterated expressions:
          a
        shadow variables:
        other variables
          forall body
        {
          if(333620 call _cond_test(333610 call !(333609 call(333604 call . b c"contains") x)))
          {
            (333618 call(333613 call . result c"add") x)
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[333655] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[333656] "expr temp" "temp"
        (333665 'move' _iterator[333656](333663 call _getIterator a))
        Defer
        {
          {
            (333681 call _freeIterator _iterator[333656])
          }
        }
        { scopeless type
          (333670 'move' _indexOfInterest[333655](333667 call iteratorIndex _iterator[333656]))
        }
        ForLoop[333657]
        {
          unknown x[333674] "index var" "insert auto destroy"
          (333676 'move' x[333674] _indexOfInterest[333655])
          if(333650 call _cond_test(333640 call !(333639 call(333634 call . b c"contains") x)))
          {
            (333648 call(333643 call . result c"add") x)
          }
          label _continueLabel[333660]
          _indexOfInterest[333655]
          _iterator[333656]
        }
        label _breakLabel[333661]
      }
    }
    (333694 return result)
  }
  { scopeless type
    (333570 call set t)
  }
  function -=[333710](ref arg lhs[333707] :
  (333706 call set unknown t[333702] ?[260]), const  ref arg rhs[333717] :
  (333716 call set t ?[260])) : _unknown[51] "assignop" "no return value for void"
  {
    if(333790 call _cond_test(333728 call &&(333721 call . lhs c"parSafe")(333725 call . rhs c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[333741] "index var" "insert auto destroy"
        iterated expressions:
          rhs
        shadow variables:
        other variables
          forall body
        {
          (333738 call(333733 call . lhs c"remove") x)
        }
      }
    }
    {
      {
        unknown _indexOfInterest[333756] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[333757] "expr temp" "temp"
        (333766 'move' _iterator[333757](333764 call _getIterator rhs))
        Defer
        {
          {
            (333782 call _freeIterator _iterator[333757])
          }
        }
        { scopeless type
          (333771 'move' _indexOfInterest[333756](333768 call iteratorIndex _iterator[333757]))
        }
        ForLoop[333758]
        {
          unknown x[333775] "index var" "insert auto destroy"
          (333777 'move' x[333775] _indexOfInterest[333756])
          (333754 call(333749 call . lhs c"remove") x)
          label _continueLabel[333761]
          _indexOfInterest[333756]
          _iterator[333757]
        }
        label _breakLabel[333762]
      }
    }
  }
  function &[333808](const  ref arg a[333805] :
  (333804 call set unknown t[333800] ?[260]), const  ref arg b[333815] :
  (333814 call set t ?[260])) : _unknown[51]
  {
    unknown result[333836](333835 call set t(333833 call ||(333826 call . a c"parSafe")(333830 call . b c"parSafe")))
    (333839 'end of statement')
    if(334049 call _cond_test(333849 call <=(333842 call . a c"size")(333846 call . b c"size")))
    {
      if(333945 call _cond_test(333859 call &&(333852 call . a c"parSafe")(333856 call . b c"parSafe")))
      {
        Forall {
          induction variables:
            
            unknown x[333884] "index var" "insert auto destroy"
          iterated expressions:
            a
          shadow variables:
          other variables
            forall body
          {
            if(333878 call _cond_test(333869 call(333864 call . b c"contains") x))
            {
              (333876 call(333871 call . result c"add") x)
            }
          }
        }
      }
      {
        {
          unknown _indexOfInterest[333911] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[333912] "expr temp" "temp"
          (333921 'move' _iterator[333912](333919 call _getIterator a))
          Defer
          {
            {
              (333937 call _freeIterator _iterator[333912])
            }
          }
          { scopeless type
            (333926 'move' _indexOfInterest[333911](333923 call iteratorIndex _iterator[333912]))
          }
          ForLoop[333913]
          {
            unknown x[333930] "index var" "insert auto destroy"
            (333932 'move' x[333930] _indexOfInterest[333911])
            if(333906 call _cond_test(333897 call(333892 call . b c"contains") x))
            {
              (333904 call(333899 call . result c"add") x)
            }
            label _continueLabel[333916]
            _indexOfInterest[333911]
            _iterator[333912]
          }
          label _breakLabel[333917]
        }
      }
    }
    {
      if(334044 call _cond_test(333958 call &&(333951 call . a c"parSafe")(333955 call . b c"parSafe")))
      {
        Forall {
          induction variables:
            
            unknown x[333983] "index var" "insert auto destroy"
          iterated expressions:
            b
          shadow variables:
          other variables
            forall body
          {
            if(333977 call _cond_test(333968 call(333963 call . a c"contains") x))
            {
              (333975 call(333970 call . result c"add") x)
            }
          }
        }
      }
      {
        {
          unknown _indexOfInterest[334010] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[334011] "expr temp" "temp"
          (334020 'move' _iterator[334011](334018 call _getIterator b))
          Defer
          {
            {
              (334036 call _freeIterator _iterator[334011])
            }
          }
          { scopeless type
            (334025 'move' _indexOfInterest[334010](334022 call iteratorIndex _iterator[334011]))
          }
          ForLoop[334012]
          {
            unknown x[334029] "index var" "insert auto destroy"
            (334031 'move' x[334029] _indexOfInterest[334010])
            if(334005 call _cond_test(333996 call(333991 call . a c"contains") x))
            {
              (334003 call(333998 call . result c"add") x)
            }
            label _continueLabel[334015]
            _indexOfInterest[334010]
            _iterator[334011]
          }
          label _breakLabel[334016]
        }
      }
    }
    (334054 return result)
  }
  { scopeless type
    (333821 call set t)
  }
  function &=[334070](ref arg lhs[334067] :
  (334066 call set unknown t[334062] ?[260]), const  ref arg rhs[334077] :
  (334076 call set t ?[260])) : _unknown[51] "assignop" "no return value for void"
  {
    unknown result[334094](334093 call set t(334091 call ||(334084 call . lhs c"parSafe")(334088 call . rhs c"parSafe")))
    (334097 'end of statement')
    if(334193 call _cond_test(334107 call &&(334100 call . lhs c"parSafe")(334104 call . rhs c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[334132] "index var" "insert auto destroy"
        iterated expressions:
          lhs
        shadow variables:
        other variables
          forall body
        {
          if(334126 call _cond_test(334117 call(334112 call . rhs c"contains") x))
          {
            (334124 call(334119 call . result c"add") x)
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[334159] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[334160] "expr temp" "temp"
        (334169 'move' _iterator[334160](334167 call _getIterator lhs))
        Defer
        {
          {
            (334185 call _freeIterator _iterator[334160])
          }
        }
        { scopeless type
          (334174 'move' _indexOfInterest[334159](334171 call iteratorIndex _iterator[334160]))
        }
        ForLoop[334161]
        {
          unknown x[334178] "index var" "insert auto destroy"
          (334180 'move' x[334178] _indexOfInterest[334159])
          if(334154 call _cond_test(334145 call(334140 call . rhs c"contains") x))
          {
            (334152 call(334147 call . result c"add") x)
          }
          label _continueLabel[334164]
          _indexOfInterest[334159]
          _iterator[334160]
        }
        label _breakLabel[334165]
      }
    }
    (334199 call = lhs result)
  }
  function ^[334215](const  ref arg a[334212] :
  (334211 call set unknown t[334207] ?[260]), const  ref arg b[334222] :
  (334221 call set t ?[260])) : _unknown[51]
  {
    unknown result[334243](334242 call set t(334240 call ||(334233 call . a c"parSafe")(334237 call . b c"parSafe")))
    (334246 'end of statement')
    if(334280 call _cond_test(334256 call <=(334249 call . a c"size")(334253 call . b c"size")))
    {
      (334260 call = result b)
      (334266 call ^= result a)
    }
    {
      (334271 call = result a)
      (334277 call ^= result b)
    }
    (334285 return result)
  }
  { scopeless type
    (334228 call set t)
  }
  function ^=[334301](ref arg lhs[334298] :
  (334297 call set unknown t[334293] ?[260]), const  ref arg rhs[334308] :
  (334307 call set t ?[260])) : _unknown[51] "assignop" "no return value for void"
  {
    if(334425 call _cond_test(334319 call &&(334312 call . lhs c"parSafe")(334316 call . rhs c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[334354] "index var" "insert auto destroy"
        iterated expressions:
          rhs
        shadow variables:
        other variables
          forall body
        {
          if(334348 call _cond_test(334329 call(334324 call . lhs c"contains") x))
          {
            (334336 call(334331 call . lhs c"remove") x)
          }
          {
            (334345 call(334340 call . lhs c"add") x)
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[334391] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[334392] "expr temp" "temp"
        (334401 'move' _iterator[334392](334399 call _getIterator rhs))
        Defer
        {
          {
            (334417 call _freeIterator _iterator[334392])
          }
        }
        { scopeless type
          (334406 'move' _indexOfInterest[334391](334403 call iteratorIndex _iterator[334392]))
        }
        ForLoop[334393]
        {
          unknown x[334410] "index var" "insert auto destroy"
          (334412 'move' x[334410] _indexOfInterest[334391])
          {
            if(334386 call _cond_test(334367 call(334362 call . lhs c"contains") x))
            {
              (334374 call(334369 call . lhs c"remove") x)
            }
            {
              (334383 call(334378 call . lhs c"add") x)
            }
          }
          label _continueLabel[334396]
          _indexOfInterest[334391]
          _iterator[334392]
        }
        label _breakLabel[334397]
      }
    }
  }
  function ==[334443](const  ref arg a[334440] :
  (334439 call set unknown t[334435] ?[260]), const  ref arg b[334450] :
  (334449 call set t ?[260])) : _unknown[51]
  {
    if(334467 call _cond_test(334462 call !=(334455 call . a c"size")(334459 call . b c"size")))
    {
      (334465 return 0)
    }
    unknown result[334474] 1
    (334477 'end of statement')
    if(334568 call _cond_test(334486 call &&(334479 call . a c"parSafe")(334483 call . b c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[334510] "index var" "insert auto destroy"
        iterated expressions:
          a
        shadow variables:
        other variables
          forall body
        {
          if(334504 call _cond_test(334497 call !(334496 call(334491 call . b c"contains") x)))
          {
            (334501 call = result 0)
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[334534] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[334535] "expr temp" "temp"
        (334544 'move' _iterator[334535](334542 call _getIterator a))
        Defer
        {
          {
            (334560 call _freeIterator _iterator[334535])
          }
        }
        { scopeless type
          (334549 'move' _indexOfInterest[334534](334546 call iteratorIndex _iterator[334535]))
        }
        ForLoop[334536]
        {
          unknown x[334553] "index var" "insert auto destroy"
          (334555 'move' x[334553] _indexOfInterest[334534])
          if(334529 call _cond_test(334524 call !(334523 call(334518 call . b c"contains") x)))
          {
            (334527 return 0)
          }
          label _continueLabel[334539]
          _indexOfInterest[334534]
          _iterator[334535]
        }
        label _breakLabel[334540]
      }
    }
    (334573 return result)
  }
  { scopeless type
    bool[10]
  }
  function !=[334589](const  ref arg a[334586] :
  (334585 call set unknown t[334581] ?[260]), const  ref arg b[334596] :
  (334595 call set t ?[260])) : _unknown[51]
  {
    (334606 return(334604 call !(334602 call == a b)))
  }
  { scopeless type
    bool[10]
  }
  function <[334623](const  ref arg a[334620] :
  (334619 call set unknown t[334615] ?[260]), const  ref arg b[334630] :
  (334629 call set t ?[260])) : _unknown[51]
  {
    if(334647 call _cond_test(334642 call >=(334635 call . a c"size")(334639 call . b c"size")))
    {
      (334645 return 0)
    }
    (334657 return(334655 call <= a b))
  }
  { scopeless type
    bool[10]
  }
  function <=[334673](const  ref arg a[334670] :
  (334669 call set unknown t[334665] ?[260]), const  ref arg b[334680] :
  (334679 call set t ?[260])) : _unknown[51]
  {
    if(334697 call _cond_test(334692 call >(334685 call . a c"size")(334689 call . b c"size")))
    {
      (334695 return 0)
    }
    unknown result[334704] 1
    (334707 'end of statement')
    if(334798 call _cond_test(334716 call &&(334709 call . a c"parSafe")(334713 call . b c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[334740] "index var" "insert auto destroy"
        iterated expressions:
          a
        shadow variables:
        other variables
          forall body
        {
          if(334734 call _cond_test(334727 call !(334726 call(334721 call . b c"contains") x)))
          {
            (334731 call = result 0)
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[334764] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[334765] "expr temp" "temp"
        (334774 'move' _iterator[334765](334772 call _getIterator a))
        Defer
        {
          {
            (334790 call _freeIterator _iterator[334765])
          }
        }
        { scopeless type
          (334779 'move' _indexOfInterest[334764](334776 call iteratorIndex _iterator[334765]))
        }
        ForLoop[334766]
        {
          unknown x[334783] "index var" "insert auto destroy"
          (334785 'move' x[334783] _indexOfInterest[334764])
          if(334759 call _cond_test(334754 call !(334753 call(334748 call . b c"contains") x)))
          {
            (334757 return 0)
          }
          label _continueLabel[334769]
          _indexOfInterest[334764]
          _iterator[334765]
        }
        label _breakLabel[334770]
      }
    }
    (334803 return result)
  }
  { scopeless type
    bool[10]
  }
  function >[334819](const  ref arg a[334816] :
  (334815 call set unknown t[334811] ?[260]), const  ref arg b[334826] :
  (334825 call set t ?[260])) : _unknown[51]
  {
    if(334843 call _cond_test(334838 call <=(334831 call . a c"size")(334835 call . b c"size")))
    {
      (334841 return 0)
    }
    (334853 return(334851 call >= a b))
  }
  { scopeless type
    bool[10]
  }
  function >=[334869](const  ref arg a[334866] :
  (334865 call set unknown t[334861] ?[260]), const  ref arg b[334876] :
  (334875 call set t ?[260])) : _unknown[51]
  {
    if(334893 call _cond_test(334888 call <(334881 call . a c"size")(334885 call . b c"size")))
    {
      (334891 return 0)
    }
    unknown result[334900] 1
    (334903 'end of statement')
    if(334994 call _cond_test(334912 call &&(334905 call . a c"parSafe")(334909 call . b c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[334936] "index var" "insert auto destroy"
        iterated expressions:
          b
        shadow variables:
        other variables
          forall body
        {
          if(334930 call _cond_test(334923 call !(334922 call(334917 call . a c"contains") x)))
          {
            (334927 call = result 0)
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[334960] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[334961] "expr temp" "temp"
        (334970 'move' _iterator[334961](334968 call _getIterator b))
        Defer
        {
          {
            (334986 call _freeIterator _iterator[334961])
          }
        }
        { scopeless type
          (334975 'move' _indexOfInterest[334960](334972 call iteratorIndex _iterator[334961]))
        }
        ForLoop[334962]
        {
          unknown x[334979] "index var" "insert auto destroy"
          (334981 'move' x[334979] _indexOfInterest[334960])
          if(334955 call _cond_test(334950 call !(334949 call(334944 call . a c"contains") x)))
          {
            (334953 return 0)
          }
          label _continueLabel[334965]
          _indexOfInterest[334960]
          _iterator[334961]
        }
        label _breakLabel[334966]
      }
    }
    (334999 return result)
  }
  { scopeless type
    bool[10]
  }
}