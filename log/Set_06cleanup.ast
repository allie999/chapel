AST dump for Set after pass cleanup.
Module use list: 

{
  (353074 'use' ChapelStandard)
  (331311 'import' ChapelLocks)
  (331315 'use' IO)
  (331318 'use' Reflection)
  (331321 'use' ChapelHashtable)
  unknown _sanityChecks[331324] "no doc" "param" "private" 1
  (331327 'end of statement')
  function _sanity[331334](arg expr[331331] :
  bool[10]) : _unknown[51] "inline" "private" "no return value for void"
  {
    if(331342 call _cond_test _sanityChecks)
    {
      (331340 call assert expr)
    }
  }
  unknown _lockType[331354] "no doc" "type variable"(331351 call . ChapelLocks c"chpl_LocalSpinlock")
  function _LockWrapper[331395].lock[331368](arg _mt[331399]:_MT[238], arg this[331397]:_LockWrapper[331395]) : _unknown[51] "inline" "method" "primary method" "no return value for void"
  {
    (331375 call(331371 call . lock$ c"lock"))
  }
  function _LockWrapper[331395].unlock[331382](arg _mt[331403]:_MT[238], arg this[331401]:_LockWrapper[331395]) : _unknown[51] "inline" "method" "primary method" "no return value for void"
  {
    (331389 call(331385 call . lock$ c"unlock"))
  }
  type _LockWrapper[331395] unknown lock$[331362](331358 'new'(331361 call _lockType))
  function _checkElementType[331410](arg t[331408]:_any[178](?)) : _unknown[51] "no doc" "no return value for void"
  {
    if(331467 call _cond_test(331415 call isGenericType t))
    {
      (331442 call compilerWarning(331438 call + "creating a set with element type "(331436 call _cast string[26] t)) 2)
      (331465 call compilerError "set element type cannot currently be generic" 2)
    }
  }
  function set[333168](?).init[331509](arg _mt[333172]:_MT[238], arg this[333170]:set[333168](?), arg eltType[331507]:_any[178](?), param arg parSafe[331512] =
  0) : _unknown[51] "method" "primary method" "no return value for void"
  {
    (331518 call _checkElementType eltType)
    (331526 call =(331522 call . this c"eltType") eltType)
    (331534 call =(331530 call . this c"parSafe") parSafe)
  }
  function set[333168](?)._addElem[331545](arg _mt[333176]:_MT[238], arg this[333174]:set[333168](?), in arg elem[331542] :
  eltType) : _unknown[51] "method" "primary method" "no doc"
  {
    unknown tmp[331560] "temp"(331559 call(331554 call . _htb c"findAvailableSlot") elem)
    (331567 call _check_tuple_var_decl tmp[331560] 2)
    unknown isFullSlot[331548](331561 call tmp[331560] 0)
    unknown idx[331550](331564 call tmp[331560] 1)
    (331572 'end of statement')
    if(331578 call _cond_test isFullSlot)
    {
      (331576 return 0)
    }
    (331591 call(331584 call . _htb c"fillSlot") idx elem none[57])
    (331594 return 1)
  }
  { scopeless type
    bool[10]
  }
  function set[333168](?).init[331603](arg _mt[333180]:_MT[238], arg this[333178]:set[333168](?), arg eltType[331601]:_any[178](?), arg iterable[331605]:_any[178](?), param arg parSafe[331608] =
  0) : _unknown[51] "method" "primary method" "no return value for void"
  {
    (331625 call _checkElementType eltType)
    (331633 call =(331629 call . this c"eltType") eltType)
    (331641 call =(331637 call . this c"parSafe") parSafe)
    (331649 call(331645 call . this c"complete"))
    {
      unknown _indexOfInterest[331658] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[331659] "expr temp" "temp"
      (331668 'move' _iterator[331659](331666 call _getIterator iterable))
      Defer
      {
        {
          (331684 call _freeIterator _iterator[331659])
        }
      }
      { scopeless type
        (331673 'move' _indexOfInterest[331658](331670 call iteratorIndex _iterator[331659]))
      }
      ForLoop[331660]
      {
        unknown elem[331677] "index var" "insert auto destroy"
        (331679 'move' elem[331677] _indexOfInterest[331658])
        (331656 call _addElem elem)
        label _continueLabel[331663]
        _indexOfInterest[331658]
        _iterator[331659]
      }
      label _breakLabel[331664]
    }
  }
  where {
    (331615 call canResolveMethod iterable "these")
  }
  {
    (331620 call <(331617 'lifetime_of' this)(331619 'lifetime_of' iterable))
  }
  function set[333168](?).init=[331706](arg _mt[333184]:_MT[238], arg this[333182]:set[333168](?), const  ref arg other[331703] :
  (331702 call set unknown t[331698] ?[260])) : _unknown[51] "method" "primary method" "no return value for void"
  {
    (331719 call =(331715 call . this c"eltType") t)
    (331731 call =(331724 call . this c"parSafe")(331728 call . other c"parSafe"))
    (331739 call(331735 call . this c"complete"))
    if(331829 call _cond_test(331745 call !(331744 call isCopyableType eltType)))
    {
      (331827 call compilerError(331824 call +(331805 call +(331799 call +(331780 call +(331773 call +(331770 call + "Cannot initialize "(331768 call _cast string[26](331766 'typeof' this))) " from ")(331778 call _cast string[26](331776 'typeof' other))) " because element type ")(331803 call _cast string[26] eltType)) " is not copyable"))
    }
    {
      unknown _indexOfInterest[331841] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[331842] "expr temp" "temp"
      (331851 'move' _iterator[331842](331849 call _getIterator other))
      Defer
      {
        {
          (331867 call _freeIterator _iterator[331842])
        }
      }
      { scopeless type
        (331856 'move' _indexOfInterest[331841](331853 call iteratorIndex _iterator[331842]))
      }
      ForLoop[331843]
      {
        unknown elem[331860] "index var" "insert auto destroy"
        (331862 'move' elem[331860] _indexOfInterest[331841])
        (331839 call _addElem elem)
        label _continueLabel[331846]
        _indexOfInterest[331841]
        _iterator[331842]
      }
      label _breakLabel[331847]
    }
  }
  {
    (331712 call <(331709 'lifetime_of' this)(331711 'lifetime_of' other))
  }
  function set[333168](?)._enter[331879](arg _mt[333188]:_MT[238], arg this[333186]:set[333168](?)) : _unknown[51] "inline" "method" "primary method" "no doc" "no return value for void"
  {
    if(331902 call _cond_test parSafe)
    {
      const tmp[331894] "const" "temp"
      (331896 'move' tmp[331894](331892 'deref'(331891 '_wide_get_locale' this)))
      {
        {
          (331888 call(331884 call . _lock$ c"lock"))
        }
        (331899 'on block' 0 tmp[331894])
      }
    }
  }
  function set[333168](?)._leave[331912](arg _mt[333192]:_MT[238], arg this[333190]:set[333168](?)) : _unknown[51] "inline" "method" "primary method" "no doc" "no return value for void"
  {
    if(331935 call _cond_test parSafe)
    {
      const tmp[331927] "const" "temp"
      (331929 'move' tmp[331927](331925 'deref'(331924 '_wide_get_locale' this)))
      {
        {
          (331921 call(331917 call . _lock$ c"unlock"))
        }
        (331932 'on block' 0 tmp[331927])
      }
    }
  }
  function set[333168](?).add[331949](arg _mt[333196]:_MT[238], ref arg this[333194]:set[333168](?), in arg x[331946] :
  eltType) : _unknown[51] "method" "primary method" "no return value for void"
  {
    (331959 call _enter)
    Defer
    {
      { scopeless
        (331964 call _leave)
      }
    }
    (331971 call _addElem x)
  }
  {
    (331955 call <(331952 'lifetime_of' this)(331954 'lifetime_of' x))
  }
  function set[333168](?).contains[331982](arg _mt[333200]:_MT[238], const arg this[333198]:set[333168](?), const  ref arg x[331979] :
  eltType) : _unknown[51] "method" "primary method"
  {
    unknown result[331986] 0
    (331989 'end of statement')
    const tmp[332033] "const" "temp"
    (332035 'move' tmp[332033](332031 'deref'(332030 '_wide_get_locale' this)))
    {
      {
        (331994 call _enter)
        Defer
        {
          { scopeless
            (331999 call _leave)
          }
        }
        unknown tmp[332015] "temp"(332014 call(332009 call . _htb c"findFullSlot") x)
        (332019 call _check_tuple_var_decl tmp[332015] 2)
        unknown hasFoundSlot[332003](332016 call tmp[332015] 0)
        (332024 'end of statement')
        (332027 call = result hasFoundSlot)
      }
      (332038 'on block' 0 tmp[332033])
    }
    (332042 return result)
  }
  { scopeless type
    bool[10]
  }
  function set[333168](?).isDisjoint[332057](arg _mt[333204]:_MT[238], const arg this[333202]:set[333168](?), const  ref arg other[332054] :
  (332053 call set eltType ?[260])) : _unknown[51] "method" "primary method"
  {
    unknown result[332061] 1
    (332064 'end of statement')
    const tmp[332156] "const" "temp"
    (332158 'move' tmp[332156](332154 'deref'(332153 '_wide_get_locale' this)))
    {
      {
        (332069 call _enter)
        Defer
        {
          { scopeless
            (332074 call _leave)
          }
        }
        if(332149 call _cond_test(332091 call !(332089 call ||(332080 call == size 0)(332087 call ==(332083 call . other c"size") 0))))
        {
          {
            unknown _indexOfInterest[332115] "an _indexOfInterest or chpl__followIdx variable" "temp"
            unknown _iterator[332116] "expr temp" "temp"
            (332125 'move' _iterator[332116](332123 call _getIterator other))
            Defer
            {
              {
                (332141 call _freeIterator _iterator[332116])
              }
            }
            { scopeless type
              (332130 'move' _indexOfInterest[332115](332127 call iteratorIndex _iterator[332116]))
            }
            ForLoop[332117]
            {
              unknown x[332134] "index var" "insert auto destroy"
              (332136 'move' x[332134] _indexOfInterest[332115])
              if(332111 call _cond_test(332101 call(332096 call . this c"contains") x))
              {
                (332104 call = result 0)
                break nil[44]
              }
              label _continueLabel[332120]
              _indexOfInterest[332115]
              _iterator[332116]
            }
            label _breakLabel[332121]
          }
        }
      }
      (332161 'on block' 0 tmp[332156])
    }
    (332165 return result)
  }
  { scopeless type
    bool[10]
  }
  function set[333168](?).isIntersecting[332180](arg _mt[333208]:_MT[238], const arg this[333206]:set[333168](?), const  ref arg other[332177] :
  (332176 call set eltType ?[260])) : _unknown[51] "method" "primary method"
  {
    (332189 return(332187 call !(332186 call isDisjoint other)))
  }
  { scopeless type
    bool[10]
  }
  function set[333168](?).remove[332201](arg _mt[333212]:_MT[238], ref arg this[333210]:set[333168](?), const  ref arg x[332198] :
  eltType) : _unknown[51] "method" "primary method"
  {
    unknown result[332205] 0
    (332208 'end of statement')
    const tmp[332288] "const" "temp"
    (332290 'move' tmp[332288](332286 'deref'(332285 '_wide_get_locale' this)))
    {
      {
        (332213 call _enter)
        Defer
        {
          { scopeless
            (332218 call _leave)
          }
        }
        unknown tmp[332234] "temp"(332233 call(332228 call . _htb c"findFullSlot") x)
        (332241 call _check_tuple_var_decl tmp[332234] 2)
        unknown hasFoundSlot[332222](332235 call tmp[332234] 0)
        unknown idx[332224](332238 call tmp[332234] 1)
        (332246 'end of statement')
        if(332281 call _cond_test hasFoundSlot)
        {
          unknown key[332249] eltType
          (332252 'end of statement')
          unknown val[332255] nothing[7]
          (332258 'end of statement')
          (332267 call(332260 call . _htb c"clearSlot") idx key val)
          (332274 call(332270 call . _htb c"maybeShrinkAfterRemove"))
          (332278 call = result 1)
        }
      }
      (332293 'on block' 0 tmp[332288])
    }
    (332297 return result)
  }
  { scopeless type
    bool[10]
  }
  function set[333168](?).clear[332304](arg _mt[333216]:_MT[238], ref arg this[333214]:set[333168](?)) : _unknown[51] "method" "primary method" "no return value for void"
  {
    const tmp[332414] "const" "temp"
    (332416 'move' tmp[332414](332412 'deref'(332411 '_wide_get_locale' this)))
    {
      {
        (332309 call _enter)
        Defer
        {
          { scopeless
            (332314 call _leave)
          }
        }
        {
          unknown _indexOfInterest[332361] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[332362] "expr temp" "temp"
          (332371 'move' _iterator[332362](332369 call _getIterator(332381 call chpl_direct_counted_range_iter 0(332377 call . _htb c"tableSize"))))
          Defer
          {
            {
              (332397 call _freeIterator _iterator[332362])
            }
          }
          { scopeless type
            (332386 'move' _indexOfInterest[332361](332383 call iteratorIndex _iterator[332362]))
          }
          ForLoop[332363]
          {
            unknown idx[332390] "index var" "insert auto destroy"
            (332392 'move' idx[332390] _indexOfInterest[332361])
            {
              if(332356 call _cond_test(332334 call(332329 call . _htb c"isSlotFull") idx))
              {
                unknown key[332336] eltType
                (332339 'end of statement')
                unknown val[332342] nothing[7]
                (332345 'end of statement')
                (332354 call(332347 call . _htb c"clearSlot") idx key val)
              }
            }
            label _continueLabel[332366]
            _indexOfInterest[332361]
            _iterator[332362]
          }
          label _breakLabel[332367]
        }
        (332409 call(332405 call . _htb c"maybeShrinkAfterRemove"))
      }
      (332419 'on block' 0 tmp[332414])
    }
  }
  function set[333168](?).these[332427](arg _mt[333220]:_MT[238], const arg this[333218]:set[333168](?)) : _unknown[51] "iterator fn" "method" "primary method" "no return value for void"
  {
    {
      unknown _indexOfInterest[332463] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[332464] "expr temp" "temp"
      (332473 'move' _iterator[332464](332471 call _getIterator(332483 call chpl_direct_counted_range_iter 0(332479 call . _htb c"tableSize"))))
      Defer
      {
        {
          (332499 call _freeIterator _iterator[332464])
        }
      }
      { scopeless type
        (332488 'move' _indexOfInterest[332463](332485 call iteratorIndex _iterator[332464]))
      }
      ForLoop[332465]
      {
        unknown idx[332492] "index var" "insert auto destroy"
        (332494 'move' idx[332492] _indexOfInterest[332463])
        if(332458 call _cond_test(332445 call(332440 call . _htb c"isSlotFull") idx))
        {
          (332456 yield(332453 call .(332452 call(332447 call . _htb c"table") idx) c"key"))
        }
        label _continueLabel[332468]
        _indexOfInterest[332463]
        _iterator[332464]
      }
      label _breakLabel[332469]
    }
  }
  function set[333168](?).these[332513](arg _mt[333224]:_MT[238], const arg this[333222]:set[333168](?), param arg tag[332511]:_any[178](?)) : _unknown[51] "iterator fn" "method" "primary method" "no doc" "no return value for void"
  {
    unknown space[332531](332529 call #(332523 call chpl_build_low_bounded_range 0)(332526 call . _htb c"tableSize"))
    (332534 'end of statement')
    {
      unknown _indexOfInterest[332568] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[332569] "expr temp" "temp"
      (332578 'move' _iterator[332569](332576 call _getIterator(332543 call(332538 call . space c"these") tag)))
      Defer
      {
        {
          (332595 call _freeIterator _iterator[332569])
        }
      }
      { scopeless type
        (332584 'move' _indexOfInterest[332568](332581 call iteratorIndex _iterator[332569]))
      }
      ForLoop[332570]
      {
        unknown idx[332588] "index var" "insert auto destroy"
        (332590 'move' idx[332588] _indexOfInterest[332568])
        if(332563 call _cond_test(332550 call(332545 call . _htb c"isSlotFull") idx))
        {
          (332561 yield(332558 call .(332557 call(332552 call . _htb c"table") idx) c"key"))
        }
        label _continueLabel[332573]
        _indexOfInterest[332568]
        _iterator[332569]
      }
      label _breakLabel[332574]
    }
  }
  where {
    (332520 call == tag(332517 call . iterKind c"standalone"))
  }
  function set[333168](?).these[332609](arg _mt[333228]:_MT[238], const arg this[333226]:set[333168](?), param arg tag[332607]:_any[178](?)) : _unknown[51] "iterator fn" "method" "primary method" "no doc" "no return value for void"
  {
    unknown space[332627](332625 call #(332619 call chpl_build_low_bounded_range 0)(332622 call . _htb c"tableSize"))
    (332630 'end of statement')
    {
      unknown _indexOfInterest[332644] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[332645] "expr temp" "temp"
      (332654 'move' _iterator[332645](332652 call _getIterator(332639 call(332634 call . space c"these") tag)))
      Defer
      {
        {
          (332671 call _freeIterator _iterator[332645])
        }
      }
      { scopeless type
        (332660 'move' _indexOfInterest[332644](332657 call iteratorIndex _iterator[332645]))
      }
      ForLoop[332646]
      {
        unknown followThis[332664] "index var" "insert auto destroy"
        (332666 'move' followThis[332664] _indexOfInterest[332644])
        {
          (332641 yield followThis)
        }
        label _continueLabel[332649]
        _indexOfInterest[332644]
        _iterator[332645]
      }
      label _breakLabel[332650]
    }
  }
  where {
    (332616 call == tag(332613 call . iterKind c"leader"))
  }
  function set[333168](?).these[332685](arg _mt[333232]:_MT[238], const arg this[333230]:set[333168](?), param arg tag[332683]:_any[178](?), arg followThis[332687]:_any[178](?)) : _unknown[51] "iterator fn" "method" "primary method" "no doc" "no return value for void"
  {
    {
      unknown _indexOfInterest[332725] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[332726] "expr temp" "temp"
      (332735 'move' _iterator[332726](332733 call _getIterator(332700 call followThis 0)))
      Defer
      {
        {
          (332752 call _freeIterator _iterator[332726])
        }
      }
      { scopeless type
        (332741 'move' _indexOfInterest[332725](332738 call iteratorIndex _iterator[332726]))
      }
      ForLoop[332727]
      {
        unknown idx[332745] "index var" "insert auto destroy"
        (332747 'move' idx[332745] _indexOfInterest[332725])
        if(332720 call _cond_test(332707 call(332702 call . _htb c"isSlotFull") idx))
        {
          (332718 yield(332715 call .(332714 call(332709 call . _htb c"table") idx) c"key"))
        }
        label _continueLabel[332730]
        _indexOfInterest[332725]
        _iterator[332726]
      }
      label _breakLabel[332731]
    }
  }
  where {
    (332694 call == tag(332691 call . iterKind c"follower"))
  }
  function set[333168](?).writeThis[332769](arg _mt[333236]:_MT[238], const arg this[333234]:set[333168](?), arg ch[332766] :
  channel) : _unknown[51] throws "method" "primary method" "no return value for void"
  {
    const tmp[332871] "const" "temp"
    (332873 'move' tmp[332871](332869 'deref'(332868 '_wide_get_locale' this)))
    {
      {
        (332774 call _enter)
        Defer
        {
          { scopeless
            (332779 call _leave)
          }
        }
        unknown count[332784] 1
        (332787 'end of statement')
        (332790 call <~> ch "{")
        {
          unknown _indexOfInterest[332830] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[332831] "expr temp" "temp"
          (332840 'move' _iterator[332831](332838 call _getIterator this))
          Defer
          {
            {
              (332856 call _freeIterator _iterator[332831])
            }
          }
          { scopeless type
            (332845 'move' _indexOfInterest[332830](332842 call iteratorIndex _iterator[332831]))
          }
          ForLoop[332832]
          {
            unknown x[332849] "index var" "insert auto destroy"
            (332851 'move' x[332849] _indexOfInterest[332830])
            {
              if(332825 call _cond_test(332803 call <= count(332801 call -(332797 call . _htb c"tableNumFullSlots") 1)))
              {
                (332807 call += count 1)
                (332816 call <~>(332813 call <~> ch x) ", ")
              }
              {
                (332821 call <~> ch x)
              }
            }
            label _continueLabel[332835]
            _indexOfInterest[332830]
            _iterator[332831]
          }
          label _breakLabel[332836]
        }
        (332865 call <~> ch "}")
      }
      (332876 'on block' 0 tmp[332871])
    }
  }
  function set[333168](?).isEmpty[332884](arg _mt[333240]:_MT[238], const arg this[333238]:set[333168](?)) : _unknown[51] "inline" "method" "primary method"
  {
    unknown result[332888] 0
    (332891 'end of statement')
    const tmp[332919] "const" "temp"
    (332921 'move' tmp[332919](332917 'deref'(332916 '_wide_get_locale' this)))
    {
      {
        (332896 call _enter)
        Defer
        {
          { scopeless
            (332901 call _leave)
          }
        }
        (332913 call = result(332911 call ==(332907 call . _htb c"tableNumFullSlots") 0))
      }
      (332924 'on block' 0 tmp[332919])
    }
    (332928 return result)
  }
  { scopeless type
    bool[10]
  }
  function set[333168](?).size[332935](arg _mt[333244]:_MT[238], const arg this[333242]:set[333168](?)) : _unknown[51] "inline" "method" "primary method" "no parens"
  {
    unknown result[332938] 0
    (332941 'end of statement')
    const tmp[332966] "const" "temp"
    (332968 'move' tmp[332966](332964 'deref'(332963 '_wide_get_locale' this)))
    {
      {
        (332946 call _enter)
        Defer
        {
          { scopeless
            (332951 call _leave)
          }
        }
        (332960 call = result(332957 call . _htb c"tableNumFullSlots"))
      }
      (332971 'on block' 0 tmp[332966])
    }
    (332975 return result)
  }
  function set[333168](?).toArray[332981](arg _mt[333248]:_MT[238], const arg this[333246]:set[333168](?)) : _unknown[51] "method" "primary method"
  {
    (332989 call _enter)
    Defer
    {
      { scopeless
        (332994 call _leave)
      }
    }
    unknown result[333013](333011 call chpl__buildArrayRuntimeType(333009 call chpl__ensureDomainExpr(333005 call #(332999 call chpl_build_low_bounded_range 0)(333002 call . _htb c"tableNumFullSlots"))) eltType)
    (333016 'end of statement')
    if(333053 call _cond_test(333021 call !(333020 call isCopyableType eltType)))
    {
      (333051 call compilerError(333048 call +(333045 call + "Cannot create array because set element type "(333043 call _cast string[26] eltType)) " is not copyable"))
    }
    const tmp[333153] "const" "temp"
    (333155 'move' tmp[333153](333151 'deref'(333150 '_wide_get_locale' this)))
    {
      {
        if(333145 call _cond_test(333064 call !=(333060 call . _htb c"tableNumFullSlots") 0))
        {
          unknown count[333067] 0
          (333070 'end of statement')
          unknown array[333087](333085 call chpl__buildArrayRuntimeType(333083 call chpl__ensureDomainExpr(333079 call #(333073 call chpl_build_low_bounded_range 0)(333076 call . _htb c"tableNumFullSlots"))) eltType)
          (333090 'end of statement')
          {
            unknown _indexOfInterest[333107] "an _indexOfInterest or chpl__followIdx variable" "temp"
            unknown _iterator[333108] "expr temp" "temp"
            (333117 'move' _iterator[333108](333115 call _getIterator this))
            Defer
            {
              {
                (333133 call _freeIterator _iterator[333108])
              }
            }
            { scopeless type
              (333122 'move' _indexOfInterest[333107](333119 call iteratorIndex _iterator[333108]))
            }
            ForLoop[333109]
            {
              unknown x[333126] "index var" "insert auto destroy"
              (333128 'move' x[333126] _indexOfInterest[333107])
              {
                (333098 call =(333096 call array count) x)
                (333104 call += count 1)
              }
              label _continueLabel[333112]
              _indexOfInterest[333107]
              _iterator[333108]
            }
            label _breakLabel[333113]
          }
          (333142 call = result array)
        }
      }
      (333158 'on block' 0 tmp[333153])
    }
    (333162 return result)
  }
  { scopeless type
    (332984 call chpl__buildArrayRuntimeType nil[44] eltType)
  }
  type set[333168](?) unknown eltType[331475] "type variable" unknown parSafe[331479] "param" 0 unknown _lock$[331492] "no doc"(331489 IfExpr  parSafe then
  { scopeless
    (331484 'new'(331487 call _LockWrapper))
  } else
  { scopeless
    none[57]
  } ) unknown _htb[331501] "no doc"(331500 call chpl__hashtable eltType nothing[7])
  function =[333262](ref arg lhs[333259] :
  (333258 call set unknown t[333254] ?[260]), const  ref arg rhs[333269] :
  (333268 call set t ?[260])) : _unknown[51] "assignop" "no return value for void"
  {
    (333277 call(333273 call . lhs c"clear"))
    {
      unknown _indexOfInterest[333290] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[333291] "expr temp" "temp"
      (333300 'move' _iterator[333291](333298 call _getIterator rhs))
      Defer
      {
        {
          (333316 call _freeIterator _iterator[333291])
        }
      }
      { scopeless type
        (333305 'move' _indexOfInterest[333290](333302 call iteratorIndex _iterator[333291]))
      }
      ForLoop[333292]
      {
        unknown x[333309] "index var" "insert auto destroy"
        (333311 'move' x[333309] _indexOfInterest[333290])
        (333288 call(333283 call . lhs c"add") x)
        label _continueLabel[333295]
        _indexOfInterest[333290]
        _iterator[333291]
      }
      label _breakLabel[333296]
    }
  }
  function |[333336](const  ref arg a[333333] :
  (333332 call set unknown t[333328] ?[260]), const  ref arg b[333343] :
  (333342 call set t ?[260])) : _unknown[51]
  {
    unknown result[333364](333363 call set t(333361 call ||(333354 call . a c"parSafe")(333358 call . b c"parSafe")))
    (333367 'end of statement')
    (333371 call = result a)
    (333376 call |= result b)
    (333380 return result)
  }
  { scopeless type
    (333349 call set t)
  }
  function |=[333396](ref arg lhs[333393] :
  (333392 call set unknown t[333388] ?[260]), const  ref arg rhs[333403] :
  (333402 call set t ?[260])) : _unknown[51] "assignop" "no return value for void"
  {
    {
      unknown _indexOfInterest[333416] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[333417] "expr temp" "temp"
      (333426 'move' _iterator[333417](333424 call _getIterator rhs))
      Defer
      {
        {
          (333442 call _freeIterator _iterator[333417])
        }
      }
      { scopeless type
        (333431 'move' _indexOfInterest[333416](333428 call iteratorIndex _iterator[333417]))
      }
      ForLoop[333418]
      {
        unknown x[333435] "index var" "insert auto destroy"
        (333437 'move' x[333435] _indexOfInterest[333416])
        (333414 call(333409 call . lhs c"add") x)
        label _continueLabel[333421]
        _indexOfInterest[333416]
        _iterator[333417]
      }
      label _breakLabel[333422]
    }
  }
  function +[333463](const  ref arg a[333460] :
  (333459 call set unknown t[333455] ?[260]), const  ref arg b[333470] :
  (333469 call set t ?[260])) : _unknown[51]
  {
    (333482 return(333480 call | a b))
  }
  { scopeless type
    (333477 call set t ?[260])
  }
  function +=[333499](ref arg lhs[333496] :
  (333495 call set unknown t[333491] ?[260]), const  ref arg rhs[333506] :
  (333505 call set t ?[260])) : _unknown[51] "assignop" "no return value for void"
  {
    (333511 call |= lhs rhs)
  }
  function -[333528](const  ref arg a[333525] :
  (333524 call set unknown t[333520] ?[260]), const  ref arg b[333535] :
  (333534 call set t ?[260])) : _unknown[51]
  {
    unknown result[333557](333542 'new'(333556 call set t(333554 call ||(333547 call . a c"parSafe")(333551 call . b c"parSafe"))))
    (333560 'end of statement')
    if(333659 call _cond_test(333570 call &&(333563 call . a c"parSafe")(333567 call . b c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[333597] "index var" "insert auto destroy"
        iterated expressions:
          a
        shadow variables:
        other variables
          forall body
        {
          if(333591 call _cond_test(333581 call !(333580 call(333575 call . b c"contains") x)))
          {
            (333589 call(333584 call . result c"add") x)
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[333625] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[333626] "expr temp" "temp"
        (333635 'move' _iterator[333626](333633 call _getIterator a))
        Defer
        {
          {
            (333651 call _freeIterator _iterator[333626])
          }
        }
        { scopeless type
          (333640 'move' _indexOfInterest[333625](333637 call iteratorIndex _iterator[333626]))
        }
        ForLoop[333627]
        {
          unknown x[333644] "index var" "insert auto destroy"
          (333646 'move' x[333644] _indexOfInterest[333625])
          if(333620 call _cond_test(333610 call !(333609 call(333604 call . b c"contains") x)))
          {
            (333618 call(333613 call . result c"add") x)
          }
          label _continueLabel[333630]
          _indexOfInterest[333625]
          _iterator[333626]
        }
        label _breakLabel[333631]
      }
    }
    (333664 return result)
  }
  { scopeless type
    (333541 call set t)
  }
  function -=[333680](ref arg lhs[333677] :
  (333676 call set unknown t[333672] ?[260]), const  ref arg rhs[333687] :
  (333686 call set t ?[260])) : _unknown[51] "assignop" "no return value for void"
  {
    if(333759 call _cond_test(333698 call &&(333691 call . lhs c"parSafe")(333695 call . rhs c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[333711] "index var" "insert auto destroy"
        iterated expressions:
          rhs
        shadow variables:
        other variables
          forall body
        {
          (333708 call(333703 call . lhs c"remove") x)
        }
      }
    }
    {
      {
        unknown _indexOfInterest[333725] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[333726] "expr temp" "temp"
        (333735 'move' _iterator[333726](333733 call _getIterator rhs))
        Defer
        {
          {
            (333751 call _freeIterator _iterator[333726])
          }
        }
        { scopeless type
          (333740 'move' _indexOfInterest[333725](333737 call iteratorIndex _iterator[333726]))
        }
        ForLoop[333727]
        {
          unknown x[333744] "index var" "insert auto destroy"
          (333746 'move' x[333744] _indexOfInterest[333725])
          (333723 call(333718 call . lhs c"remove") x)
          label _continueLabel[333730]
          _indexOfInterest[333725]
          _iterator[333726]
        }
        label _breakLabel[333731]
      }
    }
  }
  function &[333777](const  ref arg a[333774] :
  (333773 call set unknown t[333769] ?[260]), const  ref arg b[333784] :
  (333783 call set t ?[260])) : _unknown[51]
  {
    unknown result[333805](333804 call set t(333802 call ||(333795 call . a c"parSafe")(333799 call . b c"parSafe")))
    (333808 'end of statement')
    if(334016 call _cond_test(333818 call <=(333811 call . a c"size")(333815 call . b c"size")))
    {
      if(333913 call _cond_test(333828 call &&(333821 call . a c"parSafe")(333825 call . b c"parSafe")))
      {
        Forall {
          induction variables:
            
            unknown x[333853] "index var" "insert auto destroy"
          iterated expressions:
            a
          shadow variables:
          other variables
            forall body
          {
            if(333847 call _cond_test(333838 call(333833 call . b c"contains") x))
            {
              (333845 call(333840 call . result c"add") x)
            }
          }
        }
      }
      {
        {
          unknown _indexOfInterest[333879] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[333880] "expr temp" "temp"
          (333889 'move' _iterator[333880](333887 call _getIterator a))
          Defer
          {
            {
              (333905 call _freeIterator _iterator[333880])
            }
          }
          { scopeless type
            (333894 'move' _indexOfInterest[333879](333891 call iteratorIndex _iterator[333880]))
          }
          ForLoop[333881]
          {
            unknown x[333898] "index var" "insert auto destroy"
            (333900 'move' x[333898] _indexOfInterest[333879])
            if(333874 call _cond_test(333865 call(333860 call . b c"contains") x))
            {
              (333872 call(333867 call . result c"add") x)
            }
            label _continueLabel[333884]
            _indexOfInterest[333879]
            _iterator[333880]
          }
          label _breakLabel[333885]
        }
      }
    }
    {
      if(334011 call _cond_test(333926 call &&(333919 call . a c"parSafe")(333923 call . b c"parSafe")))
      {
        Forall {
          induction variables:
            
            unknown x[333951] "index var" "insert auto destroy"
          iterated expressions:
            b
          shadow variables:
          other variables
            forall body
          {
            if(333945 call _cond_test(333936 call(333931 call . a c"contains") x))
            {
              (333943 call(333938 call . result c"add") x)
            }
          }
        }
      }
      {
        {
          unknown _indexOfInterest[333977] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[333978] "expr temp" "temp"
          (333987 'move' _iterator[333978](333985 call _getIterator b))
          Defer
          {
            {
              (334003 call _freeIterator _iterator[333978])
            }
          }
          { scopeless type
            (333992 'move' _indexOfInterest[333977](333989 call iteratorIndex _iterator[333978]))
          }
          ForLoop[333979]
          {
            unknown x[333996] "index var" "insert auto destroy"
            (333998 'move' x[333996] _indexOfInterest[333977])
            if(333972 call _cond_test(333963 call(333958 call . a c"contains") x))
            {
              (333970 call(333965 call . result c"add") x)
            }
            label _continueLabel[333982]
            _indexOfInterest[333977]
            _iterator[333978]
          }
          label _breakLabel[333983]
        }
      }
    }
    (334021 return result)
  }
  { scopeless type
    (333790 call set t)
  }
  function &=[334037](ref arg lhs[334034] :
  (334033 call set unknown t[334029] ?[260]), const  ref arg rhs[334044] :
  (334043 call set t ?[260])) : _unknown[51] "assignop" "no return value for void"
  {
    unknown result[334061](334060 call set t(334058 call ||(334051 call . lhs c"parSafe")(334055 call . rhs c"parSafe")))
    (334064 'end of statement')
    if(334159 call _cond_test(334074 call &&(334067 call . lhs c"parSafe")(334071 call . rhs c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[334099] "index var" "insert auto destroy"
        iterated expressions:
          lhs
        shadow variables:
        other variables
          forall body
        {
          if(334093 call _cond_test(334084 call(334079 call . rhs c"contains") x))
          {
            (334091 call(334086 call . result c"add") x)
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[334125] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[334126] "expr temp" "temp"
        (334135 'move' _iterator[334126](334133 call _getIterator lhs))
        Defer
        {
          {
            (334151 call _freeIterator _iterator[334126])
          }
        }
        { scopeless type
          (334140 'move' _indexOfInterest[334125](334137 call iteratorIndex _iterator[334126]))
        }
        ForLoop[334127]
        {
          unknown x[334144] "index var" "insert auto destroy"
          (334146 'move' x[334144] _indexOfInterest[334125])
          if(334120 call _cond_test(334111 call(334106 call . rhs c"contains") x))
          {
            (334118 call(334113 call . result c"add") x)
          }
          label _continueLabel[334130]
          _indexOfInterest[334125]
          _iterator[334126]
        }
        label _breakLabel[334131]
      }
    }
    (334165 call = lhs result)
  }
  function ^[334181](const  ref arg a[334178] :
  (334177 call set unknown t[334173] ?[260]), const  ref arg b[334188] :
  (334187 call set t ?[260])) : _unknown[51]
  {
    unknown result[334209](334208 call set t(334206 call ||(334199 call . a c"parSafe")(334203 call . b c"parSafe")))
    (334212 'end of statement')
    if(334246 call _cond_test(334222 call <=(334215 call . a c"size")(334219 call . b c"size")))
    {
      (334226 call = result b)
      (334232 call ^= result a)
    }
    {
      (334237 call = result a)
      (334243 call ^= result b)
    }
    (334251 return result)
  }
  { scopeless type
    (334194 call set t)
  }
  function ^=[334267](ref arg lhs[334264] :
  (334263 call set unknown t[334259] ?[260]), const  ref arg rhs[334274] :
  (334273 call set t ?[260])) : _unknown[51] "assignop" "no return value for void"
  {
    if(334390 call _cond_test(334285 call &&(334278 call . lhs c"parSafe")(334282 call . rhs c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[334320] "index var" "insert auto destroy"
        iterated expressions:
          rhs
        shadow variables:
        other variables
          forall body
        {
          if(334314 call _cond_test(334295 call(334290 call . lhs c"contains") x))
          {
            (334302 call(334297 call . lhs c"remove") x)
          }
          {
            (334311 call(334306 call . lhs c"add") x)
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[334356] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[334357] "expr temp" "temp"
        (334366 'move' _iterator[334357](334364 call _getIterator rhs))
        Defer
        {
          {
            (334382 call _freeIterator _iterator[334357])
          }
        }
        { scopeless type
          (334371 'move' _indexOfInterest[334356](334368 call iteratorIndex _iterator[334357]))
        }
        ForLoop[334358]
        {
          unknown x[334375] "index var" "insert auto destroy"
          (334377 'move' x[334375] _indexOfInterest[334356])
          {
            if(334351 call _cond_test(334332 call(334327 call . lhs c"contains") x))
            {
              (334339 call(334334 call . lhs c"remove") x)
            }
            {
              (334348 call(334343 call . lhs c"add") x)
            }
          }
          label _continueLabel[334361]
          _indexOfInterest[334356]
          _iterator[334357]
        }
        label _breakLabel[334362]
      }
    }
  }
  function ==[334408](const  ref arg a[334405] :
  (334404 call set unknown t[334400] ?[260]), const  ref arg b[334415] :
  (334414 call set t ?[260])) : _unknown[51]
  {
    if(334432 call _cond_test(334427 call !=(334420 call . a c"size")(334424 call . b c"size")))
    {
      (334430 return 0)
    }
    unknown result[334439] 1
    (334442 'end of statement')
    if(334532 call _cond_test(334451 call &&(334444 call . a c"parSafe")(334448 call . b c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[334475] "index var" "insert auto destroy"
        iterated expressions:
          a
        shadow variables:
        other variables
          forall body
        {
          if(334469 call _cond_test(334462 call !(334461 call(334456 call . b c"contains") x)))
          {
            (334466 call = result 0)
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[334498] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[334499] "expr temp" "temp"
        (334508 'move' _iterator[334499](334506 call _getIterator a))
        Defer
        {
          {
            (334524 call _freeIterator _iterator[334499])
          }
        }
        { scopeless type
          (334513 'move' _indexOfInterest[334498](334510 call iteratorIndex _iterator[334499]))
        }
        ForLoop[334500]
        {
          unknown x[334517] "index var" "insert auto destroy"
          (334519 'move' x[334517] _indexOfInterest[334498])
          if(334493 call _cond_test(334488 call !(334487 call(334482 call . b c"contains") x)))
          {
            (334491 return 0)
          }
          label _continueLabel[334503]
          _indexOfInterest[334498]
          _iterator[334499]
        }
        label _breakLabel[334504]
      }
    }
    (334537 return result)
  }
  { scopeless type
    bool[10]
  }
  function !=[334553](const  ref arg a[334550] :
  (334549 call set unknown t[334545] ?[260]), const  ref arg b[334560] :
  (334559 call set t ?[260])) : _unknown[51]
  {
    (334570 return(334568 call !(334566 call == a b)))
  }
  { scopeless type
    bool[10]
  }
  function <[334587](const  ref arg a[334584] :
  (334583 call set unknown t[334579] ?[260]), const  ref arg b[334594] :
  (334593 call set t ?[260])) : _unknown[51]
  {
    if(334611 call _cond_test(334606 call >=(334599 call . a c"size")(334603 call . b c"size")))
    {
      (334609 return 0)
    }
    (334621 return(334619 call <= a b))
  }
  { scopeless type
    bool[10]
  }
  function <=[334637](const  ref arg a[334634] :
  (334633 call set unknown t[334629] ?[260]), const  ref arg b[334644] :
  (334643 call set t ?[260])) : _unknown[51]
  {
    if(334661 call _cond_test(334656 call >(334649 call . a c"size")(334653 call . b c"size")))
    {
      (334659 return 0)
    }
    unknown result[334668] 1
    (334671 'end of statement')
    if(334761 call _cond_test(334680 call &&(334673 call . a c"parSafe")(334677 call . b c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[334704] "index var" "insert auto destroy"
        iterated expressions:
          a
        shadow variables:
        other variables
          forall body
        {
          if(334698 call _cond_test(334691 call !(334690 call(334685 call . b c"contains") x)))
          {
            (334695 call = result 0)
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[334727] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[334728] "expr temp" "temp"
        (334737 'move' _iterator[334728](334735 call _getIterator a))
        Defer
        {
          {
            (334753 call _freeIterator _iterator[334728])
          }
        }
        { scopeless type
          (334742 'move' _indexOfInterest[334727](334739 call iteratorIndex _iterator[334728]))
        }
        ForLoop[334729]
        {
          unknown x[334746] "index var" "insert auto destroy"
          (334748 'move' x[334746] _indexOfInterest[334727])
          if(334722 call _cond_test(334717 call !(334716 call(334711 call . b c"contains") x)))
          {
            (334720 return 0)
          }
          label _continueLabel[334732]
          _indexOfInterest[334727]
          _iterator[334728]
        }
        label _breakLabel[334733]
      }
    }
    (334766 return result)
  }
  { scopeless type
    bool[10]
  }
  function >[334782](const  ref arg a[334779] :
  (334778 call set unknown t[334774] ?[260]), const  ref arg b[334789] :
  (334788 call set t ?[260])) : _unknown[51]
  {
    if(334806 call _cond_test(334801 call <=(334794 call . a c"size")(334798 call . b c"size")))
    {
      (334804 return 0)
    }
    (334816 return(334814 call >= a b))
  }
  { scopeless type
    bool[10]
  }
  function >=[334832](const  ref arg a[334829] :
  (334828 call set unknown t[334824] ?[260]), const  ref arg b[334839] :
  (334838 call set t ?[260])) : _unknown[51]
  {
    if(334856 call _cond_test(334851 call <(334844 call . a c"size")(334848 call . b c"size")))
    {
      (334854 return 0)
    }
    unknown result[334863] 1
    (334866 'end of statement')
    if(334956 call _cond_test(334875 call &&(334868 call . a c"parSafe")(334872 call . b c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[334899] "index var" "insert auto destroy"
        iterated expressions:
          b
        shadow variables:
        other variables
          forall body
        {
          if(334893 call _cond_test(334886 call !(334885 call(334880 call . a c"contains") x)))
          {
            (334890 call = result 0)
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[334922] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[334923] "expr temp" "temp"
        (334932 'move' _iterator[334923](334930 call _getIterator b))
        Defer
        {
          {
            (334948 call _freeIterator _iterator[334923])
          }
        }
        { scopeless type
          (334937 'move' _indexOfInterest[334922](334934 call iteratorIndex _iterator[334923]))
        }
        ForLoop[334924]
        {
          unknown x[334941] "index var" "insert auto destroy"
          (334943 'move' x[334941] _indexOfInterest[334922])
          if(334917 call _cond_test(334912 call !(334911 call(334906 call . a c"contains") x)))
          {
            (334915 return 0)
          }
          label _continueLabel[334927]
          _indexOfInterest[334922]
          _iterator[334923]
        }
        label _breakLabel[334928]
      }
    }
    (334961 return result)
  }
  { scopeless type
    bool[10]
  }
}