AST dump for Set after pass cleanup.
Module use list: 

{
  (353116 'use' ChapelStandard)
  (331342 'import' ChapelLocks)
  (331346 'use' IO)
  (331349 'use' Reflection)
  (331352 'use' ChapelHashtable)
  unknown _sanityChecks[331355] "no doc" "param" "private" 1
  (331358 'end of statement')
  function _sanity[331365](arg expr[331362] :
  bool[10]) : _unknown[51] "inline" "private" "no return value for void"
  {
    if(331373 call _cond_test _sanityChecks)
    {
      (331371 call assert expr)
    }
  }
  unknown _lockType[331385] "no doc" "type variable"(331382 call . ChapelLocks c"chpl_LocalSpinlock")
  function _LockWrapper[331426].lock[331399](arg _mt[331430]:_MT[238], arg this[331428]:_LockWrapper[331426]) : _unknown[51] "inline" "method" "primary method" "no return value for void"
  {
    (331406 call(331402 call . lock$ c"lock"))
  }
  function _LockWrapper[331426].unlock[331413](arg _mt[331434]:_MT[238], arg this[331432]:_LockWrapper[331426]) : _unknown[51] "inline" "method" "primary method" "no return value for void"
  {
    (331420 call(331416 call . lock$ c"unlock"))
  }
  type _LockWrapper[331426] unknown lock$[331393](331389 'new'(331392 call _lockType))
  function _checkElementType[331441](arg t[331439]:_any[178](?)) : _unknown[51] "no doc" "no return value for void"
  {
    if(331498 call _cond_test(331446 call isGenericType t))
    {
      (331473 call compilerWarning(331469 call + "creating a set with element type "(331467 call _cast string[26] t)) 2)
      (331496 call compilerError "set element type cannot currently be generic" 2)
    }
  }
  function set[333199](?).init[331540](arg _mt[333203]:_MT[238], arg this[333201]:set[333199](?), arg eltType[331538]:_any[178](?), param arg parSafe[331543] =
  0) : _unknown[51] "method" "primary method" "no return value for void"
  {
    (331549 call _checkElementType eltType)
    (331557 call =(331553 call . this c"eltType") eltType)
    (331565 call =(331561 call . this c"parSafe") parSafe)
  }
  function set[333199](?)._addElem[331576](arg _mt[333207]:_MT[238], arg this[333205]:set[333199](?), in arg elem[331573] :
  eltType) : _unknown[51] "method" "primary method" "no doc"
  {
    unknown tmp[331591] "temp"(331590 call(331585 call . _htb c"findAvailableSlot") elem)
    (331598 call _check_tuple_var_decl tmp[331591] 2)
    unknown isFullSlot[331579](331592 call tmp[331591] 0)
    unknown idx[331581](331595 call tmp[331591] 1)
    (331603 'end of statement')
    if(331609 call _cond_test isFullSlot)
    {
      (331607 return 0)
    }
    (331622 call(331615 call . _htb c"fillSlot") idx elem none[57])
    (331625 return 1)
  }
  { scopeless type
    bool[10]
  }
  function set[333199](?).init[331634](arg _mt[333211]:_MT[238], arg this[333209]:set[333199](?), arg eltType[331632]:_any[178](?), arg iterable[331636]:_any[178](?), param arg parSafe[331639] =
  0) : _unknown[51] "method" "primary method" "no return value for void"
  {
    (331656 call _checkElementType eltType)
    (331664 call =(331660 call . this c"eltType") eltType)
    (331672 call =(331668 call . this c"parSafe") parSafe)
    (331680 call(331676 call . this c"complete"))
    {
      unknown _indexOfInterest[331689] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[331690] "expr temp" "temp"
      (331699 'move' _iterator[331690](331697 call _getIterator iterable))
      Defer
      {
        {
          (331715 call _freeIterator _iterator[331690])
        }
      }
      { scopeless type
        (331704 'move' _indexOfInterest[331689](331701 call iteratorIndex _iterator[331690]))
      }
      ForLoop[331691]
      {
        unknown elem[331708] "index var" "insert auto destroy"
        (331710 'move' elem[331708] _indexOfInterest[331689])
        (331687 call _addElem elem)
        label _continueLabel[331694]
        _indexOfInterest[331689]
        _iterator[331690]
      }
      label _breakLabel[331695]
    }
  }
  where {
    (331646 call canResolveMethod iterable "these")
  }
  {
    (331651 call <(331648 'lifetime_of' this)(331650 'lifetime_of' iterable))
  }
  function set[333199](?).init=[331737](arg _mt[333215]:_MT[238], arg this[333213]:set[333199](?), const  ref arg other[331734] :
  (331733 call set unknown t[331729] ?[260])) : _unknown[51] "method" "primary method" "no return value for void"
  {
    (331750 call =(331746 call . this c"eltType") t)
    (331762 call =(331755 call . this c"parSafe")(331759 call . other c"parSafe"))
    (331770 call(331766 call . this c"complete"))
    if(331860 call _cond_test(331776 call !(331775 call isCopyableType eltType)))
    {
      (331858 call compilerError(331855 call +(331836 call +(331830 call +(331811 call +(331804 call +(331801 call + "Cannot initialize "(331799 call _cast string[26](331797 'typeof' this))) " from ")(331809 call _cast string[26](331807 'typeof' other))) " because element type ")(331834 call _cast string[26] eltType)) " is not copyable"))
    }
    {
      unknown _indexOfInterest[331872] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[331873] "expr temp" "temp"
      (331882 'move' _iterator[331873](331880 call _getIterator other))
      Defer
      {
        {
          (331898 call _freeIterator _iterator[331873])
        }
      }
      { scopeless type
        (331887 'move' _indexOfInterest[331872](331884 call iteratorIndex _iterator[331873]))
      }
      ForLoop[331874]
      {
        unknown elem[331891] "index var" "insert auto destroy"
        (331893 'move' elem[331891] _indexOfInterest[331872])
        (331870 call _addElem elem)
        label _continueLabel[331877]
        _indexOfInterest[331872]
        _iterator[331873]
      }
      label _breakLabel[331878]
    }
  }
  {
    (331743 call <(331740 'lifetime_of' this)(331742 'lifetime_of' other))
  }
  function set[333199](?)._enter[331910](arg _mt[333219]:_MT[238], arg this[333217]:set[333199](?)) : _unknown[51] "inline" "method" "primary method" "no doc" "no return value for void"
  {
    if(331933 call _cond_test parSafe)
    {
      const tmp[331925] "const" "temp"
      (331927 'move' tmp[331925](331923 'deref'(331922 '_wide_get_locale' this)))
      {
        {
          (331919 call(331915 call . _lock$ c"lock"))
        }
        (331930 'on block' 0 tmp[331925])
      }
    }
  }
  function set[333199](?)._leave[331943](arg _mt[333223]:_MT[238], arg this[333221]:set[333199](?)) : _unknown[51] "inline" "method" "primary method" "no doc" "no return value for void"
  {
    if(331966 call _cond_test parSafe)
    {
      const tmp[331958] "const" "temp"
      (331960 'move' tmp[331958](331956 'deref'(331955 '_wide_get_locale' this)))
      {
        {
          (331952 call(331948 call . _lock$ c"unlock"))
        }
        (331963 'on block' 0 tmp[331958])
      }
    }
  }
  function set[333199](?).add[331980](arg _mt[333227]:_MT[238], ref arg this[333225]:set[333199](?), in arg x[331977] :
  eltType) : _unknown[51] "method" "primary method" "no return value for void"
  {
    (331990 call _enter)
    Defer
    {
      { scopeless
        (331995 call _leave)
      }
    }
    (332002 call _addElem x)
  }
  {
    (331986 call <(331983 'lifetime_of' this)(331985 'lifetime_of' x))
  }
  function set[333199](?).contains[332013](arg _mt[333231]:_MT[238], const arg this[333229]:set[333199](?), const  ref arg x[332010] :
  eltType) : _unknown[51] "method" "primary method"
  {
    unknown result[332017] 0
    (332020 'end of statement')
    const tmp[332064] "const" "temp"
    (332066 'move' tmp[332064](332062 'deref'(332061 '_wide_get_locale' this)))
    {
      {
        (332025 call _enter)
        Defer
        {
          { scopeless
            (332030 call _leave)
          }
        }
        unknown tmp[332046] "temp"(332045 call(332040 call . _htb c"findFullSlot") x)
        (332050 call _check_tuple_var_decl tmp[332046] 2)
        unknown hasFoundSlot[332034](332047 call tmp[332046] 0)
        (332055 'end of statement')
        (332058 call = result hasFoundSlot)
      }
      (332069 'on block' 0 tmp[332064])
    }
    (332073 return result)
  }
  { scopeless type
    bool[10]
  }
  function set[333199](?).isDisjoint[332088](arg _mt[333235]:_MT[238], const arg this[333233]:set[333199](?), const  ref arg other[332085] :
  (332084 call set eltType ?[260])) : _unknown[51] "method" "primary method"
  {
    unknown result[332092] 1
    (332095 'end of statement')
    const tmp[332187] "const" "temp"
    (332189 'move' tmp[332187](332185 'deref'(332184 '_wide_get_locale' this)))
    {
      {
        (332100 call _enter)
        Defer
        {
          { scopeless
            (332105 call _leave)
          }
        }
        if(332180 call _cond_test(332122 call !(332120 call ||(332111 call == size 0)(332118 call ==(332114 call . other c"size") 0))))
        {
          {
            unknown _indexOfInterest[332146] "an _indexOfInterest or chpl__followIdx variable" "temp"
            unknown _iterator[332147] "expr temp" "temp"
            (332156 'move' _iterator[332147](332154 call _getIterator other))
            Defer
            {
              {
                (332172 call _freeIterator _iterator[332147])
              }
            }
            { scopeless type
              (332161 'move' _indexOfInterest[332146](332158 call iteratorIndex _iterator[332147]))
            }
            ForLoop[332148]
            {
              unknown x[332165] "index var" "insert auto destroy"
              (332167 'move' x[332165] _indexOfInterest[332146])
              if(332142 call _cond_test(332132 call(332127 call . this c"contains") x))
              {
                (332135 call = result 0)
                break nil[44]
              }
              label _continueLabel[332151]
              _indexOfInterest[332146]
              _iterator[332147]
            }
            label _breakLabel[332152]
          }
        }
      }
      (332192 'on block' 0 tmp[332187])
    }
    (332196 return result)
  }
  { scopeless type
    bool[10]
  }
  function set[333199](?).isIntersecting[332211](arg _mt[333239]:_MT[238], const arg this[333237]:set[333199](?), const  ref arg other[332208] :
  (332207 call set eltType ?[260])) : _unknown[51] "method" "primary method"
  {
    (332220 return(332218 call !(332217 call isDisjoint other)))
  }
  { scopeless type
    bool[10]
  }
  function set[333199](?).remove[332232](arg _mt[333243]:_MT[238], ref arg this[333241]:set[333199](?), const  ref arg x[332229] :
  eltType) : _unknown[51] "method" "primary method"
  {
    unknown result[332236] 0
    (332239 'end of statement')
    const tmp[332319] "const" "temp"
    (332321 'move' tmp[332319](332317 'deref'(332316 '_wide_get_locale' this)))
    {
      {
        (332244 call _enter)
        Defer
        {
          { scopeless
            (332249 call _leave)
          }
        }
        unknown tmp[332265] "temp"(332264 call(332259 call . _htb c"findFullSlot") x)
        (332272 call _check_tuple_var_decl tmp[332265] 2)
        unknown hasFoundSlot[332253](332266 call tmp[332265] 0)
        unknown idx[332255](332269 call tmp[332265] 1)
        (332277 'end of statement')
        if(332312 call _cond_test hasFoundSlot)
        {
          unknown key[332280] eltType
          (332283 'end of statement')
          unknown val[332286] nothing[7]
          (332289 'end of statement')
          (332298 call(332291 call . _htb c"clearSlot") idx key val)
          (332305 call(332301 call . _htb c"maybeShrinkAfterRemove"))
          (332309 call = result 1)
        }
      }
      (332324 'on block' 0 tmp[332319])
    }
    (332328 return result)
  }
  { scopeless type
    bool[10]
  }
  function set[333199](?).clear[332335](arg _mt[333247]:_MT[238], ref arg this[333245]:set[333199](?)) : _unknown[51] "method" "primary method" "no return value for void"
  {
    const tmp[332445] "const" "temp"
    (332447 'move' tmp[332445](332443 'deref'(332442 '_wide_get_locale' this)))
    {
      {
        (332340 call _enter)
        Defer
        {
          { scopeless
            (332345 call _leave)
          }
        }
        {
          unknown _indexOfInterest[332392] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[332393] "expr temp" "temp"
          (332402 'move' _iterator[332393](332400 call _getIterator(332412 call chpl_direct_counted_range_iter 0(332408 call . _htb c"tableSize"))))
          Defer
          {
            {
              (332428 call _freeIterator _iterator[332393])
            }
          }
          { scopeless type
            (332417 'move' _indexOfInterest[332392](332414 call iteratorIndex _iterator[332393]))
          }
          ForLoop[332394]
          {
            unknown idx[332421] "index var" "insert auto destroy"
            (332423 'move' idx[332421] _indexOfInterest[332392])
            {
              if(332387 call _cond_test(332365 call(332360 call . _htb c"isSlotFull") idx))
              {
                unknown key[332367] eltType
                (332370 'end of statement')
                unknown val[332373] nothing[7]
                (332376 'end of statement')
                (332385 call(332378 call . _htb c"clearSlot") idx key val)
              }
            }
            label _continueLabel[332397]
            _indexOfInterest[332392]
            _iterator[332393]
          }
          label _breakLabel[332398]
        }
        (332440 call(332436 call . _htb c"maybeShrinkAfterRemove"))
      }
      (332450 'on block' 0 tmp[332445])
    }
  }
  function set[333199](?).these[332458](arg _mt[333251]:_MT[238], const arg this[333249]:set[333199](?)) : _unknown[51] "iterator fn" "method" "primary method" "no return value for void"
  {
    {
      unknown _indexOfInterest[332494] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[332495] "expr temp" "temp"
      (332504 'move' _iterator[332495](332502 call _getIterator(332514 call chpl_direct_counted_range_iter 0(332510 call . _htb c"tableSize"))))
      Defer
      {
        {
          (332530 call _freeIterator _iterator[332495])
        }
      }
      { scopeless type
        (332519 'move' _indexOfInterest[332494](332516 call iteratorIndex _iterator[332495]))
      }
      ForLoop[332496]
      {
        unknown idx[332523] "index var" "insert auto destroy"
        (332525 'move' idx[332523] _indexOfInterest[332494])
        if(332489 call _cond_test(332476 call(332471 call . _htb c"isSlotFull") idx))
        {
          (332487 yield(332484 call .(332483 call(332478 call . _htb c"table") idx) c"key"))
        }
        label _continueLabel[332499]
        _indexOfInterest[332494]
        _iterator[332495]
      }
      label _breakLabel[332500]
    }
  }
  function set[333199](?).these[332544](arg _mt[333255]:_MT[238], const arg this[333253]:set[333199](?), param arg tag[332542]:_any[178](?)) : _unknown[51] "iterator fn" "method" "primary method" "no doc" "no return value for void"
  {
    unknown space[332562](332560 call #(332554 call chpl_build_low_bounded_range 0)(332557 call . _htb c"tableSize"))
    (332565 'end of statement')
    {
      unknown _indexOfInterest[332599] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[332600] "expr temp" "temp"
      (332609 'move' _iterator[332600](332607 call _getIterator(332574 call(332569 call . space c"these") tag)))
      Defer
      {
        {
          (332626 call _freeIterator _iterator[332600])
        }
      }
      { scopeless type
        (332615 'move' _indexOfInterest[332599](332612 call iteratorIndex _iterator[332600]))
      }
      ForLoop[332601]
      {
        unknown idx[332619] "index var" "insert auto destroy"
        (332621 'move' idx[332619] _indexOfInterest[332599])
        if(332594 call _cond_test(332581 call(332576 call . _htb c"isSlotFull") idx))
        {
          (332592 yield(332589 call .(332588 call(332583 call . _htb c"table") idx) c"key"))
        }
        label _continueLabel[332604]
        _indexOfInterest[332599]
        _iterator[332600]
      }
      label _breakLabel[332605]
    }
  }
  where {
    (332551 call == tag(332548 call . iterKind c"standalone"))
  }
  function set[333199](?).these[332640](arg _mt[333259]:_MT[238], const arg this[333257]:set[333199](?), param arg tag[332638]:_any[178](?)) : _unknown[51] "iterator fn" "method" "primary method" "no doc" "no return value for void"
  {
    unknown space[332658](332656 call #(332650 call chpl_build_low_bounded_range 0)(332653 call . _htb c"tableSize"))
    (332661 'end of statement')
    {
      unknown _indexOfInterest[332675] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[332676] "expr temp" "temp"
      (332685 'move' _iterator[332676](332683 call _getIterator(332670 call(332665 call . space c"these") tag)))
      Defer
      {
        {
          (332702 call _freeIterator _iterator[332676])
        }
      }
      { scopeless type
        (332691 'move' _indexOfInterest[332675](332688 call iteratorIndex _iterator[332676]))
      }
      ForLoop[332677]
      {
        unknown followThis[332695] "index var" "insert auto destroy"
        (332697 'move' followThis[332695] _indexOfInterest[332675])
        {
          (332672 yield followThis)
        }
        label _continueLabel[332680]
        _indexOfInterest[332675]
        _iterator[332676]
      }
      label _breakLabel[332681]
    }
  }
  where {
    (332647 call == tag(332644 call . iterKind c"leader"))
  }
  function set[333199](?).these[332716](arg _mt[333263]:_MT[238], const arg this[333261]:set[333199](?), param arg tag[332714]:_any[178](?), arg followThis[332718]:_any[178](?)) : _unknown[51] "iterator fn" "method" "primary method" "no doc" "no return value for void"
  {
    {
      unknown _indexOfInterest[332756] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[332757] "expr temp" "temp"
      (332766 'move' _iterator[332757](332764 call _getIterator(332731 call followThis 0)))
      Defer
      {
        {
          (332783 call _freeIterator _iterator[332757])
        }
      }
      { scopeless type
        (332772 'move' _indexOfInterest[332756](332769 call iteratorIndex _iterator[332757]))
      }
      ForLoop[332758]
      {
        unknown idx[332776] "index var" "insert auto destroy"
        (332778 'move' idx[332776] _indexOfInterest[332756])
        if(332751 call _cond_test(332738 call(332733 call . _htb c"isSlotFull") idx))
        {
          (332749 yield(332746 call .(332745 call(332740 call . _htb c"table") idx) c"key"))
        }
        label _continueLabel[332761]
        _indexOfInterest[332756]
        _iterator[332757]
      }
      label _breakLabel[332762]
    }
  }
  where {
    (332725 call == tag(332722 call . iterKind c"follower"))
  }
  function set[333199](?).writeThis[332800](arg _mt[333267]:_MT[238], const arg this[333265]:set[333199](?), arg ch[332797] :
  channel) : _unknown[51] throws "method" "primary method" "no return value for void"
  {
    const tmp[332902] "const" "temp"
    (332904 'move' tmp[332902](332900 'deref'(332899 '_wide_get_locale' this)))
    {
      {
        (332805 call _enter)
        Defer
        {
          { scopeless
            (332810 call _leave)
          }
        }
        unknown count[332815] 1
        (332818 'end of statement')
        (332821 call <~> ch "{")
        {
          unknown _indexOfInterest[332861] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[332862] "expr temp" "temp"
          (332871 'move' _iterator[332862](332869 call _getIterator this))
          Defer
          {
            {
              (332887 call _freeIterator _iterator[332862])
            }
          }
          { scopeless type
            (332876 'move' _indexOfInterest[332861](332873 call iteratorIndex _iterator[332862]))
          }
          ForLoop[332863]
          {
            unknown x[332880] "index var" "insert auto destroy"
            (332882 'move' x[332880] _indexOfInterest[332861])
            {
              if(332856 call _cond_test(332834 call <= count(332832 call -(332828 call . _htb c"tableNumFullSlots") 1)))
              {
                (332838 call += count 1)
                (332847 call <~>(332844 call <~> ch x) ", ")
              }
              {
                (332852 call <~> ch x)
              }
            }
            label _continueLabel[332866]
            _indexOfInterest[332861]
            _iterator[332862]
          }
          label _breakLabel[332867]
        }
        (332896 call <~> ch "}")
      }
      (332907 'on block' 0 tmp[332902])
    }
  }
  function set[333199](?).isEmpty[332915](arg _mt[333271]:_MT[238], const arg this[333269]:set[333199](?)) : _unknown[51] "inline" "method" "primary method"
  {
    unknown result[332919] 0
    (332922 'end of statement')
    const tmp[332950] "const" "temp"
    (332952 'move' tmp[332950](332948 'deref'(332947 '_wide_get_locale' this)))
    {
      {
        (332927 call _enter)
        Defer
        {
          { scopeless
            (332932 call _leave)
          }
        }
        (332944 call = result(332942 call ==(332938 call . _htb c"tableNumFullSlots") 0))
      }
      (332955 'on block' 0 tmp[332950])
    }
    (332959 return result)
  }
  { scopeless type
    bool[10]
  }
  function set[333199](?).size[332966](arg _mt[333275]:_MT[238], const arg this[333273]:set[333199](?)) : _unknown[51] "inline" "method" "primary method" "no parens"
  {
    unknown result[332969] 0
    (332972 'end of statement')
    const tmp[332997] "const" "temp"
    (332999 'move' tmp[332997](332995 'deref'(332994 '_wide_get_locale' this)))
    {
      {
        (332977 call _enter)
        Defer
        {
          { scopeless
            (332982 call _leave)
          }
        }
        (332991 call = result(332988 call . _htb c"tableNumFullSlots"))
      }
      (333002 'on block' 0 tmp[332997])
    }
    (333006 return result)
  }
  function set[333199](?).toArray[333012](arg _mt[333279]:_MT[238], const arg this[333277]:set[333199](?)) : _unknown[51] "method" "primary method"
  {
    (333020 call _enter)
    Defer
    {
      { scopeless
        (333025 call _leave)
      }
    }
    unknown result[333044](333042 call chpl__buildArrayRuntimeType(333040 call chpl__ensureDomainExpr(333036 call #(333030 call chpl_build_low_bounded_range 0)(333033 call . _htb c"tableNumFullSlots"))) eltType)
    (333047 'end of statement')
    if(333084 call _cond_test(333052 call !(333051 call isCopyableType eltType)))
    {
      (333082 call compilerError(333079 call +(333076 call + "Cannot create array because set element type "(333074 call _cast string[26] eltType)) " is not copyable"))
    }
    const tmp[333184] "const" "temp"
    (333186 'move' tmp[333184](333182 'deref'(333181 '_wide_get_locale' this)))
    {
      {
        if(333176 call _cond_test(333095 call !=(333091 call . _htb c"tableNumFullSlots") 0))
        {
          unknown count[333098] 0
          (333101 'end of statement')
          unknown array[333118](333116 call chpl__buildArrayRuntimeType(333114 call chpl__ensureDomainExpr(333110 call #(333104 call chpl_build_low_bounded_range 0)(333107 call . _htb c"tableNumFullSlots"))) eltType)
          (333121 'end of statement')
          {
            unknown _indexOfInterest[333138] "an _indexOfInterest or chpl__followIdx variable" "temp"
            unknown _iterator[333139] "expr temp" "temp"
            (333148 'move' _iterator[333139](333146 call _getIterator this))
            Defer
            {
              {
                (333164 call _freeIterator _iterator[333139])
              }
            }
            { scopeless type
              (333153 'move' _indexOfInterest[333138](333150 call iteratorIndex _iterator[333139]))
            }
            ForLoop[333140]
            {
              unknown x[333157] "index var" "insert auto destroy"
              (333159 'move' x[333157] _indexOfInterest[333138])
              {
                (333129 call =(333127 call array count) x)
                (333135 call += count 1)
              }
              label _continueLabel[333143]
              _indexOfInterest[333138]
              _iterator[333139]
            }
            label _breakLabel[333144]
          }
          (333173 call = result array)
        }
      }
      (333189 'on block' 0 tmp[333184])
    }
    (333193 return result)
  }
  { scopeless type
    (333015 call chpl__buildArrayRuntimeType nil[44] eltType)
  }
  type set[333199](?) unknown eltType[331506] "type variable" unknown parSafe[331510] "param" 0 unknown _lock$[331523] "no doc"(331520 IfExpr  parSafe then
  { scopeless
    (331515 'new'(331518 call _LockWrapper))
  } else
  { scopeless
    none[57]
  } ) unknown _htb[331532] "no doc"(331531 call chpl__hashtable eltType nothing[7])
  function =[333293](ref arg lhs[333290] :
  (333289 call set unknown t[333285] ?[260]), const  ref arg rhs[333300] :
  (333299 call set t ?[260])) : _unknown[51] "assignop" "no return value for void"
  {
    (333308 call(333304 call . lhs c"clear"))
    {
      unknown _indexOfInterest[333321] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[333322] "expr temp" "temp"
      (333331 'move' _iterator[333322](333329 call _getIterator rhs))
      Defer
      {
        {
          (333347 call _freeIterator _iterator[333322])
        }
      }
      { scopeless type
        (333336 'move' _indexOfInterest[333321](333333 call iteratorIndex _iterator[333322]))
      }
      ForLoop[333323]
      {
        unknown x[333340] "index var" "insert auto destroy"
        (333342 'move' x[333340] _indexOfInterest[333321])
        (333319 call(333314 call . lhs c"add") x)
        label _continueLabel[333326]
        _indexOfInterest[333321]
        _iterator[333322]
      }
      label _breakLabel[333327]
    }
  }
  function |[333367](const  ref arg a[333364] :
  (333363 call set unknown t[333359] ?[260]), const  ref arg b[333374] :
  (333373 call set t ?[260])) : _unknown[51]
  {
    unknown result[333395](333394 call set t(333392 call ||(333385 call . a c"parSafe")(333389 call . b c"parSafe")))
    (333398 'end of statement')
    (333402 call = result a)
    (333407 call |= result b)
    (333411 return result)
  }
  { scopeless type
    (333380 call set t)
  }
  function |=[333427](ref arg lhs[333424] :
  (333423 call set unknown t[333419] ?[260]), const  ref arg rhs[333434] :
  (333433 call set t ?[260])) : _unknown[51] "assignop" "no return value for void"
  {
    {
      unknown _indexOfInterest[333447] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[333448] "expr temp" "temp"
      (333457 'move' _iterator[333448](333455 call _getIterator rhs))
      Defer
      {
        {
          (333473 call _freeIterator _iterator[333448])
        }
      }
      { scopeless type
        (333462 'move' _indexOfInterest[333447](333459 call iteratorIndex _iterator[333448]))
      }
      ForLoop[333449]
      {
        unknown x[333466] "index var" "insert auto destroy"
        (333468 'move' x[333466] _indexOfInterest[333447])
        (333445 call(333440 call . lhs c"add") x)
        label _continueLabel[333452]
        _indexOfInterest[333447]
        _iterator[333448]
      }
      label _breakLabel[333453]
    }
  }
  function +[333494](const  ref arg a[333491] :
  (333490 call set unknown t[333486] ?[260]), const  ref arg b[333501] :
  (333500 call set t ?[260])) : _unknown[51]
  {
    (333513 return(333511 call | a b))
  }
  { scopeless type
    (333508 call set t ?[260])
  }
  function +=[333530](ref arg lhs[333527] :
  (333526 call set unknown t[333522] ?[260]), const  ref arg rhs[333537] :
  (333536 call set t ?[260])) : _unknown[51] "assignop" "no return value for void"
  {
    (333542 call |= lhs rhs)
  }
  function -[333559](const  ref arg a[333556] :
  (333555 call set unknown t[333551] ?[260]), const  ref arg b[333566] :
  (333565 call set t ?[260])) : _unknown[51]
  {
    unknown result[333588](333573 'new'(333587 call set t(333585 call ||(333578 call . a c"parSafe")(333582 call . b c"parSafe"))))
    (333591 'end of statement')
    if(333691 call _cond_test(333601 call &&(333594 call . a c"parSafe")(333598 call . b c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[333628] "index var" "insert auto destroy"
        iterated expressions:
          a
        shadow variables:
        other variables
          forall body
        {
          if(333622 call _cond_test(333612 call !(333611 call(333606 call . b c"contains") x)))
          {
            (333620 call(333615 call . result c"add") x)
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[333657] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[333658] "expr temp" "temp"
        (333667 'move' _iterator[333658](333665 call _getIterator a))
        Defer
        {
          {
            (333683 call _freeIterator _iterator[333658])
          }
        }
        { scopeless type
          (333672 'move' _indexOfInterest[333657](333669 call iteratorIndex _iterator[333658]))
        }
        ForLoop[333659]
        {
          unknown x[333676] "index var" "insert auto destroy"
          (333678 'move' x[333676] _indexOfInterest[333657])
          if(333652 call _cond_test(333642 call !(333641 call(333636 call . b c"contains") x)))
          {
            (333650 call(333645 call . result c"add") x)
          }
          label _continueLabel[333662]
          _indexOfInterest[333657]
          _iterator[333658]
        }
        label _breakLabel[333663]
      }
    }
    (333696 return result)
  }
  { scopeless type
    (333572 call set t)
  }
  function -=[333712](ref arg lhs[333709] :
  (333708 call set unknown t[333704] ?[260]), const  ref arg rhs[333719] :
  (333718 call set t ?[260])) : _unknown[51] "assignop" "no return value for void"
  {
    if(333792 call _cond_test(333730 call &&(333723 call . lhs c"parSafe")(333727 call . rhs c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[333743] "index var" "insert auto destroy"
        iterated expressions:
          rhs
        shadow variables:
        other variables
          forall body
        {
          (333740 call(333735 call . lhs c"remove") x)
        }
      }
    }
    {
      {
        unknown _indexOfInterest[333758] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[333759] "expr temp" "temp"
        (333768 'move' _iterator[333759](333766 call _getIterator rhs))
        Defer
        {
          {
            (333784 call _freeIterator _iterator[333759])
          }
        }
        { scopeless type
          (333773 'move' _indexOfInterest[333758](333770 call iteratorIndex _iterator[333759]))
        }
        ForLoop[333760]
        {
          unknown x[333777] "index var" "insert auto destroy"
          (333779 'move' x[333777] _indexOfInterest[333758])
          (333756 call(333751 call . lhs c"remove") x)
          label _continueLabel[333763]
          _indexOfInterest[333758]
          _iterator[333759]
        }
        label _breakLabel[333764]
      }
    }
  }
  function &[333810](const  ref arg a[333807] :
  (333806 call set unknown t[333802] ?[260]), const  ref arg b[333817] :
  (333816 call set t ?[260])) : _unknown[51]
  {
    unknown result[333838](333837 call set t(333835 call ||(333828 call . a c"parSafe")(333832 call . b c"parSafe")))
    (333841 'end of statement')
    if(334051 call _cond_test(333851 call <=(333844 call . a c"size")(333848 call . b c"size")))
    {
      if(333947 call _cond_test(333861 call &&(333854 call . a c"parSafe")(333858 call . b c"parSafe")))
      {
        Forall {
          induction variables:
            
            unknown x[333886] "index var" "insert auto destroy"
          iterated expressions:
            a
          shadow variables:
          other variables
            forall body
          {
            if(333880 call _cond_test(333871 call(333866 call . b c"contains") x))
            {
              (333878 call(333873 call . result c"add") x)
            }
          }
        }
      }
      {
        {
          unknown _indexOfInterest[333913] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[333914] "expr temp" "temp"
          (333923 'move' _iterator[333914](333921 call _getIterator a))
          Defer
          {
            {
              (333939 call _freeIterator _iterator[333914])
            }
          }
          { scopeless type
            (333928 'move' _indexOfInterest[333913](333925 call iteratorIndex _iterator[333914]))
          }
          ForLoop[333915]
          {
            unknown x[333932] "index var" "insert auto destroy"
            (333934 'move' x[333932] _indexOfInterest[333913])
            if(333908 call _cond_test(333899 call(333894 call . b c"contains") x))
            {
              (333906 call(333901 call . result c"add") x)
            }
            label _continueLabel[333918]
            _indexOfInterest[333913]
            _iterator[333914]
          }
          label _breakLabel[333919]
        }
      }
    }
    {
      if(334046 call _cond_test(333960 call &&(333953 call . a c"parSafe")(333957 call . b c"parSafe")))
      {
        Forall {
          induction variables:
            
            unknown x[333985] "index var" "insert auto destroy"
          iterated expressions:
            b
          shadow variables:
          other variables
            forall body
          {
            if(333979 call _cond_test(333970 call(333965 call . a c"contains") x))
            {
              (333977 call(333972 call . result c"add") x)
            }
          }
        }
      }
      {
        {
          unknown _indexOfInterest[334012] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[334013] "expr temp" "temp"
          (334022 'move' _iterator[334013](334020 call _getIterator b))
          Defer
          {
            {
              (334038 call _freeIterator _iterator[334013])
            }
          }
          { scopeless type
            (334027 'move' _indexOfInterest[334012](334024 call iteratorIndex _iterator[334013]))
          }
          ForLoop[334014]
          {
            unknown x[334031] "index var" "insert auto destroy"
            (334033 'move' x[334031] _indexOfInterest[334012])
            if(334007 call _cond_test(333998 call(333993 call . a c"contains") x))
            {
              (334005 call(334000 call . result c"add") x)
            }
            label _continueLabel[334017]
            _indexOfInterest[334012]
            _iterator[334013]
          }
          label _breakLabel[334018]
        }
      }
    }
    (334056 return result)
  }
  { scopeless type
    (333823 call set t)
  }
  function &=[334072](ref arg lhs[334069] :
  (334068 call set unknown t[334064] ?[260]), const  ref arg rhs[334079] :
  (334078 call set t ?[260])) : _unknown[51] "assignop" "no return value for void"
  {
    unknown result[334096](334095 call set t(334093 call ||(334086 call . lhs c"parSafe")(334090 call . rhs c"parSafe")))
    (334099 'end of statement')
    if(334195 call _cond_test(334109 call &&(334102 call . lhs c"parSafe")(334106 call . rhs c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[334134] "index var" "insert auto destroy"
        iterated expressions:
          lhs
        shadow variables:
        other variables
          forall body
        {
          if(334128 call _cond_test(334119 call(334114 call . rhs c"contains") x))
          {
            (334126 call(334121 call . result c"add") x)
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[334161] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[334162] "expr temp" "temp"
        (334171 'move' _iterator[334162](334169 call _getIterator lhs))
        Defer
        {
          {
            (334187 call _freeIterator _iterator[334162])
          }
        }
        { scopeless type
          (334176 'move' _indexOfInterest[334161](334173 call iteratorIndex _iterator[334162]))
        }
        ForLoop[334163]
        {
          unknown x[334180] "index var" "insert auto destroy"
          (334182 'move' x[334180] _indexOfInterest[334161])
          if(334156 call _cond_test(334147 call(334142 call . rhs c"contains") x))
          {
            (334154 call(334149 call . result c"add") x)
          }
          label _continueLabel[334166]
          _indexOfInterest[334161]
          _iterator[334162]
        }
        label _breakLabel[334167]
      }
    }
    (334201 call = lhs result)
  }
  function ^[334217](const  ref arg a[334214] :
  (334213 call set unknown t[334209] ?[260]), const  ref arg b[334224] :
  (334223 call set t ?[260])) : _unknown[51]
  {
    unknown result[334245](334244 call set t(334242 call ||(334235 call . a c"parSafe")(334239 call . b c"parSafe")))
    (334248 'end of statement')
    if(334282 call _cond_test(334258 call <=(334251 call . a c"size")(334255 call . b c"size")))
    {
      (334262 call = result b)
      (334268 call ^= result a)
    }
    {
      (334273 call = result a)
      (334279 call ^= result b)
    }
    (334287 return result)
  }
  { scopeless type
    (334230 call set t)
  }
  function ^=[334303](ref arg lhs[334300] :
  (334299 call set unknown t[334295] ?[260]), const  ref arg rhs[334310] :
  (334309 call set t ?[260])) : _unknown[51] "assignop" "no return value for void"
  {
    if(334427 call _cond_test(334321 call &&(334314 call . lhs c"parSafe")(334318 call . rhs c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[334356] "index var" "insert auto destroy"
        iterated expressions:
          rhs
        shadow variables:
        other variables
          forall body
        {
          if(334350 call _cond_test(334331 call(334326 call . lhs c"contains") x))
          {
            (334338 call(334333 call . lhs c"remove") x)
          }
          {
            (334347 call(334342 call . lhs c"add") x)
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[334393] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[334394] "expr temp" "temp"
        (334403 'move' _iterator[334394](334401 call _getIterator rhs))
        Defer
        {
          {
            (334419 call _freeIterator _iterator[334394])
          }
        }
        { scopeless type
          (334408 'move' _indexOfInterest[334393](334405 call iteratorIndex _iterator[334394]))
        }
        ForLoop[334395]
        {
          unknown x[334412] "index var" "insert auto destroy"
          (334414 'move' x[334412] _indexOfInterest[334393])
          {
            if(334388 call _cond_test(334369 call(334364 call . lhs c"contains") x))
            {
              (334376 call(334371 call . lhs c"remove") x)
            }
            {
              (334385 call(334380 call . lhs c"add") x)
            }
          }
          label _continueLabel[334398]
          _indexOfInterest[334393]
          _iterator[334394]
        }
        label _breakLabel[334399]
      }
    }
  }
  function ==[334445](const  ref arg a[334442] :
  (334441 call set unknown t[334437] ?[260]), const  ref arg b[334452] :
  (334451 call set t ?[260])) : _unknown[51]
  {
    if(334469 call _cond_test(334464 call !=(334457 call . a c"size")(334461 call . b c"size")))
    {
      (334467 return 0)
    }
    unknown result[334476] 1
    (334479 'end of statement')
    if(334570 call _cond_test(334488 call &&(334481 call . a c"parSafe")(334485 call . b c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[334512] "index var" "insert auto destroy"
        iterated expressions:
          a
        shadow variables:
        other variables
          forall body
        {
          if(334506 call _cond_test(334499 call !(334498 call(334493 call . b c"contains") x)))
          {
            (334503 call = result 0)
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[334536] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[334537] "expr temp" "temp"
        (334546 'move' _iterator[334537](334544 call _getIterator a))
        Defer
        {
          {
            (334562 call _freeIterator _iterator[334537])
          }
        }
        { scopeless type
          (334551 'move' _indexOfInterest[334536](334548 call iteratorIndex _iterator[334537]))
        }
        ForLoop[334538]
        {
          unknown x[334555] "index var" "insert auto destroy"
          (334557 'move' x[334555] _indexOfInterest[334536])
          if(334531 call _cond_test(334526 call !(334525 call(334520 call . b c"contains") x)))
          {
            (334529 return 0)
          }
          label _continueLabel[334541]
          _indexOfInterest[334536]
          _iterator[334537]
        }
        label _breakLabel[334542]
      }
    }
    (334575 return result)
  }
  { scopeless type
    bool[10]
  }
  function !=[334591](const  ref arg a[334588] :
  (334587 call set unknown t[334583] ?[260]), const  ref arg b[334598] :
  (334597 call set t ?[260])) : _unknown[51]
  {
    (334608 return(334606 call !(334604 call == a b)))
  }
  { scopeless type
    bool[10]
  }
  function <[334625](const  ref arg a[334622] :
  (334621 call set unknown t[334617] ?[260]), const  ref arg b[334632] :
  (334631 call set t ?[260])) : _unknown[51]
  {
    if(334649 call _cond_test(334644 call >=(334637 call . a c"size")(334641 call . b c"size")))
    {
      (334647 return 0)
    }
    (334659 return(334657 call <= a b))
  }
  { scopeless type
    bool[10]
  }
  function <=[334675](const  ref arg a[334672] :
  (334671 call set unknown t[334667] ?[260]), const  ref arg b[334682] :
  (334681 call set t ?[260])) : _unknown[51]
  {
    if(334699 call _cond_test(334694 call >(334687 call . a c"size")(334691 call . b c"size")))
    {
      (334697 return 0)
    }
    unknown result[334706] 1
    (334709 'end of statement')
    if(334800 call _cond_test(334718 call &&(334711 call . a c"parSafe")(334715 call . b c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[334742] "index var" "insert auto destroy"
        iterated expressions:
          a
        shadow variables:
        other variables
          forall body
        {
          if(334736 call _cond_test(334729 call !(334728 call(334723 call . b c"contains") x)))
          {
            (334733 call = result 0)
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[334766] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[334767] "expr temp" "temp"
        (334776 'move' _iterator[334767](334774 call _getIterator a))
        Defer
        {
          {
            (334792 call _freeIterator _iterator[334767])
          }
        }
        { scopeless type
          (334781 'move' _indexOfInterest[334766](334778 call iteratorIndex _iterator[334767]))
        }
        ForLoop[334768]
        {
          unknown x[334785] "index var" "insert auto destroy"
          (334787 'move' x[334785] _indexOfInterest[334766])
          if(334761 call _cond_test(334756 call !(334755 call(334750 call . b c"contains") x)))
          {
            (334759 return 0)
          }
          label _continueLabel[334771]
          _indexOfInterest[334766]
          _iterator[334767]
        }
        label _breakLabel[334772]
      }
    }
    (334805 return result)
  }
  { scopeless type
    bool[10]
  }
  function >[334821](const  ref arg a[334818] :
  (334817 call set unknown t[334813] ?[260]), const  ref arg b[334828] :
  (334827 call set t ?[260])) : _unknown[51]
  {
    if(334845 call _cond_test(334840 call <=(334833 call . a c"size")(334837 call . b c"size")))
    {
      (334843 return 0)
    }
    (334855 return(334853 call >= a b))
  }
  { scopeless type
    bool[10]
  }
  function >=[334871](const  ref arg a[334868] :
  (334867 call set unknown t[334863] ?[260]), const  ref arg b[334878] :
  (334877 call set t ?[260])) : _unknown[51]
  {
    if(334895 call _cond_test(334890 call <(334883 call . a c"size")(334887 call . b c"size")))
    {
      (334893 return 0)
    }
    unknown result[334902] 1
    (334905 'end of statement')
    if(334996 call _cond_test(334914 call &&(334907 call . a c"parSafe")(334911 call . b c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[334938] "index var" "insert auto destroy"
        iterated expressions:
          b
        shadow variables:
        other variables
          forall body
        {
          if(334932 call _cond_test(334925 call !(334924 call(334919 call . a c"contains") x)))
          {
            (334929 call = result 0)
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[334962] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[334963] "expr temp" "temp"
        (334972 'move' _iterator[334963](334970 call _getIterator b))
        Defer
        {
          {
            (334988 call _freeIterator _iterator[334963])
          }
        }
        { scopeless type
          (334977 'move' _indexOfInterest[334962](334974 call iteratorIndex _iterator[334963]))
        }
        ForLoop[334964]
        {
          unknown x[334981] "index var" "insert auto destroy"
          (334983 'move' x[334981] _indexOfInterest[334962])
          if(334957 call _cond_test(334952 call !(334951 call(334946 call . a c"contains") x)))
          {
            (334955 return 0)
          }
          label _continueLabel[334967]
          _indexOfInterest[334962]
          _iterator[334963]
        }
        label _breakLabel[334968]
      }
    }
    (335001 return result)
  }
  { scopeless type
    bool[10]
  }
}