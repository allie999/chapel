AST dump for Set after pass cleanup.
Module use list: 

{
  (353183 'use' ChapelStandard)
  (331409 'import' ChapelLocks)
  (331413 'use' IO)
  (331416 'use' Reflection)
  (331419 'use' ChapelHashtable)
  unknown _sanityChecks[331422] "no doc" "param" "private" 1
  (331425 'end of statement')
  function _sanity[331432](arg expr[331429] :
  bool[10]) : _unknown[51] "inline" "private" "no return value for void"
  {
    if(331440 call _cond_test _sanityChecks)
    {
      (331438 call assert expr)
    }
  }
  unknown _lockType[331452] "no doc" "type variable"(331449 call . ChapelLocks c"chpl_LocalSpinlock")
  function _LockWrapper[331493].lock[331466](arg _mt[331497]:_MT[238], arg this[331495]:_LockWrapper[331493]) : _unknown[51] "inline" "method" "primary method" "no return value for void"
  {
    (331473 call(331469 call . lock$ c"lock"))
  }
  function _LockWrapper[331493].unlock[331480](arg _mt[331501]:_MT[238], arg this[331499]:_LockWrapper[331493]) : _unknown[51] "inline" "method" "primary method" "no return value for void"
  {
    (331487 call(331483 call . lock$ c"unlock"))
  }
  type _LockWrapper[331493] unknown lock$[331460](331456 'new'(331459 call _lockType))
  function _checkElementType[331508](arg t[331506]:_any[178](?)) : _unknown[51] "no doc" "no return value for void"
  {
    if(331565 call _cond_test(331513 call isGenericType t))
    {
      (331540 call compilerWarning(331536 call + "creating a set with element type "(331534 call _cast string[26] t)) 2)
      (331563 call compilerError "set element type cannot currently be generic" 2)
    }
  }
  function set[333266](?).init[331607](arg _mt[333270]:_MT[238], arg this[333268]:set[333266](?), arg eltType[331605]:_any[178](?), param arg parSafe[331610] =
  0) : _unknown[51] "method" "primary method" "no return value for void"
  {
    (331616 call _checkElementType eltType)
    (331624 call =(331620 call . this c"eltType") eltType)
    (331632 call =(331628 call . this c"parSafe") parSafe)
  }
  function set[333266](?)._addElem[331643](arg _mt[333274]:_MT[238], arg this[333272]:set[333266](?), in arg elem[331640] :
  eltType) : _unknown[51] "method" "primary method" "no doc"
  {
    unknown tmp[331658] "temp"(331657 call(331652 call . _htb c"findAvailableSlot") elem)
    (331665 call _check_tuple_var_decl tmp[331658] 2)
    unknown isFullSlot[331646](331659 call tmp[331658] 0)
    unknown idx[331648](331662 call tmp[331658] 1)
    (331670 'end of statement')
    if(331676 call _cond_test isFullSlot)
    {
      (331674 return 0)
    }
    (331689 call(331682 call . _htb c"fillSlot") idx elem none[57])
    (331692 return 1)
  }
  { scopeless type
    bool[10]
  }
  function set[333266](?).init[331701](arg _mt[333278]:_MT[238], arg this[333276]:set[333266](?), arg eltType[331699]:_any[178](?), arg iterable[331703]:_any[178](?), param arg parSafe[331706] =
  0) : _unknown[51] "method" "primary method" "no return value for void"
  {
    (331723 call _checkElementType eltType)
    (331731 call =(331727 call . this c"eltType") eltType)
    (331739 call =(331735 call . this c"parSafe") parSafe)
    (331747 call(331743 call . this c"complete"))
    {
      unknown _indexOfInterest[331756] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[331757] "expr temp" "temp"
      (331766 'move' _iterator[331757](331764 call _getIterator iterable))
      Defer
      {
        {
          (331782 call _freeIterator _iterator[331757])
        }
      }
      { scopeless type
        (331771 'move' _indexOfInterest[331756](331768 call iteratorIndex _iterator[331757]))
      }
      ForLoop[331758]
      {
        unknown elem[331775] "index var" "insert auto destroy"
        (331777 'move' elem[331775] _indexOfInterest[331756])
        (331754 call _addElem elem)
        label _continueLabel[331761]
        _indexOfInterest[331756]
        _iterator[331757]
      }
      label _breakLabel[331762]
    }
  }
  where {
    (331713 call canResolveMethod iterable "these")
  }
  {
    (331718 call <(331715 'lifetime_of' this)(331717 'lifetime_of' iterable))
  }
  function set[333266](?).init=[331804](arg _mt[333282]:_MT[238], arg this[333280]:set[333266](?), const  ref arg other[331801] :
  (331800 call set unknown t[331796] ?[260])) : _unknown[51] "method" "primary method" "no return value for void"
  {
    (331817 call =(331813 call . this c"eltType") t)
    (331829 call =(331822 call . this c"parSafe")(331826 call . other c"parSafe"))
    (331837 call(331833 call . this c"complete"))
    if(331927 call _cond_test(331843 call !(331842 call isCopyableType eltType)))
    {
      (331925 call compilerError(331922 call +(331903 call +(331897 call +(331878 call +(331871 call +(331868 call + "Cannot initialize "(331866 call _cast string[26](331864 'typeof' this))) " from ")(331876 call _cast string[26](331874 'typeof' other))) " because element type ")(331901 call _cast string[26] eltType)) " is not copyable"))
    }
    {
      unknown _indexOfInterest[331939] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[331940] "expr temp" "temp"
      (331949 'move' _iterator[331940](331947 call _getIterator other))
      Defer
      {
        {
          (331965 call _freeIterator _iterator[331940])
        }
      }
      { scopeless type
        (331954 'move' _indexOfInterest[331939](331951 call iteratorIndex _iterator[331940]))
      }
      ForLoop[331941]
      {
        unknown elem[331958] "index var" "insert auto destroy"
        (331960 'move' elem[331958] _indexOfInterest[331939])
        (331937 call _addElem elem)
        label _continueLabel[331944]
        _indexOfInterest[331939]
        _iterator[331940]
      }
      label _breakLabel[331945]
    }
  }
  {
    (331810 call <(331807 'lifetime_of' this)(331809 'lifetime_of' other))
  }
  function set[333266](?)._enter[331977](arg _mt[333286]:_MT[238], arg this[333284]:set[333266](?)) : _unknown[51] "inline" "method" "primary method" "no doc" "no return value for void"
  {
    if(332000 call _cond_test parSafe)
    {
      const tmp[331992] "const" "temp"
      (331994 'move' tmp[331992](331990 'deref'(331989 '_wide_get_locale' this)))
      {
        {
          (331986 call(331982 call . _lock$ c"lock"))
        }
        (331997 'on block' 0 tmp[331992])
      }
    }
  }
  function set[333266](?)._leave[332010](arg _mt[333290]:_MT[238], arg this[333288]:set[333266](?)) : _unknown[51] "inline" "method" "primary method" "no doc" "no return value for void"
  {
    if(332033 call _cond_test parSafe)
    {
      const tmp[332025] "const" "temp"
      (332027 'move' tmp[332025](332023 'deref'(332022 '_wide_get_locale' this)))
      {
        {
          (332019 call(332015 call . _lock$ c"unlock"))
        }
        (332030 'on block' 0 tmp[332025])
      }
    }
  }
  function set[333266](?).add[332047](arg _mt[333294]:_MT[238], ref arg this[333292]:set[333266](?), in arg x[332044] :
  eltType) : _unknown[51] "method" "primary method" "no return value for void"
  {
    (332057 call _enter)
    Defer
    {
      { scopeless
        (332062 call _leave)
      }
    }
    (332069 call _addElem x)
  }
  {
    (332053 call <(332050 'lifetime_of' this)(332052 'lifetime_of' x))
  }
  function set[333266](?).contains[332080](arg _mt[333298]:_MT[238], const arg this[333296]:set[333266](?), const  ref arg x[332077] :
  eltType) : _unknown[51] "method" "primary method"
  {
    unknown result[332084] 0
    (332087 'end of statement')
    const tmp[332131] "const" "temp"
    (332133 'move' tmp[332131](332129 'deref'(332128 '_wide_get_locale' this)))
    {
      {
        (332092 call _enter)
        Defer
        {
          { scopeless
            (332097 call _leave)
          }
        }
        unknown tmp[332113] "temp"(332112 call(332107 call . _htb c"findFullSlot") x)
        (332117 call _check_tuple_var_decl tmp[332113] 2)
        unknown hasFoundSlot[332101](332114 call tmp[332113] 0)
        (332122 'end of statement')
        (332125 call = result hasFoundSlot)
      }
      (332136 'on block' 0 tmp[332131])
    }
    (332140 return result)
  }
  { scopeless type
    bool[10]
  }
  function set[333266](?).isDisjoint[332155](arg _mt[333302]:_MT[238], const arg this[333300]:set[333266](?), const  ref arg other[332152] :
  (332151 call set eltType ?[260])) : _unknown[51] "method" "primary method"
  {
    unknown result[332159] 1
    (332162 'end of statement')
    const tmp[332254] "const" "temp"
    (332256 'move' tmp[332254](332252 'deref'(332251 '_wide_get_locale' this)))
    {
      {
        (332167 call _enter)
        Defer
        {
          { scopeless
            (332172 call _leave)
          }
        }
        if(332247 call _cond_test(332189 call !(332187 call ||(332178 call == size 0)(332185 call ==(332181 call . other c"size") 0))))
        {
          {
            unknown _indexOfInterest[332213] "an _indexOfInterest or chpl__followIdx variable" "temp"
            unknown _iterator[332214] "expr temp" "temp"
            (332223 'move' _iterator[332214](332221 call _getIterator other))
            Defer
            {
              {
                (332239 call _freeIterator _iterator[332214])
              }
            }
            { scopeless type
              (332228 'move' _indexOfInterest[332213](332225 call iteratorIndex _iterator[332214]))
            }
            ForLoop[332215]
            {
              unknown x[332232] "index var" "insert auto destroy"
              (332234 'move' x[332232] _indexOfInterest[332213])
              if(332209 call _cond_test(332199 call(332194 call . this c"contains") x))
              {
                (332202 call = result 0)
                break nil[44]
              }
              label _continueLabel[332218]
              _indexOfInterest[332213]
              _iterator[332214]
            }
            label _breakLabel[332219]
          }
        }
      }
      (332259 'on block' 0 tmp[332254])
    }
    (332263 return result)
  }
  { scopeless type
    bool[10]
  }
  function set[333266](?).isIntersecting[332278](arg _mt[333306]:_MT[238], const arg this[333304]:set[333266](?), const  ref arg other[332275] :
  (332274 call set eltType ?[260])) : _unknown[51] "method" "primary method"
  {
    (332287 return(332285 call !(332284 call isDisjoint other)))
  }
  { scopeless type
    bool[10]
  }
  function set[333266](?).remove[332299](arg _mt[333310]:_MT[238], ref arg this[333308]:set[333266](?), const  ref arg x[332296] :
  eltType) : _unknown[51] "method" "primary method"
  {
    unknown result[332303] 0
    (332306 'end of statement')
    const tmp[332386] "const" "temp"
    (332388 'move' tmp[332386](332384 'deref'(332383 '_wide_get_locale' this)))
    {
      {
        (332311 call _enter)
        Defer
        {
          { scopeless
            (332316 call _leave)
          }
        }
        unknown tmp[332332] "temp"(332331 call(332326 call . _htb c"findFullSlot") x)
        (332339 call _check_tuple_var_decl tmp[332332] 2)
        unknown hasFoundSlot[332320](332333 call tmp[332332] 0)
        unknown idx[332322](332336 call tmp[332332] 1)
        (332344 'end of statement')
        if(332379 call _cond_test hasFoundSlot)
        {
          unknown key[332347] eltType
          (332350 'end of statement')
          unknown val[332353] nothing[7]
          (332356 'end of statement')
          (332365 call(332358 call . _htb c"clearSlot") idx key val)
          (332372 call(332368 call . _htb c"maybeShrinkAfterRemove"))
          (332376 call = result 1)
        }
      }
      (332391 'on block' 0 tmp[332386])
    }
    (332395 return result)
  }
  { scopeless type
    bool[10]
  }
  function set[333266](?).clear[332402](arg _mt[333314]:_MT[238], ref arg this[333312]:set[333266](?)) : _unknown[51] "method" "primary method" "no return value for void"
  {
    const tmp[332512] "const" "temp"
    (332514 'move' tmp[332512](332510 'deref'(332509 '_wide_get_locale' this)))
    {
      {
        (332407 call _enter)
        Defer
        {
          { scopeless
            (332412 call _leave)
          }
        }
        {
          unknown _indexOfInterest[332459] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[332460] "expr temp" "temp"
          (332469 'move' _iterator[332460](332467 call _getIterator(332479 call chpl_direct_counted_range_iter 0(332475 call . _htb c"tableSize"))))
          Defer
          {
            {
              (332495 call _freeIterator _iterator[332460])
            }
          }
          { scopeless type
            (332484 'move' _indexOfInterest[332459](332481 call iteratorIndex _iterator[332460]))
          }
          ForLoop[332461]
          {
            unknown idx[332488] "index var" "insert auto destroy"
            (332490 'move' idx[332488] _indexOfInterest[332459])
            {
              if(332454 call _cond_test(332432 call(332427 call . _htb c"isSlotFull") idx))
              {
                unknown key[332434] eltType
                (332437 'end of statement')
                unknown val[332440] nothing[7]
                (332443 'end of statement')
                (332452 call(332445 call . _htb c"clearSlot") idx key val)
              }
            }
            label _continueLabel[332464]
            _indexOfInterest[332459]
            _iterator[332460]
          }
          label _breakLabel[332465]
        }
        (332507 call(332503 call . _htb c"maybeShrinkAfterRemove"))
      }
      (332517 'on block' 0 tmp[332512])
    }
  }
  function set[333266](?).these[332525](arg _mt[333318]:_MT[238], const arg this[333316]:set[333266](?)) : _unknown[51] "iterator fn" "method" "primary method" "no return value for void"
  {
    {
      unknown _indexOfInterest[332561] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[332562] "expr temp" "temp"
      (332571 'move' _iterator[332562](332569 call _getIterator(332581 call chpl_direct_counted_range_iter 0(332577 call . _htb c"tableSize"))))
      Defer
      {
        {
          (332597 call _freeIterator _iterator[332562])
        }
      }
      { scopeless type
        (332586 'move' _indexOfInterest[332561](332583 call iteratorIndex _iterator[332562]))
      }
      ForLoop[332563]
      {
        unknown idx[332590] "index var" "insert auto destroy"
        (332592 'move' idx[332590] _indexOfInterest[332561])
        if(332556 call _cond_test(332543 call(332538 call . _htb c"isSlotFull") idx))
        {
          (332554 yield(332551 call .(332550 call(332545 call . _htb c"table") idx) c"key"))
        }
        label _continueLabel[332566]
        _indexOfInterest[332561]
        _iterator[332562]
      }
      label _breakLabel[332567]
    }
  }
  function set[333266](?).these[332611](arg _mt[333322]:_MT[238], const arg this[333320]:set[333266](?), param arg tag[332609]:_any[178](?)) : _unknown[51] "iterator fn" "method" "primary method" "no doc" "no return value for void"
  {
    unknown space[332629](332627 call #(332621 call chpl_build_low_bounded_range 0)(332624 call . _htb c"tableSize"))
    (332632 'end of statement')
    {
      unknown _indexOfInterest[332666] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[332667] "expr temp" "temp"
      (332676 'move' _iterator[332667](332674 call _getIterator(332641 call(332636 call . space c"these") tag)))
      Defer
      {
        {
          (332693 call _freeIterator _iterator[332667])
        }
      }
      { scopeless type
        (332682 'move' _indexOfInterest[332666](332679 call iteratorIndex _iterator[332667]))
      }
      ForLoop[332668]
      {
        unknown idx[332686] "index var" "insert auto destroy"
        (332688 'move' idx[332686] _indexOfInterest[332666])
        if(332661 call _cond_test(332648 call(332643 call . _htb c"isSlotFull") idx))
        {
          (332659 yield(332656 call .(332655 call(332650 call . _htb c"table") idx) c"key"))
        }
        label _continueLabel[332671]
        _indexOfInterest[332666]
        _iterator[332667]
      }
      label _breakLabel[332672]
    }
  }
  where {
    (332618 call == tag(332615 call . iterKind c"standalone"))
  }
  function set[333266](?).these[332707](arg _mt[333326]:_MT[238], const arg this[333324]:set[333266](?), param arg tag[332705]:_any[178](?)) : _unknown[51] "iterator fn" "method" "primary method" "no doc" "no return value for void"
  {
    unknown space[332725](332723 call #(332717 call chpl_build_low_bounded_range 0)(332720 call . _htb c"tableSize"))
    (332728 'end of statement')
    {
      unknown _indexOfInterest[332742] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[332743] "expr temp" "temp"
      (332752 'move' _iterator[332743](332750 call _getIterator(332737 call(332732 call . space c"these") tag)))
      Defer
      {
        {
          (332769 call _freeIterator _iterator[332743])
        }
      }
      { scopeless type
        (332758 'move' _indexOfInterest[332742](332755 call iteratorIndex _iterator[332743]))
      }
      ForLoop[332744]
      {
        unknown followThis[332762] "index var" "insert auto destroy"
        (332764 'move' followThis[332762] _indexOfInterest[332742])
        {
          (332739 yield followThis)
        }
        label _continueLabel[332747]
        _indexOfInterest[332742]
        _iterator[332743]
      }
      label _breakLabel[332748]
    }
  }
  where {
    (332714 call == tag(332711 call . iterKind c"leader"))
  }
  function set[333266](?).these[332783](arg _mt[333330]:_MT[238], const arg this[333328]:set[333266](?), param arg tag[332781]:_any[178](?), arg followThis[332785]:_any[178](?)) : _unknown[51] "iterator fn" "method" "primary method" "no doc" "no return value for void"
  {
    {
      unknown _indexOfInterest[332823] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[332824] "expr temp" "temp"
      (332833 'move' _iterator[332824](332831 call _getIterator(332798 call followThis 0)))
      Defer
      {
        {
          (332850 call _freeIterator _iterator[332824])
        }
      }
      { scopeless type
        (332839 'move' _indexOfInterest[332823](332836 call iteratorIndex _iterator[332824]))
      }
      ForLoop[332825]
      {
        unknown idx[332843] "index var" "insert auto destroy"
        (332845 'move' idx[332843] _indexOfInterest[332823])
        if(332818 call _cond_test(332805 call(332800 call . _htb c"isSlotFull") idx))
        {
          (332816 yield(332813 call .(332812 call(332807 call . _htb c"table") idx) c"key"))
        }
        label _continueLabel[332828]
        _indexOfInterest[332823]
        _iterator[332824]
      }
      label _breakLabel[332829]
    }
  }
  where {
    (332792 call == tag(332789 call . iterKind c"follower"))
  }
  function set[333266](?).writeThis[332867](arg _mt[333334]:_MT[238], const arg this[333332]:set[333266](?), arg ch[332864] :
  channel) : _unknown[51] throws "method" "primary method" "no return value for void"
  {
    const tmp[332969] "const" "temp"
    (332971 'move' tmp[332969](332967 'deref'(332966 '_wide_get_locale' this)))
    {
      {
        (332872 call _enter)
        Defer
        {
          { scopeless
            (332877 call _leave)
          }
        }
        unknown count[332882] 1
        (332885 'end of statement')
        (332888 call <~> ch "{")
        {
          unknown _indexOfInterest[332928] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[332929] "expr temp" "temp"
          (332938 'move' _iterator[332929](332936 call _getIterator this))
          Defer
          {
            {
              (332954 call _freeIterator _iterator[332929])
            }
          }
          { scopeless type
            (332943 'move' _indexOfInterest[332928](332940 call iteratorIndex _iterator[332929]))
          }
          ForLoop[332930]
          {
            unknown x[332947] "index var" "insert auto destroy"
            (332949 'move' x[332947] _indexOfInterest[332928])
            {
              if(332923 call _cond_test(332901 call <= count(332899 call -(332895 call . _htb c"tableNumFullSlots") 1)))
              {
                (332905 call += count 1)
                (332914 call <~>(332911 call <~> ch x) ", ")
              }
              {
                (332919 call <~> ch x)
              }
            }
            label _continueLabel[332933]
            _indexOfInterest[332928]
            _iterator[332929]
          }
          label _breakLabel[332934]
        }
        (332963 call <~> ch "}")
      }
      (332974 'on block' 0 tmp[332969])
    }
  }
  function set[333266](?).isEmpty[332982](arg _mt[333338]:_MT[238], const arg this[333336]:set[333266](?)) : _unknown[51] "inline" "method" "primary method"
  {
    unknown result[332986] 0
    (332989 'end of statement')
    const tmp[333017] "const" "temp"
    (333019 'move' tmp[333017](333015 'deref'(333014 '_wide_get_locale' this)))
    {
      {
        (332994 call _enter)
        Defer
        {
          { scopeless
            (332999 call _leave)
          }
        }
        (333011 call = result(333009 call ==(333005 call . _htb c"tableNumFullSlots") 0))
      }
      (333022 'on block' 0 tmp[333017])
    }
    (333026 return result)
  }
  { scopeless type
    bool[10]
  }
  function set[333266](?).size[333033](arg _mt[333342]:_MT[238], const arg this[333340]:set[333266](?)) : _unknown[51] "inline" "method" "primary method" "no parens"
  {
    unknown result[333036] 0
    (333039 'end of statement')
    const tmp[333064] "const" "temp"
    (333066 'move' tmp[333064](333062 'deref'(333061 '_wide_get_locale' this)))
    {
      {
        (333044 call _enter)
        Defer
        {
          { scopeless
            (333049 call _leave)
          }
        }
        (333058 call = result(333055 call . _htb c"tableNumFullSlots"))
      }
      (333069 'on block' 0 tmp[333064])
    }
    (333073 return result)
  }
  function set[333266](?).toArray[333079](arg _mt[333346]:_MT[238], const arg this[333344]:set[333266](?)) : _unknown[51] "method" "primary method"
  {
    (333087 call _enter)
    Defer
    {
      { scopeless
        (333092 call _leave)
      }
    }
    unknown result[333111](333109 call chpl__buildArrayRuntimeType(333107 call chpl__ensureDomainExpr(333103 call #(333097 call chpl_build_low_bounded_range 0)(333100 call . _htb c"tableNumFullSlots"))) eltType)
    (333114 'end of statement')
    if(333151 call _cond_test(333119 call !(333118 call isCopyableType eltType)))
    {
      (333149 call compilerError(333146 call +(333143 call + "Cannot create array because set element type "(333141 call _cast string[26] eltType)) " is not copyable"))
    }
    const tmp[333251] "const" "temp"
    (333253 'move' tmp[333251](333249 'deref'(333248 '_wide_get_locale' this)))
    {
      {
        if(333243 call _cond_test(333162 call !=(333158 call . _htb c"tableNumFullSlots") 0))
        {
          unknown count[333165] 0
          (333168 'end of statement')
          unknown array[333185](333183 call chpl__buildArrayRuntimeType(333181 call chpl__ensureDomainExpr(333177 call #(333171 call chpl_build_low_bounded_range 0)(333174 call . _htb c"tableNumFullSlots"))) eltType)
          (333188 'end of statement')
          {
            unknown _indexOfInterest[333205] "an _indexOfInterest or chpl__followIdx variable" "temp"
            unknown _iterator[333206] "expr temp" "temp"
            (333215 'move' _iterator[333206](333213 call _getIterator this))
            Defer
            {
              {
                (333231 call _freeIterator _iterator[333206])
              }
            }
            { scopeless type
              (333220 'move' _indexOfInterest[333205](333217 call iteratorIndex _iterator[333206]))
            }
            ForLoop[333207]
            {
              unknown x[333224] "index var" "insert auto destroy"
              (333226 'move' x[333224] _indexOfInterest[333205])
              {
                (333196 call =(333194 call array count) x)
                (333202 call += count 1)
              }
              label _continueLabel[333210]
              _indexOfInterest[333205]
              _iterator[333206]
            }
            label _breakLabel[333211]
          }
          (333240 call = result array)
        }
      }
      (333256 'on block' 0 tmp[333251])
    }
    (333260 return result)
  }
  { scopeless type
    (333082 call chpl__buildArrayRuntimeType nil[44] eltType)
  }
  type set[333266](?) unknown eltType[331573] "type variable" unknown parSafe[331577] "param" 0 unknown _lock$[331590] "no doc"(331587 IfExpr  parSafe then
  { scopeless
    (331582 'new'(331585 call _LockWrapper))
  } else
  { scopeless
    none[57]
  } ) unknown _htb[331599] "no doc"(331598 call chpl__hashtable eltType nothing[7])
  function =[333360](ref arg lhs[333357] :
  (333356 call set unknown t[333352] ?[260]), const  ref arg rhs[333367] :
  (333366 call set t ?[260])) : _unknown[51] "assignop" "no return value for void"
  {
    (333375 call(333371 call . lhs c"clear"))
    {
      unknown _indexOfInterest[333388] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[333389] "expr temp" "temp"
      (333398 'move' _iterator[333389](333396 call _getIterator rhs))
      Defer
      {
        {
          (333414 call _freeIterator _iterator[333389])
        }
      }
      { scopeless type
        (333403 'move' _indexOfInterest[333388](333400 call iteratorIndex _iterator[333389]))
      }
      ForLoop[333390]
      {
        unknown x[333407] "index var" "insert auto destroy"
        (333409 'move' x[333407] _indexOfInterest[333388])
        (333386 call(333381 call . lhs c"add") x)
        label _continueLabel[333393]
        _indexOfInterest[333388]
        _iterator[333389]
      }
      label _breakLabel[333394]
    }
  }
  function |[333434](const  ref arg a[333431] :
  (333430 call set unknown t[333426] ?[260]), const  ref arg b[333441] :
  (333440 call set t ?[260])) : _unknown[51]
  {
    unknown result[333462](333461 call set t(333459 call ||(333452 call . a c"parSafe")(333456 call . b c"parSafe")))
    (333465 'end of statement')
    (333469 call = result a)
    (333474 call |= result b)
    (333478 return result)
  }
  { scopeless type
    (333447 call set t)
  }
  function |=[333494](ref arg lhs[333491] :
  (333490 call set unknown t[333486] ?[260]), const  ref arg rhs[333501] :
  (333500 call set t ?[260])) : _unknown[51] "assignop" "no return value for void"
  {
    {
      unknown _indexOfInterest[333514] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[333515] "expr temp" "temp"
      (333524 'move' _iterator[333515](333522 call _getIterator rhs))
      Defer
      {
        {
          (333540 call _freeIterator _iterator[333515])
        }
      }
      { scopeless type
        (333529 'move' _indexOfInterest[333514](333526 call iteratorIndex _iterator[333515]))
      }
      ForLoop[333516]
      {
        unknown x[333533] "index var" "insert auto destroy"
        (333535 'move' x[333533] _indexOfInterest[333514])
        (333512 call(333507 call . lhs c"add") x)
        label _continueLabel[333519]
        _indexOfInterest[333514]
        _iterator[333515]
      }
      label _breakLabel[333520]
    }
  }
  function +[333561](const  ref arg a[333558] :
  (333557 call set unknown t[333553] ?[260]), const  ref arg b[333568] :
  (333567 call set t ?[260])) : _unknown[51]
  {
    (333580 return(333578 call | a b))
  }
  { scopeless type
    (333575 call set t ?[260])
  }
  function +=[333597](ref arg lhs[333594] :
  (333593 call set unknown t[333589] ?[260]), const  ref arg rhs[333604] :
  (333603 call set t ?[260])) : _unknown[51] "assignop" "no return value for void"
  {
    (333609 call |= lhs rhs)
  }
  function -[333626](const  ref arg a[333623] :
  (333622 call set unknown t[333618] ?[260]), const  ref arg b[333633] :
  (333632 call set t ?[260])) : _unknown[51]
  {
    unknown result[333655](333640 'new'(333654 call set t(333652 call ||(333645 call . a c"parSafe")(333649 call . b c"parSafe"))))
    (333658 'end of statement')
    if(333758 call _cond_test(333668 call &&(333661 call . a c"parSafe")(333665 call . b c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[333695] "index var" "insert auto destroy"
        iterated expressions:
          a
        shadow variables:
        other variables
          forall body
        {
          if(333689 call _cond_test(333679 call !(333678 call(333673 call . b c"contains") x)))
          {
            (333687 call(333682 call . result c"add") x)
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[333724] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[333725] "expr temp" "temp"
        (333734 'move' _iterator[333725](333732 call _getIterator a))
        Defer
        {
          {
            (333750 call _freeIterator _iterator[333725])
          }
        }
        { scopeless type
          (333739 'move' _indexOfInterest[333724](333736 call iteratorIndex _iterator[333725]))
        }
        ForLoop[333726]
        {
          unknown x[333743] "index var" "insert auto destroy"
          (333745 'move' x[333743] _indexOfInterest[333724])
          if(333719 call _cond_test(333709 call !(333708 call(333703 call . b c"contains") x)))
          {
            (333717 call(333712 call . result c"add") x)
          }
          label _continueLabel[333729]
          _indexOfInterest[333724]
          _iterator[333725]
        }
        label _breakLabel[333730]
      }
    }
    (333763 return result)
  }
  { scopeless type
    (333639 call set t)
  }
  function -=[333779](ref arg lhs[333776] :
  (333775 call set unknown t[333771] ?[260]), const  ref arg rhs[333786] :
  (333785 call set t ?[260])) : _unknown[51] "assignop" "no return value for void"
  {
    if(333859 call _cond_test(333797 call &&(333790 call . lhs c"parSafe")(333794 call . rhs c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[333810] "index var" "insert auto destroy"
        iterated expressions:
          rhs
        shadow variables:
        other variables
          forall body
        {
          (333807 call(333802 call . lhs c"remove") x)
        }
      }
    }
    {
      {
        unknown _indexOfInterest[333825] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[333826] "expr temp" "temp"
        (333835 'move' _iterator[333826](333833 call _getIterator rhs))
        Defer
        {
          {
            (333851 call _freeIterator _iterator[333826])
          }
        }
        { scopeless type
          (333840 'move' _indexOfInterest[333825](333837 call iteratorIndex _iterator[333826]))
        }
        ForLoop[333827]
        {
          unknown x[333844] "index var" "insert auto destroy"
          (333846 'move' x[333844] _indexOfInterest[333825])
          (333823 call(333818 call . lhs c"remove") x)
          label _continueLabel[333830]
          _indexOfInterest[333825]
          _iterator[333826]
        }
        label _breakLabel[333831]
      }
    }
  }
  function &[333877](const  ref arg a[333874] :
  (333873 call set unknown t[333869] ?[260]), const  ref arg b[333884] :
  (333883 call set t ?[260])) : _unknown[51]
  {
    unknown result[333905](333904 call set t(333902 call ||(333895 call . a c"parSafe")(333899 call . b c"parSafe")))
    (333908 'end of statement')
    if(334118 call _cond_test(333918 call <=(333911 call . a c"size")(333915 call . b c"size")))
    {
      if(334014 call _cond_test(333928 call &&(333921 call . a c"parSafe")(333925 call . b c"parSafe")))
      {
        Forall {
          induction variables:
            
            unknown x[333953] "index var" "insert auto destroy"
          iterated expressions:
            a
          shadow variables:
          other variables
            forall body
          {
            if(333947 call _cond_test(333938 call(333933 call . b c"contains") x))
            {
              (333945 call(333940 call . result c"add") x)
            }
          }
        }
      }
      {
        {
          unknown _indexOfInterest[333980] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[333981] "expr temp" "temp"
          (333990 'move' _iterator[333981](333988 call _getIterator a))
          Defer
          {
            {
              (334006 call _freeIterator _iterator[333981])
            }
          }
          { scopeless type
            (333995 'move' _indexOfInterest[333980](333992 call iteratorIndex _iterator[333981]))
          }
          ForLoop[333982]
          {
            unknown x[333999] "index var" "insert auto destroy"
            (334001 'move' x[333999] _indexOfInterest[333980])
            if(333975 call _cond_test(333966 call(333961 call . b c"contains") x))
            {
              (333973 call(333968 call . result c"add") x)
            }
            label _continueLabel[333985]
            _indexOfInterest[333980]
            _iterator[333981]
          }
          label _breakLabel[333986]
        }
      }
    }
    {
      if(334113 call _cond_test(334027 call &&(334020 call . a c"parSafe")(334024 call . b c"parSafe")))
      {
        Forall {
          induction variables:
            
            unknown x[334052] "index var" "insert auto destroy"
          iterated expressions:
            b
          shadow variables:
          other variables
            forall body
          {
            if(334046 call _cond_test(334037 call(334032 call . a c"contains") x))
            {
              (334044 call(334039 call . result c"add") x)
            }
          }
        }
      }
      {
        {
          unknown _indexOfInterest[334079] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[334080] "expr temp" "temp"
          (334089 'move' _iterator[334080](334087 call _getIterator b))
          Defer
          {
            {
              (334105 call _freeIterator _iterator[334080])
            }
          }
          { scopeless type
            (334094 'move' _indexOfInterest[334079](334091 call iteratorIndex _iterator[334080]))
          }
          ForLoop[334081]
          {
            unknown x[334098] "index var" "insert auto destroy"
            (334100 'move' x[334098] _indexOfInterest[334079])
            if(334074 call _cond_test(334065 call(334060 call . a c"contains") x))
            {
              (334072 call(334067 call . result c"add") x)
            }
            label _continueLabel[334084]
            _indexOfInterest[334079]
            _iterator[334080]
          }
          label _breakLabel[334085]
        }
      }
    }
    (334123 return result)
  }
  { scopeless type
    (333890 call set t)
  }
  function &=[334139](ref arg lhs[334136] :
  (334135 call set unknown t[334131] ?[260]), const  ref arg rhs[334146] :
  (334145 call set t ?[260])) : _unknown[51] "assignop" "no return value for void"
  {
    unknown result[334163](334162 call set t(334160 call ||(334153 call . lhs c"parSafe")(334157 call . rhs c"parSafe")))
    (334166 'end of statement')
    if(334262 call _cond_test(334176 call &&(334169 call . lhs c"parSafe")(334173 call . rhs c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[334201] "index var" "insert auto destroy"
        iterated expressions:
          lhs
        shadow variables:
        other variables
          forall body
        {
          if(334195 call _cond_test(334186 call(334181 call . rhs c"contains") x))
          {
            (334193 call(334188 call . result c"add") x)
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[334228] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[334229] "expr temp" "temp"
        (334238 'move' _iterator[334229](334236 call _getIterator lhs))
        Defer
        {
          {
            (334254 call _freeIterator _iterator[334229])
          }
        }
        { scopeless type
          (334243 'move' _indexOfInterest[334228](334240 call iteratorIndex _iterator[334229]))
        }
        ForLoop[334230]
        {
          unknown x[334247] "index var" "insert auto destroy"
          (334249 'move' x[334247] _indexOfInterest[334228])
          if(334223 call _cond_test(334214 call(334209 call . rhs c"contains") x))
          {
            (334221 call(334216 call . result c"add") x)
          }
          label _continueLabel[334233]
          _indexOfInterest[334228]
          _iterator[334229]
        }
        label _breakLabel[334234]
      }
    }
    (334268 call = lhs result)
  }
  function ^[334284](const  ref arg a[334281] :
  (334280 call set unknown t[334276] ?[260]), const  ref arg b[334291] :
  (334290 call set t ?[260])) : _unknown[51]
  {
    unknown result[334312](334311 call set t(334309 call ||(334302 call . a c"parSafe")(334306 call . b c"parSafe")))
    (334315 'end of statement')
    if(334349 call _cond_test(334325 call <=(334318 call . a c"size")(334322 call . b c"size")))
    {
      (334329 call = result b)
      (334335 call ^= result a)
    }
    {
      (334340 call = result a)
      (334346 call ^= result b)
    }
    (334354 return result)
  }
  { scopeless type
    (334297 call set t)
  }
  function ^=[334370](ref arg lhs[334367] :
  (334366 call set unknown t[334362] ?[260]), const  ref arg rhs[334377] :
  (334376 call set t ?[260])) : _unknown[51] "assignop" "no return value for void"
  {
    if(334494 call _cond_test(334388 call &&(334381 call . lhs c"parSafe")(334385 call . rhs c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[334423] "index var" "insert auto destroy"
        iterated expressions:
          rhs
        shadow variables:
        other variables
          forall body
        {
          if(334417 call _cond_test(334398 call(334393 call . lhs c"contains") x))
          {
            (334405 call(334400 call . lhs c"remove") x)
          }
          {
            (334414 call(334409 call . lhs c"add") x)
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[334460] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[334461] "expr temp" "temp"
        (334470 'move' _iterator[334461](334468 call _getIterator rhs))
        Defer
        {
          {
            (334486 call _freeIterator _iterator[334461])
          }
        }
        { scopeless type
          (334475 'move' _indexOfInterest[334460](334472 call iteratorIndex _iterator[334461]))
        }
        ForLoop[334462]
        {
          unknown x[334479] "index var" "insert auto destroy"
          (334481 'move' x[334479] _indexOfInterest[334460])
          {
            if(334455 call _cond_test(334436 call(334431 call . lhs c"contains") x))
            {
              (334443 call(334438 call . lhs c"remove") x)
            }
            {
              (334452 call(334447 call . lhs c"add") x)
            }
          }
          label _continueLabel[334465]
          _indexOfInterest[334460]
          _iterator[334461]
        }
        label _breakLabel[334466]
      }
    }
  }
  function ==[334512](const  ref arg a[334509] :
  (334508 call set unknown t[334504] ?[260]), const  ref arg b[334519] :
  (334518 call set t ?[260])) : _unknown[51]
  {
    if(334536 call _cond_test(334531 call !=(334524 call . a c"size")(334528 call . b c"size")))
    {
      (334534 return 0)
    }
    unknown result[334543] 1
    (334546 'end of statement')
    if(334637 call _cond_test(334555 call &&(334548 call . a c"parSafe")(334552 call . b c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[334579] "index var" "insert auto destroy"
        iterated expressions:
          a
        shadow variables:
        other variables
          forall body
        {
          if(334573 call _cond_test(334566 call !(334565 call(334560 call . b c"contains") x)))
          {
            (334570 call = result 0)
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[334603] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[334604] "expr temp" "temp"
        (334613 'move' _iterator[334604](334611 call _getIterator a))
        Defer
        {
          {
            (334629 call _freeIterator _iterator[334604])
          }
        }
        { scopeless type
          (334618 'move' _indexOfInterest[334603](334615 call iteratorIndex _iterator[334604]))
        }
        ForLoop[334605]
        {
          unknown x[334622] "index var" "insert auto destroy"
          (334624 'move' x[334622] _indexOfInterest[334603])
          if(334598 call _cond_test(334593 call !(334592 call(334587 call . b c"contains") x)))
          {
            (334596 return 0)
          }
          label _continueLabel[334608]
          _indexOfInterest[334603]
          _iterator[334604]
        }
        label _breakLabel[334609]
      }
    }
    (334642 return result)
  }
  { scopeless type
    bool[10]
  }
  function !=[334658](const  ref arg a[334655] :
  (334654 call set unknown t[334650] ?[260]), const  ref arg b[334665] :
  (334664 call set t ?[260])) : _unknown[51]
  {
    (334675 return(334673 call !(334671 call == a b)))
  }
  { scopeless type
    bool[10]
  }
  function <[334692](const  ref arg a[334689] :
  (334688 call set unknown t[334684] ?[260]), const  ref arg b[334699] :
  (334698 call set t ?[260])) : _unknown[51]
  {
    if(334716 call _cond_test(334711 call >=(334704 call . a c"size")(334708 call . b c"size")))
    {
      (334714 return 0)
    }
    (334726 return(334724 call <= a b))
  }
  { scopeless type
    bool[10]
  }
  function <=[334742](const  ref arg a[334739] :
  (334738 call set unknown t[334734] ?[260]), const  ref arg b[334749] :
  (334748 call set t ?[260])) : _unknown[51]
  {
    if(334766 call _cond_test(334761 call >(334754 call . a c"size")(334758 call . b c"size")))
    {
      (334764 return 0)
    }
    unknown result[334773] 1
    (334776 'end of statement')
    if(334867 call _cond_test(334785 call &&(334778 call . a c"parSafe")(334782 call . b c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[334809] "index var" "insert auto destroy"
        iterated expressions:
          a
        shadow variables:
        other variables
          forall body
        {
          if(334803 call _cond_test(334796 call !(334795 call(334790 call . b c"contains") x)))
          {
            (334800 call = result 0)
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[334833] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[334834] "expr temp" "temp"
        (334843 'move' _iterator[334834](334841 call _getIterator a))
        Defer
        {
          {
            (334859 call _freeIterator _iterator[334834])
          }
        }
        { scopeless type
          (334848 'move' _indexOfInterest[334833](334845 call iteratorIndex _iterator[334834]))
        }
        ForLoop[334835]
        {
          unknown x[334852] "index var" "insert auto destroy"
          (334854 'move' x[334852] _indexOfInterest[334833])
          if(334828 call _cond_test(334823 call !(334822 call(334817 call . b c"contains") x)))
          {
            (334826 return 0)
          }
          label _continueLabel[334838]
          _indexOfInterest[334833]
          _iterator[334834]
        }
        label _breakLabel[334839]
      }
    }
    (334872 return result)
  }
  { scopeless type
    bool[10]
  }
  function >[334888](const  ref arg a[334885] :
  (334884 call set unknown t[334880] ?[260]), const  ref arg b[334895] :
  (334894 call set t ?[260])) : _unknown[51]
  {
    if(334912 call _cond_test(334907 call <=(334900 call . a c"size")(334904 call . b c"size")))
    {
      (334910 return 0)
    }
    (334922 return(334920 call >= a b))
  }
  { scopeless type
    bool[10]
  }
  function >=[334938](const  ref arg a[334935] :
  (334934 call set unknown t[334930] ?[260]), const  ref arg b[334945] :
  (334944 call set t ?[260])) : _unknown[51]
  {
    if(334962 call _cond_test(334957 call <(334950 call . a c"size")(334954 call . b c"size")))
    {
      (334960 return 0)
    }
    unknown result[334969] 1
    (334972 'end of statement')
    if(335063 call _cond_test(334981 call &&(334974 call . a c"parSafe")(334978 call . b c"parSafe")))
    {
      Forall {
        induction variables:
          
          unknown x[335005] "index var" "insert auto destroy"
        iterated expressions:
          b
        shadow variables:
        other variables
          forall body
        {
          if(334999 call _cond_test(334992 call !(334991 call(334986 call . a c"contains") x)))
          {
            (334996 call = result 0)
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[335029] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[335030] "expr temp" "temp"
        (335039 'move' _iterator[335030](335037 call _getIterator b))
        Defer
        {
          {
            (335055 call _freeIterator _iterator[335030])
          }
        }
        { scopeless type
          (335044 'move' _indexOfInterest[335029](335041 call iteratorIndex _iterator[335030]))
        }
        ForLoop[335031]
        {
          unknown x[335048] "index var" "insert auto destroy"
          (335050 'move' x[335048] _indexOfInterest[335029])
          if(335024 call _cond_test(335019 call !(335018 call(335013 call . a c"contains") x)))
          {
            (335022 return 0)
          }
          label _continueLabel[335034]
          _indexOfInterest[335029]
          _iterator[335030]
        }
        label _breakLabel[335035]
      }
    }
    (335068 return result)
  }
  { scopeless type
    bool[10]
  }
}