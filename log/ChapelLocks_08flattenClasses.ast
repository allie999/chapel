AST dump for ChapelLocks after pass flattenClasses.
Module use list: Atomics ChapelBase MemConsistency 

{
  function chpl_LocalSpinlock[187432].lock[187323](arg _mt[187436]:_MT[238], arg this[187434]:chpl_LocalSpinlock[187432]) : _unknown[51] "inline" "method" "primary method" "no return value for void"
  {
    const tmp[187402] "const" "temp"
    (187404 'move' tmp[187402](187400 'deref'(187399 '_wide_get_locale' this[187434])))
    {
      {
        unknown tmp[187348] "temp"
        (187396 'move' tmp[187348](187379 call _cond_test(187381 call ||(187386 call(187383 call .(361920 call . this[187434] c"l") c"read"))(187391 call(187388 call .(361925 call . this[187434] c"l") c"testAndSet") acquire[187008]))))
        WhileDo[187353]
        {
          (187346 call chpl_task_yield)
          label _continueLabel[187351]
          (187374 'move' tmp[187348](187357 call _cond_test(187359 call ||(187364 call(187361 call .(361909 call . this[187434] c"l") c"read"))(187369 call(187366 call .(361914 call . this[187434] c"l") c"testAndSet") acquire[187008]))))
          tmp[187348]
        }
        label _breakLabel[187352]
      }
      (187407 'on block' 0 tmp[187402])
    }
  }
  function chpl_LocalSpinlock[187432].unlock[187415](arg _mt[187440]:_MT[238], arg this[187438]:chpl_LocalSpinlock[187432]) : _unknown[51] "inline" "method" "primary method" "no return value for void"
  {
    (187426 call(187418 call .(361931 call . this[187438] c"l") c"clear") release[187006])
  }
  type chpl_LocalSpinlock[187432] unknown l[187317](187316 call chpl__processorAtomicType bool[10])
  (355262 'used modules list'(187305 'use' Atomics[43964])(187307 'use' ChapelBase[307])(187310 'use' MemConsistency[186648]))
}