AST dump for ChapelRange after pass expandExternArrayCalls.
Module use list: 

{
  { scopeless
    (64187 'use' ChapelBase)
    (64189 'use' SysBasic)
    (64190 'use' HaltWrappers)
  }
  { scopeless
    (64194 'use' Math)
    (64196 'use' DSIUtil)
  }
  { scopeless
    unknown debugChapelRange[64198] "config" "no doc" "param" 0
    (64201 'end of statement')
  }
  { scopeless
    unknown useOptimizedRangeIterators[64203] "config" "no doc" "param" 1
    (64206 'end of statement')
  }
  type BoundedRangeType[64216] def bounded[64208]:BoundedRangeType[64216] def boundedLow[64210]:BoundedRangeType[64216] def boundedHigh[64212]:BoundedRangeType[64216] def boundedNone[64214]:BoundedRangeType[64216]
  {
  }
  type range[64319](?) unknown idxType[64223] "type variable" int[13] unknown boundedType[64233] "param"(64230 call . BoundedRangeType c"bounded") BoundedRangeType unknown stridable[64239] "param" 0 bool[10] unknown _low[64247](64246 call chpl__idxTypeToIntIdxType idxType) unknown _high[64255](64254 call chpl__idxTypeToIntIdxType idxType) unknown _stride[64268](64265 IfExpr  stridable then
  { scopeless
    (64263 call chpl__rangeStrideType idxType)
  } else
  { scopeless
    nothing[7]
  } ) unknown _alignment[64281](64278 IfExpr  stridable then
  { scopeless
    (64276 call chpl__idxTypeToIntIdxType idxType)
  } else
  { scopeless
    nothing[7]
  } ) unknown _aligned[64291](64288 IfExpr  stridable then
  { scopeless
    bool[10]
  } else
  { scopeless
    nothing[7]
  } ) function range[64319](?).strType[64297](arg _mt[64323]:_MT[238], arg this[64321]:range[64319](?)) type : _unknown[51] "method" "primary method" "no parens"
  {
    { scopeless
      (64303 return(64302 call chpl__rangeStrideType idxType))
    }
  } function range[64319](?).chpl__promotionType[64310](arg _mt[64327]:_MT[238], arg this[64325]:range[64319](?)) type : _unknown[51] "method" "primary method"
  {
    (64313 return idxType)
  }
  function _unknown[51].intIdxType[64333](arg _mt[64338]:_MT[238], arg this[64335] :
  range) type : _unknown[51] "method" "no parens"
  {
    (64344 return(64343 call chpl__idxTypeToIntIdxType idxType))
  }
  function _unknown[51].init[64356](arg _mt[64421]:_MT[238], arg this[64418] :
  range, arg idxType[64353]:_any[178](?) =
  int[13], param arg boundedType[64363] :
  BoundedRangeType =
  (64360 call . BoundedRangeType c"bounded"), param arg stridable[64369] :
  bool[10] =
  0, arg _low[64379] :
  idxType =
  (64378 call chpl__intToIdx idxType 1), arg _high[64389] :
  idxType =
  (64388 call chpl__intToIdx idxType 0), arg _stride[64398] :
  (64396 call chpl__rangeStrideType idxType) =
  1, arg _alignment[64408] :
  idxType =
  (64407 call chpl__intToIdx idxType 0), arg _aligned[64414] :
  bool[10] =
  0) : _unknown[51] "method" "no doc"
  {
    (64428 call =(64424 call . this c"idxType") idxType)
    (64439 call =(64435 call . this c"boundedType") boundedType)
    (64447 call =(64443 call . this c"stridable") stridable)
    (64460 call =(64453 call . this c"_low")(64459 call chpl__idxToInt _low))
    (64473 call =(64466 call . this c"_high")(64472 call chpl__idxToInt _high))
    (64481 call(64477 call . this c"complete"))
    if(64518 call _cond_test stridable)
    {
      (64491 call =(64487 call . this c"_stride") _stride)
      (64505 call =(64498 call . this c"_alignment")(64504 call chpl__idxToInt _alignment))
      (64515 call =(64511 call . this c"_aligned") _aligned)
    }
    if(64536 call _cond_test(64526 call &&(64523 call ! stridable) boundsChecking))
    {
      { scopeless
        (64534 call assert(64531 call == _stride 1))
      }
    }
  }
  function _isAnyNothing[64549](arg args[64546]:_any[178](?) ...) param : _unknown[51] "private"
  {
    {
      unknown i[64579] 0
      unknown tmp[64580] "maybe param" "temp"
      (64592 'move' tmp[64580](64590 call chpl_compute_low_param_loop_bound 0(64558 call -(64554 call . args c"size") 1)))
      unknown tmp[64581] "maybe param" "temp"
      (64605 'move' tmp[64581](64603 call chpl_compute_high_param_loop_bound 0(64597 call -(64599 call . args c"size") 1)))
      unknown tmp[64582] "maybe param" "temp"
      (64608 'move' tmp[64582] 1)
      ParamForLoop[64610]
      { i[64579] tmp[64580] tmp[64581] tmp[64582]
        {
          if(64573 call _cond_test(64569 call isNothingType(64567 'typeof'(64566 call args i))))
          {
            { scopeless
              (64571 return 1)
            }
          }
        }
      }
      label _unused_continueLabel[64584]
      label _breakLabel[64583]
    }
    (64621 return 0)
  }
  { scopeless type
    bool[10]
  }
  function _unknown[51].init[64633](arg _mt[64679]:_MT[238], arg this[64676] :
  range, arg idxType[64630]:_any[178](?) =
  int[13], param arg boundedType[64640] :
  BoundedRangeType =
  (64637 call . BoundedRangeType c"bounded"), param arg stridable[64646] :
  bool[10] =
  0, arg _low[64656] :
  idxType =
  (64655 call chpl__intToIdx idxType 1), arg _high[64666] :
  idxType =
  (64665 call chpl__intToIdx idxType 0), arg _stride[64670]:_any[178](?), arg _alignment[64672]:_any[178](?), arg _aligned[64674]:_any[178](?)) : _unknown[51] "method" "no doc"
  {
    (64692 call =(64688 call . this c"idxType") idxType)
    (64701 call =(64697 call . this c"boundedType") boundedType)
    (64709 call =(64705 call . this c"stridable") stridable)
    (64720 call =(64713 call . this c"_low")(64719 call chpl__idxToInt _low))
    (64731 call =(64724 call . this c"_high")(64730 call chpl__idxToInt _high))
    (64739 call(64735 call . this c"complete"))
    if(64763 call _cond_test stridable)
    {
      { scopeless
        (64761 call compilerError "non-stridable range initializer called with stridable=true")
      }
    }
  }
  where {
    (64686 call _isAnyNothing _stride _alignment _aligned)
  }
  function _unknown[51].init=[64786](arg _mt[64791]:_MT[238], arg this[64788] :
  range, arg other[64783] :
  (64782 call range unknown i[64775] unknown b[64778] unknown s[64780])) : _unknown[51] "method" "no doc"
  {
    unknown idxType[64810] "type variable"(64807 IfExpr (64799 call ==(64795 call .(64794 'typeof' this) c"idxType") ?[260]) then
    { scopeless
      i
    } else
    { scopeless
      (64804 call .(64803 'typeof' this) c"idxType")
    } )
    { scopeless
      unknown boundedType[64831] "param"(64828 IfExpr (64820 call ==(64816 call .(64815 'typeof' this) c"boundedType") ?[260]) then
      { scopeless
        b
      } else
      { scopeless
        (64825 call .(64824 'typeof' this) c"boundedType")
      } )
      (64834 'end of statement')
    }
    { scopeless
      unknown stridable[64852] "param"(64849 IfExpr (64841 call ==(64837 call .(64836 'typeof' this) c"stridable") ?[260]) then
      { scopeless
        s
      } else
      { scopeless
        (64846 call .(64845 'typeof' this) c"stridable")
      } )
      (64855 'end of statement')
    }
    if(64920 call _cond_test(64858 call != boundedType b))
    {
      (64917 call compilerError(64914 call +(64911 call +(64905 call +(64886 call + "range(boundedType="(64884 call _cast string[26](64880 call .(64879 'typeof' this) c"boundedType"))) ") cannot be initialized from range(boundedType=")(64909 call _cast string[26] b)) ")"))
    }
    if(64951 call _cond_test(64928 call &&(64925 call ! stridable) s))
    {
      { scopeless
        (64949 call compilerError "cannot initialize a non-stridable range from a stridable range")
      }
    }
    { scopeless
      const str[64974] "const"(64971 IfExpr (64958 call && stridable s) then
      { scopeless
        (64961 call . other c"stride")
      } else
      { scopeless
        (64969 call _cast(64968 call chpl__rangeStrideType idxType) 1)
      } )
      (64977 'end of statement')
    }
    (65022 call(64979 call . this c"init") idxType boundedType stridable(64993 call chpl__intToIdx idxType(64990 call . other c"_low"))(65001 call chpl__intToIdx idxType(64998 call . other c"_high")) str(65015 call chpl__intToIdx idxType(65014 call chpl__idxToInt(65010 call . other c"alignment")))(65019 call . other c"aligned"))
  }
  function _unknown[51].displayRepresentation[65051](arg _mt[65056]:_MT[238], arg this[65053] :
  range, arg msg[65047] :
  string[26] =
  "") : _unknown[51] "method" "no doc"
  {
    (65152 call chpl_debug_writeln msg "("(65081 call _cast string[26] idxType) "," boundedType "," stridable " : " low "," high "," stride ","(65148 IfExpr  aligned then
    { scopeless
      (65129 call _cast string[26] alignment)
    } else
    { scopeless
      "\?"
    } ) ")")
  }
  { scopeless type
    void[4]
  }
  function chpl_build_bounded_range[65168](arg low[65165] :
  (65164 call int[13] unknown w[65161]), arg high[65174] :
  (65173 call int[13] w)) : _unknown[51]
  {
    { scopeless
      (65189 return(65177 'new'(65188 call range(65182 call int[13] w)(_low = low)(_high = high))))
    }
  }
  function chpl_build_bounded_range[65204](arg low[65201] :
  (65200 call uint[115] unknown w[65197]), arg high[65210] :
  (65209 call uint[115] w)) : _unknown[51]
  {
    { scopeless
      (65225 return(65213 'new'(65224 call range(65218 call uint[115] w)(_low = low)(_high = high))))
    }
  }
  function chpl_build_bounded_range[65236](arg low[65233] :
  enum[187](?), arg high[65239] :
  enum[187](?)) : _unknown[51]
  {
    if(65269 call _cond_test(65246 call !=(65243 'typeof' low)(65245 'typeof' high)))
    {
      { scopeless
        (65267 call compilerError "ranges of enums must use a single enum type")
      }
    }
    (65285 return(65275 'new'(65284 call range(65278 'typeof' low)(_low = low)(_high = high))))
  }
  function chpl_build_bounded_range[65295](arg low[65292] :
  bool[10], arg high[65298] :
  bool[10]) : _unknown[51]
  {
    { scopeless
      (65310 return(65301 'new'(65309 call range bool[10](_low = low)(_high = high))))
    }
  }
  function chpl_build_bounded_range[65319](arg low[65317]:_any[178](?), arg high[65321]:_any[178](?)) : _unknown[51]
  {
    (65342 call compilerError "Bounds of 'low..high' must be integers of compatible types.")
  }
  function chpl_build_low_bounded_range[65353](arg low[65350] :
  integral) : _unknown[51]
  {
    { scopeless
      (65367 return(65355 'new'(65366 call range(65358 'typeof' low)(65361 call . BoundedRangeType c"boundedLow")(_low = low))))
    }
  }
  function chpl_build_low_bounded_range[65378](arg low[65375] :
  enum[187](?)) : _unknown[51]
  {
    { scopeless
      (65392 return(65380 'new'(65391 call range(65383 'typeof' low)(65386 call . BoundedRangeType c"boundedLow")(_low = low))))
    }
  }
  function chpl_build_low_bounded_range[65403](arg low[65400] :
  bool[10]) : _unknown[51]
  {
    { scopeless
      (65417 return(65405 'new'(65416 call range(65408 'typeof' low)(65411 call . BoundedRangeType c"boundedLow")(_low = low))))
    }
  }
  function chpl_build_low_bounded_range[65426](arg low[65424]:_any[178](?)) : _unknown[51]
  {
    (65447 call compilerError "Bound of 'low..' must be an integer")
  }
  function chpl_build_high_bounded_range[65458](arg high[65455] :
  integral) : _unknown[51]
  {
    { scopeless
      (65472 return(65460 'new'(65471 call range(65463 'typeof' high)(65466 call . BoundedRangeType c"boundedHigh")(_high = high))))
    }
  }
  function chpl_build_high_bounded_range[65483](arg high[65480] :
  enum[187](?)) : _unknown[51]
  {
    { scopeless
      (65497 return(65485 'new'(65496 call range(65488 'typeof' high)(65491 call . BoundedRangeType c"boundedHigh")(_high = high))))
    }
  }
  function chpl_build_high_bounded_range[65508](arg high[65505] :
  bool[10]) : _unknown[51]
  {
    { scopeless
      (65522 return(65510 'new'(65521 call range(65513 'typeof' high)(65516 call . BoundedRangeType c"boundedHigh")(_high = high))))
    }
  }
  function chpl_build_high_bounded_range[65531](arg high[65529]:_any[178](?)) : _unknown[51]
  {
    (65552 call compilerError "Bound of '..high' must be an integer.")
  }
  function chpl_build_unbounded_range[65559]() : _unknown[51]
  {
    { scopeless
      (65572 return(65561 'new'(65571 call range int[13](65568 call . BoundedRangeType c"boundedNone"))))
    }
  }
  function chpl_compute_low_param_loop_bound[65587](param arg low[65584] :
  (65583 call int[13] unknown w[65580]), param arg high[65593] :
  (65592 call int[13] w)) param : _unknown[51]
  {
    (65597 return low)
  }
  function chpl_compute_high_param_loop_bound[65612](param arg low[65609] :
  (65608 call int[13] unknown w[65605]), param arg high[65618] :
  (65617 call int[13] w)) param : _unknown[51]
  {
    (65622 return high)
  }
  function chpl_compute_low_param_loop_bound[65637](param arg low[65634] :
  (65633 call uint[115] unknown w[65630]), param arg high[65643] :
  (65642 call uint[115] w)) param : _unknown[51]
  {
    (65647 return low)
  }
  function chpl_compute_high_param_loop_bound[65662](param arg low[65659] :
  (65658 call uint[115] unknown w[65655]), param arg high[65668] :
  (65667 call uint[115] w)) param : _unknown[51]
  {
    (65672 return high)
  }
  function chpl_compute_low_param_loop_bound[65683](param arg low[65680] :
  bool[10], param arg high[65686] :
  bool[10]) param : _unknown[51]
  {
    (65690 return low)
  }
  function chpl_compute_high_param_loop_bound[65701](param arg low[65698] :
  bool[10], param arg high[65704] :
  bool[10]) param : _unknown[51]
  {
    (65708 return high)
  }
  function chpl_compute_low_param_loop_bound[65717](param arg low[65715]:_any[178](?), param arg high[65719]:_any[178](?)) param : _unknown[51] "last resort"
  {
    (65742 call compilerError "Range bounds must be integers of compatible types in param for-loops")
  }
  function chpl_compute_low_param_loop_bound[65751](arg low[65749]:_any[178](?), arg high[65753]:_any[178](?)) : _unknown[51] "last resort"
  {
    (65774 call compilerError "param for-loops must be defined over a bounded param range")
  }
  function chpl_compute_count_param_loop[65785](param arg count[65782] :
  integral) param : _unknown[51]
  {
    (65788 return count)
  }
  function chpl_compute_count_param_loop[65797](arg count[65795]:_any[178](?)) : _unknown[51] "last resort"
  {
    (65820 call compilerError "in a param for-loop, the count operator requires a param integral value")
  }
  function chpl_low_bound_count_for_param_loop[65831](param arg high[65828] :
  integral, param arg count[65834] :
  integral) param : _unknown[51]
  {
    if(65888 call _cond_test(65839 call > count 0))
    {
      (65860 call compilerError "count operators with positive count require the range to have a low bound")
    }
    {
      { scopeless
        if(65884 call _cond_test(65865 call == count 0))
        {
          (65871 return(65869 call + high 1))
        }
        {
          (65881 return(65879 call +(65876 call + high count) 1))
        }
      }
    }
  }
  function chpl_low_bound_count_for_param_loop[65900](arg high[65898]:_any[178](?), arg count[65902]:_any[178](?)) : _unknown[51] "last resort"
  {
    (65907 call compilerError "Range bounds must be integers of compatible types in param for-loops")
  }
  function chpl_high_bound_count_for_param_loop[65918](param arg low[65915] :
  integral, param arg count[65921] :
  integral) param : _unknown[51]
  {
    if(65977 call _cond_test(65926 call < count 0))
    {
      (65949 call compilerError "count operators with negative count require the range to have a high bound")
    }
    {
      { scopeless
        if(65973 call _cond_test(65954 call == count 0))
        {
          (65960 return(65958 call - low 1))
        }
        {
          (65970 return(65968 call -(65965 call + low count) 1))
        }
      }
    }
  }
  function chpl_high_bound_count_for_param_loop[65989](arg low[65987]:_any[178](?), arg count[65991]:_any[178](?)) : _unknown[51] "last resort"
  {
    (65996 call compilerError "Range bounds must be integers of compatible types in param for-loops")
  }
  function chpl_bounded_count_for_param_loop_low[66007](param arg low[66004] :
  integral, param arg high[66010] :
  integral, param arg count[66014] :
  integral) param : _unknown[51]
  {
    { scopeless
      unknown abs_count[66028] "param"(66025 IfExpr (66019 call < count 0) then
      { scopeless
        (66022 call - count)
      } else
      { scopeless
        count
      } )
      (66031 'end of statement')
    }
    { scopeless
      unknown size[66040] "param"(66038 call +(66035 call - high low) 1)
      (66043 'end of statement')
    }
    if(66133 call _cond_test(66046 call < size abs_count))
    {
      (66092 call compilerError "Count of "(66069 call _cast string[26] abs_count) " is too small for range of size "(66090 call _cast string[26] size))
    }
    {
      { scopeless
        if(66128 call _cond_test(66097 call == count 0))
        {
          (66103 return(66101 call + high 1))
        }
        {
          { scopeless
            if(66124 call _cond_test(66108 call < count 0))
            {
              (66117 return(66115 call +(66112 call + high count) 1))
            }
            {
              (66121 return low)
            }
          }
        }
      }
    }
  }
  function chpl_bounded_count_for_param_loop_low[66144](arg low[66142]:_any[178](?), arg high[66146]:_any[178](?), arg count[66148]:_any[178](?)) : _unknown[51] "last resort"
  {
    (66171 call compilerError "Range bounds and counts must be integers of compatible types in param for-loops")
  }
  function chpl_bounded_count_for_param_loop_high[66182](param arg low[66179] :
  integral, param arg high[66185] :
  integral, param arg count[66189] :
  integral) param : _unknown[51]
  {
    if(66225 call _cond_test(66194 call == count 0))
    {
      (66200 return(66198 call - low 1))
    }
    {
      { scopeless
        if(66221 call _cond_test(66205 call < count 0))
        {
          (66208 return high)
        }
        {
          (66218 return(66216 call -(66213 call + low count) 1))
        }
      }
    }
  }
  function chpl_bounded_count_for_param_loop_high[66237](arg low[66235]:_any[178](?), arg high[66239]:_any[178](?), arg count[66241]:_any[178](?)) : _unknown[51] "last resort"
  {
    (66246 call compilerError "Range bounds and counts must be integers of compatible types in param for-loops")
  }
  function isRangeType[66255](arg t[66253]:_any[178](?)) param : _unknown[51]
  {
    function isRangeHelp[66266](arg t[66263] :
    (66262 call range ?[260])) param : _unknown[51]
    {
      { scopeless
        (66269 return 1)
      }
    }
    function isRangeHelp[66279](arg t[66277]:_any[178](?)) param : _unknown[51]
    {
      { scopeless
        (66282 return 0)
      }
    }
    (66291 return(66290 call isRangeHelp t))
  }
  function isRangeValue[66304](arg r[66301] :
  (66300 call range ?[260])) param : _unknown[51] "no doc"
  {
    { scopeless
      (66307 return 1)
    }
  }
  function isRangeValue[66316](arg r[66314]:_any[178](?)) param : _unknown[51] "no doc"
  {
    { scopeless
      (66319 return 0)
    }
  }
  function isBoundedRange[66328](arg r[66326]:_any[178](?)) param : _unknown[51] "no doc"
  {
    { scopeless
      (66331 return 0)
    }
  }
  function isBoundedRange[66345](arg r[66342] :
  (66341 call range ?[260])) param : _unknown[51]
  {
    { scopeless
      (66354 return(66353 call isBoundedRange(66349 call . r c"boundedType")))
    }
  }
  function isBoundedRange[66365](param arg B[66362] :
  BoundedRangeType) param : _unknown[51] "no doc"
  {
    { scopeless
      (66374 return(66372 call == B(66369 call . BoundedRangeType c"bounded")))
    }
  }
  function _unknown[51].isBounded[66382](arg _mt[66387]:_MT[238], arg this[66384] :
  range) param : _unknown[51] "method"
  {
    { scopeless
      (66396 return(66394 call == boundedType(66391 call . BoundedRangeType c"bounded")))
    }
  }
  function _unknown[51].hasLowBound[66404](arg _mt[66409]:_MT[238], arg this[66406] :
  range) param : _unknown[51] "method"
  {
    { scopeless
      (66427 return(66425 call ||(66416 call == boundedType(66413 call . BoundedRangeType c"bounded"))(66423 call == boundedType(66420 call . BoundedRangeType c"boundedLow"))))
    }
  }
  function _unknown[51].hasHighBound[66435](arg _mt[66440]:_MT[238], arg this[66437] :
  range) param : _unknown[51] "method"
  {
    { scopeless
      (66458 return(66456 call ||(66447 call == boundedType(66444 call . BoundedRangeType c"bounded"))(66454 call == boundedType(66451 call . BoundedRangeType c"boundedHigh"))))
    }
  }
  function _unknown[51].stride[66466](arg _mt[66471]:_MT[238], arg this[66468] :
  range) : _unknown[51] "inline" "method" "no parens"
  {
    { scopeless
      (66475 return _stride)
    }
  }
  where {
    stridable
  }
  function _unknown[51].stride[66484](arg _mt[66489]:_MT[238], arg this[66486] :
  range) param : _unknown[51] "method" "no doc" "no parens"
  {
    { scopeless
      (66498 return(66496 call _cast strType 1))
    }
  }
  where {
    (66492 call ! stridable)
  }
  function _unknown[51].alignment[66507](arg _mt[66512]:_MT[238], arg this[66509] :
  range) : _unknown[51] "inline" "method" "no parens"
  {
    { scopeless
      (66519 return(66518 call chpl_intToIdx _alignment))
    }
  }
  where {
    stridable
  }
  function _unknown[51].alignment[66528](arg _mt[66533]:_MT[238], arg this[66530] :
  range) : _unknown[51] "method" "no doc" "no parens"
  {
    { scopeless
      (66544 return low)
    }
  }
  where {
    (66541 call &&(66536 call ! stridable)(66540 call hasLowBound))
  }
  function _unknown[51].alignment[66553](arg _mt[66558]:_MT[238], arg this[66555] :
  range) : _unknown[51] "method" "no doc" "no parens"
  {
    { scopeless
      (66564 return(66563 call chpl_intToIdx 0))
    }
  }
  function _unknown[51].aligned[66572](arg _mt[66577]:_MT[238], arg this[66574] :
  range) : _unknown[51] "inline" "method" "no parens"
  {
    { scopeless
      (66581 return _aligned)
    }
  }
  where {
    stridable
  }
  function _unknown[51].aligned[66590](arg _mt[66595]:_MT[238], arg this[66592] :
  range) param : _unknown[51] "method" "no doc" "no parens"
  {
    { scopeless
      (66619 return 1)
    }
  }
  where {
    (66616 call &&(66598 call ! stridable)(66614 call ||(66605 call == boundedType(66602 call . BoundedRangeType c"bounded"))(66612 call == boundedType(66609 call . BoundedRangeType c"boundedLow"))))
  }
  function _unknown[51].aligned[66628](arg _mt[66633]:_MT[238], arg this[66630] :
  range) param : _unknown[51] "method" "no doc" "no parens"
  {
    { scopeless
      (66636 return 0)
    }
  }
  function _unknown[51].first[66644](arg _mt[66649]:_MT[238], arg this[66646] :
  range) : _unknown[51] "inline" "method" "no parens"
  {
    (66660 return(66659 call chpl_intToIdx(66655 call . this c"firstAsInt")))
  }
  function _unknown[51].firstAsInt[66668](arg _mt[66673]:_MT[238], arg this[66670] :
  range) : _unknown[51] "inline" "method" "no doc" "no parens"
  {
    if(66702 call _cond_test(66676 call ! stridable))
    {
      { scopeless
        (66679 return _low)
      }
    }
    {
      { scopeless
        (66700 return(66697 IfExpr (66683 call > _stride 0) then
        { scopeless
          (66688 call . this c"alignedLowAsInt")
        } else
        { scopeless
          (66694 call . this c"alignedHighAsInt")
        } ))
      }
    }
  }
  function _unknown[51].last[66714](arg _mt[66719]:_MT[238], arg this[66716] :
  range) : _unknown[51] "inline" "method" "no parens"
  {
    (66730 return(66729 call chpl_intToIdx(66725 call . this c"lastAsInt")))
  }
  function _unknown[51].lastAsInt[66738](arg _mt[66743]:_MT[238], arg this[66740] :
  range) : _unknown[51] "inline" "method" "no doc" "no parens"
  {
    if(66768 call _cond_test(66746 call ! stridable))
    {
      { scopeless
        (66749 return _high)
      }
    }
    {
      { scopeless
        (66766 return(66763 IfExpr (66753 call > stride 0) then
        { scopeless
          (66756 call . this c"alignedHighAsInt")
        } else
        { scopeless
          (66760 call . this c"alignedLowAsInt")
        } ))
      }
    }
  }
  function _unknown[51].low[66780](arg _mt[66785]:_MT[238], arg this[66782] :
  range) : _unknown[51] "inline" "method" "no parens"
  {
    { scopeless
      (66791 return(66790 call chpl_intToIdx _low))
    }
  }
  function _unknown[51].high[66799](arg _mt[66804]:_MT[238], arg this[66801] :
  range) : _unknown[51] "inline" "method" "no parens"
  {
    { scopeless
      (66810 return(66809 call chpl_intToIdx _high))
    }
  }
  function _unknown[51].alignedLow[66818](arg _mt[66823]:_MT[238], arg this[66820] :
  range) : _unknown[51] "inline" "method" "no parens"
  {
    (66833 return(66832 call chpl_intToIdx(66828 call . this c"alignedLowAsInt")))
  }
  { scopeless type
    idxType
  }
  function _unknown[51].alignedLowAsInt[66842](arg _mt[66847]:_MT[238], arg this[66844] :
  range) : _unknown[51] "inline" "method" "no doc" "no parens"
  {
    if(66866 call _cond_test(66850 call ! stridable))
    {
      { scopeless
        (66853 return _low)
      }
    }
    {
      { scopeless
        (66864 return(66862 call + _low(66861 call chpl__diffMod _alignment _low stride)))
      }
    }
  }
  function _unknown[51].alignedHigh[66878](arg _mt[66883]:_MT[238], arg this[66880] :
  range) : _unknown[51] "inline" "method" "no parens"
  {
    (66893 return(66892 call chpl_intToIdx(66888 call . this c"alignedHighAsInt")))
  }
  { scopeless type
    idxType
  }
  function _unknown[51].alignedHighAsInt[66902](arg _mt[66907]:_MT[238], arg this[66904] :
  range) : _unknown[51] "inline" "method" "no doc" "no parens"
  {
    if(66926 call _cond_test(66910 call ! stridable))
    {
      { scopeless
        (66913 return _high)
      }
    }
    {
      { scopeless
        (66924 return(66922 call - _high(66921 call chpl__diffMod _high _alignment stride)))
      }
    }
  }
  function _unknown[51].isEmpty[66938](arg _mt[66943]:_MT[238], arg this[66940] :
  range) : _unknown[51] "inline" "method"
  {
    if(66993 call _cond_test(66949 call && boundsChecking(66948 call isAmbiguous)))
    {
      { scopeless
        (66973 call(66952 call . HaltWrappers c"boundsCheckHalt") "isEmpty() is invoked on an ambiguously-aligned range")
      }
    }
    {
      { scopeless
        (66991 return(66989 call &&(66978 call isBoundedRange this)(66987 call >(66980 call . this c"alignedLow")(66984 call . this c"alignedHigh"))))
      }
    }
  }
  function _unknown[51].length[67005](arg _mt[67010]:_MT[238], arg this[67007] :
  range) : _unknown[51] "inline" "method" "no parens"
  {
    (67051 call compilerWarning(67048 call + "'range.length' is deprecated - " "please use 'range.size' instead"))
    (67058 return(67055 call . this c"size"))
  }
  { scopeless type
    intIdxType
  }
  function _unknown[51].size[67066](arg _mt[67071]:_MT[238], arg this[67068] :
  range) : _unknown[51] "method" "no parens"
  {
    if(67101 call _cond_test(67078 call !(67077 call isBoundedRange this)))
    {
      { scopeless
        (67099 call compilerError "'size' is not defined on unbounded ranges")
      }
    }
    { scopeless
      const ah[67111] "const"(67108 call . this c"alignedHighAsInt")
      const al[67118] "const"(67115 call . this c"alignedLowAsInt")
      (67121 'end of statement')
    }
    if(67132 call _cond_test(67124 call > al ah))
    {
      { scopeless
        (67130 return(67128 call _cast intIdxType 0))
      }
    }
    { scopeless
      const s[67147] "const"(67145 call _cast intIdxType(67143 call abs(67139 call . this c"stride")))
      (67150 'end of statement')
    }
    (67164 return(67162 call +(67156 call /(67153 call - ah al) s)(67160 call _cast intIdxType 1)))
  }
  { scopeless type
    intIdxType
  }
  function _unknown[51].hasFirst[67172](arg _mt[67177]:_MT[238], arg this[67174] :
  range) param : _unknown[51] "method"
  {
    { scopeless
      (67192 return(67191 call hasLowBound))
    }
  }
  where {
    (67187 call &&(67180 call ! stridable)(67185 call !(67184 call hasHighBound)))
  }
  function _unknown[51].hasFirst[67201](arg _mt[67206]:_MT[238], arg this[67203] :
  range) : _unknown[51] "inline" "method" "no doc"
  {
    { scopeless
      (67233 return(67230 IfExpr (67214 call ||(67210 call isAmbiguous)(67213 call isEmpty)) then
      { scopeless
        0
      } else
      { scopeless(67227 IfExpr (67219 call > stride 0) then
        { scopeless
          (67223 call hasLowBound)
        } else
        { scopeless
          (67226 call hasHighBound)
        } )
      } ))
    }
  }
  function _unknown[51].hasLast[67241](arg _mt[67246]:_MT[238], arg this[67243] :
  range) param : _unknown[51] "method"
  {
    { scopeless
      (67261 return(67260 call hasHighBound))
    }
  }
  where {
    (67256 call &&(67249 call ! stridable)(67254 call !(67253 call hasLowBound)))
  }
  function _unknown[51].hasLast[67270](arg _mt[67275]:_MT[238], arg this[67272] :
  range) : _unknown[51] "inline" "method" "no doc"
  {
    { scopeless
      (67302 return(67299 IfExpr (67283 call ||(67279 call isAmbiguous)(67282 call isEmpty)) then
      { scopeless
        0
      } else
      { scopeless(67296 IfExpr (67288 call > stride 0) then
        { scopeless
          (67292 call hasHighBound)
        } else
        { scopeless
          (67295 call hasLowBound)
        } )
      } ))
    }
  }
  function _unknown[51].isNaturallyAligned[67310](arg _mt[67315]:_MT[238], arg this[67312] :
  range) : _unknown[51] "method"
  {
    if(67343 call _cond_test(67332 call > stride 0))
    {
      { scopeless
        (67341 return(67339 call ==(67335 call . this c"alignedLowAsInt") _low))
      }
    }
    if(67362 call _cond_test(67351 call < stride 0))
    {
      { scopeless
        (67360 return(67358 call ==(67354 call . this c"alignedHighAsInt") _high))
      }
    }
    (67368 return 0)
  }
  where {
    (67328 call && stridable(67326 call ==(67319 call . this c"boundedType")(67323 call . BoundedRangeType c"bounded")))
  }
  function _unknown[51].isNaturallyAligned[67376](arg _mt[67381]:_MT[238], arg this[67378] :
  range) param : _unknown[51] "inline" "method" "no doc"
  {
    (67399 return 1)
  }
  where {
    (67396 call &&(67384 call ! stridable)(67394 call ==(67387 call . this c"boundedType")(67391 call . BoundedRangeType c"bounded")))
  }
  function _unknown[51].isNaturallyAligned[67408](arg _mt[67413]:_MT[238], arg this[67410] :
  range) : _unknown[51] "inline" "method" "no doc"
  {
    (67437 return(67435 call ==(67431 call . this c"alignedLowAsInt") _low))
  }
  where {
    (67428 call &&(67416 call ! stridable)(67426 call ==(67419 call . this c"boundedType")(67423 call . BoundedRangeType c"boundedLow")))
  }
  function _unknown[51].isNaturallyAligned[67446](arg _mt[67451]:_MT[238], arg this[67448] :
  range) : _unknown[51] "inline" "method" "no doc"
  {
    (67479 return(67477 call &&(67468 call > stride 0)(67475 call ==(67471 call . this c"alignedLowAsInt") _low)))
  }
  where {
    (67464 call && stridable(67462 call ==(67455 call . this c"boundedType")(67459 call . BoundedRangeType c"boundedLow")))
  }
  function _unknown[51].isNaturallyAligned[67488](arg _mt[67493]:_MT[238], arg this[67490] :
  range) param : _unknown[51] "inline" "method" "no doc"
  {
    (67523 return 0)
  }
  where {
    (67520 call ||(67503 call ==(67496 call . this c"boundedType")(67500 call . BoundedRangeType c"boundedNone"))(67518 call &&(67506 call ! stridable)(67516 call ==(67509 call . this c"boundedType")(67513 call . BoundedRangeType c"boundedHigh"))))
  }
  function _unknown[51].isNaturallyAligned[67532](arg _mt[67537]:_MT[238], arg this[67534] :
  range) : _unknown[51] "inline" "method" "no doc"
  {
    (67565 return(67563 call &&(67554 call < stride 0)(67561 call ==(67557 call . this c"alignedHighAsInt") _high)))
  }
  where {
    (67550 call && stridable(67548 call ==(67541 call . this c"boundedType")(67545 call . BoundedRangeType c"boundedHigh")))
  }
  function _unknown[51].isAmbiguous[67574](arg _mt[67579]:_MT[238], arg this[67576] :
  range) param : _unknown[51] "method"
  {
    { scopeless
      (67585 return 0)
    }
  }
  where {
    (67582 call ! stridable)
  }
  function _unknown[51].isAmbiguous[67594](arg _mt[67599]:_MT[238], arg this[67596] :
  range) : _unknown[51] "method" "no doc"
  {
    { scopeless
      (67619 return(67617 call &&(67603 call ! aligned)(67615 call ||(67607 call > stride 1)(67613 call < stride(67611 call - 1)))))
    }
  }
  where {
    stridable
  }
  function _unknown[51].contains[67632](arg _mt[67637]:_MT[238], arg this[67634] :
  range, arg ind[67629] :
  idxType) : _unknown[51] "inline" "method"
  {
    if(67650 call _cond_test(67646 call(67642 call . this c"isAmbiguous")))
    {
      { scopeless
        (67648 return 0)
      }
    }
    { scopeless
      const i[67660] "const"(67659 call chpl__idxToInt ind)
      (67663 'end of statement')
    }
    if(67680 call _cond_test(67666 call hasHighBound))
    {
      if(67674 call _cond_test(67669 call > i _high))
      {
        { scopeless
          (67672 return 0)
        }
      }
    }
    if(67700 call _cond_test(67686 call hasLowBound))
    {
      if(67694 call _cond_test(67689 call < i _low))
      {
        { scopeless
          (67692 return 0)
        }
      }
    }
    if(67734 call _cond_test stridable)
    {
      { scopeless
        unknown s[67712](67710 call _cast intIdxType(67708 call abs _stride))
        (67715 'end of statement')
      }
      if(67729 call _cond_test(67724 call !=(67722 call chpl__diffMod i _alignment s) 0))
      {
        { scopeless
          (67727 return 0)
        }
      }
    }
    (67739 return 1)
  }
  function _unknown[51].contains[67753](arg _mt[67758]:_MT[238], arg this[67755] :
  range, arg other[67750] :
  (67749 call range ?[260])) : _unknown[51] "inline" "method"
  {
    if(67777 call _cond_test(67772 call ||(67765 call(67761 call . this c"isAmbiguous"))(67771 call(67767 call . other c"isAmbiguous"))))
    {
      { scopeless
        (67775 return 0)
      }
    }
    if(67845 call _cond_test stridable)
    {
      if(67819 call _cond_test(67810 call ||(67795 call &&(67786 call > stride 0)(67793 call <(67789 call . other c"stride") 0))(67808 call &&(67799 call < stride 0)(67806 call >(67802 call . other c"stride") 0))))
      {
        { scopeless
          (67817 return(67816 call _containsHelp this other))
        }
      }
    }
    {
      if(67839 call _cond_test(67830 call <(67826 call . other c"stride") 0))
      {
        { scopeless
          (67837 return(67836 call _containsHelp this other))
        }
      }
    }
    (67856 return(67854 call == other(67853 call this other)))
  }
  function _unknown[51].member[67867](arg _mt[67872]:_MT[238], arg this[67869] :
  range, arg ind[67864] :
  idxType) : _unknown[51] "inline" "method"
  {
    (67912 call compilerWarning(67909 call + "range.member is deprecated - " "please use range.contains instead"))
    (67924 return(67923 call(67918 call . this c"contains") ind))
  }
  function _unknown[51].member[67938](arg _mt[67943]:_MT[238], arg this[67940] :
  range, arg other[67935] :
  (67934 call range ?[260])) : _unknown[51] "inline" "method"
  {
    (67951 call compilerWarning(67948 call + "range.member is deprecated - " "please use range.contains instead"))
    (67961 return(67960 call(67955 call . this c"contains") other))
  }
  function _containsHelp[67974](in arg arg1[67971] :
  (67970 call range ?[260]), in arg arg2[67980] :
  (67979 call range ?[260])) : _unknown[51] "inline" "private"
  {
    if(68013 call _cond_test(67984 call . arg2 c"stridable"))
    {
      { scopeless
        (67997 call =(67988 call . arg2 c"_stride")(67995 call -(67992 call . arg2 c"_stride")))
      }
    }
    {
      { scopeless
        (68010 call =(68001 call . arg1 c"_stride")(68008 call -(68005 call . arg1 c"_stride")))
      }
    }
    (68027 return(68025 call == arg2(68024 call arg1 arg2)))
  }
  function ==[68040](arg r1[68037] :
  (68036 call range ?[260]), arg r2[68046] :
  (68045 call range ?[260])) param : _unknown[51]
  {
    { scopeless
      (68060 return 0)
    }
  }
  where {
    (68057 call !=(68050 call . r1 c"boundedType")(68054 call . r2 c"boundedType"))
  }
  function ==[68075](arg r1[68072] :
  (68071 call range ?[260]), arg r2[68081] :
  (68080 call range ?[260])) : _unknown[51]
  {
    if(68112 call _cond_test(68107 call !=(68100 call(68096 call . r1 c"isAmbiguous"))(68106 call(68102 call . r2 c"isAmbiguous"))))
    {
      { scopeless
        (68110 return 0)
      }
    }
    if(68131 call _cond_test(68123 call(68119 call . r1 c"isAmbiguous")))
    {
      { scopeless
        (68129 return(68128 call ident r1 r2))
      }
    }
    if(68313 call _cond_test(68139 call isBoundedRange r1))
    {
      { scopeless
        const len[68144] "const"(68141 call . r1 c"size")
        const l2[68151] "const"(68148 call . r2 c"size")
        (68154 'end of statement')
      }
      if(68163 call _cond_test(68158 call != len l2))
      {
        { scopeless
          (68161 return 0)
        }
      }
      if(68175 call _cond_test(68170 call == len 0))
      {
        { scopeless
          (68173 return 1)
        }
      }
      if(68195 call _cond_test(68190 call !=(68183 call . r1 c"first")(68187 call . r2 c"first")))
      {
        { scopeless
          (68193 return 0)
        }
      }
      if(68207 call _cond_test(68202 call == len 1))
      {
        { scopeless
          (68205 return 1)
        }
      }
      if(68225 call _cond_test(68220 call !=(68213 call . r1 c"stride")(68217 call . r2 c"stride")))
      {
        { scopeless
          (68223 return 0)
        }
      }
      (68231 return 1)
    }
    {
      if(68246 call _cond_test(68241 call !=(68234 call . r1 c"stride")(68238 call . r2 c"stride")))
      {
        { scopeless
          (68244 return 0)
        }
      }
      if(68276 call _cond_test(68257 call(68253 call . r1 c"hasLowBound")))
      {
        { scopeless
          if(68271 call _cond_test(68266 call !=(68259 call . r1 c"alignedLow")(68263 call . r2 c"alignedLow")))
          {
            { scopeless
              (68269 return 0)
            }
          }
        }
      }
      if(68305 call _cond_test(68286 call(68282 call . r1 c"hasHighBound")))
      {
        { scopeless
          if(68300 call _cond_test(68295 call !=(68288 call . r1 c"alignedHigh")(68292 call . r2 c"alignedHigh")))
          {
            { scopeless
              (68298 return 0)
            }
          }
        }
      }
      (68311 return 1)
    }
  }
  where {
    (68093 call ==(68086 call . r1 c"boundedType")(68090 call . r2 c"boundedType"))
  }
  { scopeless type
    bool[10]
  }
  function !=[68330](arg r1[68327] :
  (68326 call range ?[260]), arg r2[68336] :
  (68335 call range ?[260])) : _unknown[51]
  {
    { scopeless
      (68345 return(68343 call !(68341 call == r1 r2)))
    }
  }
  function ident[68359](arg r1[68356] :
  (68355 call range ?[260]), arg r2[68365] :
  (68364 call range ?[260])) : _unknown[51]
  {
    if(68415 call _cond_test(68410 call !=(68403 call . r1 c"_low")(68407 call . r2 c"_low")))
    {
      { scopeless
        (68413 return 0)
      }
    }
    if(68434 call _cond_test(68429 call !=(68422 call . r1 c"_high")(68426 call . r2 c"_high")))
    {
      { scopeless
        (68432 return 0)
      }
    }
    if(68511 call _cond_test(68440 call . r1 c"stridable"))
    {
      if(68506 call _cond_test(68444 call . r2 c"stridable"))
      {
        if(68460 call _cond_test(68455 call !=(68448 call . r1 c"_stride")(68452 call . r2 c"_stride")))
        {
          { scopeless
            (68458 return 0)
          }
        }
        if(68479 call _cond_test(68474 call !=(68467 call . r1 c"_alignment")(68471 call . r2 c"_alignment")))
        {
          { scopeless
            (68477 return 0)
          }
        }
        if(68497 call _cond_test(68492 call !=(68485 call . r1 c"_aligned")(68489 call . r2 c"_aligned")))
        {
          { scopeless
            (68495 return 0)
          }
        }
      }
      {
        (68503 return 0)
      }
    }
    (68516 return 1)
  }
  where {
    (68400 call &&(68388 call &&(68376 call ==(68369 call . r1 c"idxType")(68373 call . r2 c"idxType"))(68386 call ==(68379 call . r1 c"boundedType")(68383 call . r2 c"boundedType")))(68398 call ==(68391 call . r1 c"stridable")(68395 call . r2 c"stridable")))
  }
  function ident[68530](arg r1[68527] :
  (68526 call range ?[260]), arg r2[68536] :
  (68535 call range ?[260])) param : _unknown[51] "no doc"
  {
    { scopeless
      (68540 return 0)
    }
  }
  function _unknown[51].safeCast[68555](arg _mt[68560]:_MT[238], arg this[68557] :
  range, arg t[68552] :
  (68551 call range ?[260])) : _unknown[51] "method" "no doc"
  {
    { scopeless
      unknown tmp[68563] t
      (68566 'end of statement')
    }
    if(68631 call _cond_test(68576 call !=(68569 call . tmp c"boundedType")(68573 call . this c"boundedType")))
    {
      (68628 call compilerError "cannot cast range from "(68602 call _cast string[26](68598 call . this c"boundedType")) " to "(68626 call _cast string[26](68622 call . tmp c"boundedType")))
    }
    if(68725 call _cond_test(68636 call . tmp c"stridable"))
    {
      (68647 call =(68640 call . tmp c"_stride")(68644 call . this c"stride"))
      (68673 call =(68652 call . tmp c"_alignment")(68672 call(68662 call .(68661 call chpl__idxToInt(68657 call . this c"alignment")) c"safeCast")(68668 call . tmp c"intIdxType")))
      (68684 call =(68677 call . tmp c"_aligned")(68681 call . this c"aligned"))
    }
    {
      { scopeless
        if(68721 call _cond_test(68692 call !=(68688 call . this c"stride") 1))
        {
          (68718 call(68697 call . HaltWrappers c"safeCastCheckHalt") "illegal safeCast from non-unit stride range to unstridable range")
        }
      }
    }
    (68747 call =(68731 call . tmp c"_low")(68746 call(68738 call .(68735 call . this c"_low") c"safeCast")(68742 call . tmp c"intIdxType")))
    (68767 call =(68751 call . tmp c"_high")(68766 call(68758 call .(68755 call . this c"_high") c"safeCast")(68762 call . tmp c"intIdxType")))
    (68771 return tmp)
  }
  function _cast[68784](arg t[68781] :
  (68780 call range ?[260]), arg r[68790] :
  (68789 call range ?[260])) : _unknown[51] "no doc"
  {
    { scopeless
      unknown tmp[68794] t
      (68797 'end of statement')
    }
    if(68830 call _cond_test(68807 call !=(68800 call . tmp c"boundedType")(68804 call . r c"boundedType")))
    {
      (68827 call compilerError "cannot cast range from "(68817 call _cast string[26](68813 call . r c"boundedType")) " to "(68825 call _cast string[26](68821 call . tmp c"boundedType")))
    }
    if(68878 call _cond_test(68835 call . tmp c"stridable"))
    {
      (68846 call =(68839 call . tmp c"_stride")(68843 call . r c"_stride"))
      (68864 call =(68851 call . tmp c"_alignment")(68862 call _cast(68859 call . tmp c"intIdxType")(68855 call . r c"_alignment")))
      (68875 call =(68868 call . tmp c"_aligned")(68872 call . r c"_aligned"))
    }
    (68896 call =(68883 call . tmp c"_low")(68894 call _cast(68891 call . tmp c"intIdxType")(68887 call . r c"low")))
    (68913 call =(68900 call . tmp c"_high")(68911 call _cast(68908 call . tmp c"intIdxType")(68904 call . r c"high")))
    (68917 return tmp)
  }
  function _unknown[51].boundsCheck[68936](arg _mt[68941]:_MT[238], arg this[68938] :
  range, arg other[68933] :
  (68932 call range unknown e[68925] unknown b[68928] unknown s[68930])) : _unknown[51] "inline" "method"
  {
    if(68967 call _cond_test(68962 call ||(68955 call(68951 call . this c"isAmbiguous"))(68961 call(68957 call . other c"isAmbiguous"))))
    {
      { scopeless
        (68965 return 0)
      }
    }
    (68974 return 1)
  }
  where {
    (68948 call == b(68945 call . BoundedRangeType c"boundedNone"))
  }
  function _unknown[51].boundsCheck[68994](arg _mt[68999]:_MT[238], arg this[68996] :
  range, arg other[68991] :
  (68990 call range unknown e[68983] unknown b[68986] unknown s[68988])) : _unknown[51] "inline" "method" "no doc"
  {
    if(69018 call _cond_test(69013 call ||(69006 call(69002 call . this c"isAmbiguous"))(69012 call(69008 call . other c"isAmbiguous"))))
    {
      { scopeless
        (69016 return 0)
      }
    }
    { scopeless
      unknown boundedOther[69077](69024 'new'(69076 call range idxType(69029 call . BoundedRangeType c"bounded")(69037 call || s(69034 call . this c"stridable"))(69050 IfExpr (69044 call(69040 call . other c"hasLowBound")) then
      { scopeless
        (69046 call . other c"low")
      } else
      { scopeless
        low
      } )(69064 IfExpr (69058 call(69054 call . other c"hasHighBound")) then
      { scopeless
        (69060 call . other c"high")
      } else
      { scopeless
        high
      } )(69068 call . other c"stride")(69072 call . other c"alignment") 1))
      (69080 'end of statement')
    }
    (69094 return(69092 call ||(69086 call ==(69082 call . boundedOther c"size") 0)(69091 call contains boundedOther)))
  }
  function _unknown[51].boundsCheck[69105](arg _mt[69110]:_MT[238], arg this[69107] :
  range, arg other[69102] :
  idxType) : _unknown[51] "inline" "method"
  {
    { scopeless
      (69116 return(69115 call contains other))
    }
  }
  function _unknown[51].alignLow[69124](arg _mt[69129]:_MT[238], ref arg this[69126] :
  range) : _unknown[51] "method" "no doc"
  {
    if(69166 call _cond_test(69138 call && boundsChecking(69137 call(69133 call . this c"isAmbiguous"))))
    {
      { scopeless
        (69164 call(69141 call . HaltWrappers c"boundsCheckHalt") "alignLow -- Cannot be applied to a range with ambiguous alignment.")
      }
    }
    if(69181 call _cond_test stridable)
    {
      { scopeless
        (69178 call = _low(69175 call . this c"alignedLowAsInt"))
      }
    }
    (69187 return this)
  }
  function _unknown[51].alignHigh[69194](arg _mt[69199]:_MT[238], ref arg this[69196] :
  range) : _unknown[51] "method" "no doc"
  {
    if(69234 call _cond_test(69208 call && boundsChecking(69207 call(69203 call . this c"isAmbiguous"))))
    {
      { scopeless
        (69232 call(69211 call . HaltWrappers c"boundsCheckHalt") "alignHigh -- Cannot be applied to a range with ambiguous alignment.")
      }
    }
    if(69249 call _cond_test stridable)
    {
      { scopeless
        (69246 call = _high(69243 call . this c"alignedHighAsInt"))
      }
    }
    (69255 return this)
  }
  function _unknown[51].indexOrder[69266](arg _mt[69271]:_MT[238], arg this[69268] :
  range, arg ind[69263] :
  idxType) : _unknown[51] "method"
  {
    if(69306 call _cond_test(69280 call && boundsChecking(69279 call(69275 call . this c"isAmbiguous"))))
    {
      { scopeless
        (69304 call(69283 call . HaltWrappers c"boundsCheckHalt") "indexOrder -- Undefined on a range with ambiguous alignment.")
      }
    }
    if(69326 call _cond_test(69316 call !(69315 call contains ind)))
    {
      { scopeless
        (69324 return(69322 call _cast intIdxType(69319 call - 1)))
      }
    }
    if(69396 call _cond_test(69332 call ! stridable))
    {
      if(69349 call _cond_test(69339 call(69335 call . this c"hasLowBound")))
      {
        { scopeless
          (69347 return(69345 call -(69343 call chpl__idxToInt ind) _low))
        }
      }
    }
    {
      if(69390 call _cond_test(69362 call(69358 call . this c"hasFirst")))
      {
        { scopeless
          (69388 return(69386 call _cast intIdxType(69383 call /(69380 call -(69368 call _cast strType(69366 call chpl__idxToInt ind))(69378 call _cast strType(69376 call chpl__idxToInt(69372 call . this c"first")))) _stride)))
        }
      }
    }
    (69406 return(69404 call _cast intIdxType(69401 call - 1)))
  }
  function _unknown[51].orderToIndex[69417](arg _mt[69422]:_MT[238], arg this[69419] :
  range, arg ord[69414] :
  integral) : _unknown[51] "method"
  {
    if(69608 call _cond_test boundsChecking)
    {
      if(69455 call _cond_test(69429 call !(69428 call hasFirst)))
      {
        { scopeless
          (69453 call(69432 call . HaltWrappers c"boundsCheckHalt") "invoking orderToIndex on a range that has no first index")
        }
      }
      if(69488 call _cond_test(69463 call isAmbiguous))
      {
        { scopeless
          (69486 call(69465 call . HaltWrappers c"boundsCheckHalt") "invoking orderToIndex on a range that is ambiguously aligned")
        }
      }
      if(69527 call _cond_test(69495 call < ord 0))
      {
        { scopeless
          (69525 call(69498 call . HaltWrappers c"boundsCheckHalt")(69522 call + "invoking orderToIndex on a negative integer: "(69520 call _cast string[26] ord)))
        }
      }
      if(69603 call _cond_test(69543 call &&(69535 call isBoundedRange this)(69541 call >= ord(69538 call . this c"size"))))
      {
        { scopeless
          (69601 call(69546 call . HaltWrappers c"boundsCheckHalt")(69598 call +(69589 call +(69570 call + "invoking orderToIndex on an integer "(69568 call _cast string[26] ord)) " that is larger than the range's number of indices ")(69596 call _cast string[26](69592 call . this c"size"))))
        }
      }
    }
    (69628 return(69627 call chpl_intToIdx(69625 call chpl__addRangeStrides(69616 call . this c"firstAsInt")(69621 call . this c"stride") ord)))
  }
  { scopeless type
    idxType
  }
  function _unknown[51].translate[69640](arg _mt[69645]:_MT[238], arg this[69642] :
  range, arg offset[69637] :
  integral) : _unknown[51] "inline" "method"
  {
    { scopeless
      (69651 return(69649 call + this offset))
    }
  }
  function _unknown[51].translate[69661](arg _mt[69666]:_MT[238], arg this[69663] :
  range, arg i[69659]:_any[178](?)) : _unknown[51] "inline" "method" "no doc"
  {
    (69687 call compilerError "offsets must be of integral type")
  }
  function _unknown[51]._effAlmt[69695](arg _mt[69700]:_MT[238], arg this[69697] :
  range) : _unknown[51] "inline" "method" "no doc"
  {
    { scopeless
      (69704 return alignment)
    }
  }
  where {
    stridable
  }
  function _unknown[51]._effAlmt[69713](arg _mt[69718]:_MT[238], arg this[69715] :
  range) : _unknown[51] "method" "no doc"
  {
    { scopeless
      (69727 return(69726 call chpl_intToIdx 0))
    }
  }
  where {
    (69721 call ! stridable)
  }
  function _unknown[51].interior[69740](arg _mt[69745]:_MT[238], arg this[69742] :
  range, arg offset[69737] :
  integral) : _unknown[51] "method" "no doc"
  {
    (69773 call compilerError "interior is not supported on unbounded ranges")
  }
  where {
    (69752 call != boundedType(69749 call . BoundedRangeType c"bounded"))
  }
  function _unknown[51].interior[69786](arg _mt[69791]:_MT[238], arg this[69788] :
  range, arg offset[69783] :
  integral) : _unknown[51] "method"
  {
    { scopeless
      const i[69800] "const"(69799 call(69794 call . offset c"safeCast") intIdxType)
      (69803 'end of statement')
    }
    if(69834 call _cond_test(69807 call < i 0))
    {
      { scopeless
        (69832 return(69809 'new'(69831 call range idxType boundedType stridable low(69825 call chpl_intToIdx(69822 call -(69819 call - _low 1) i)) stride(69829 call _effAlmt) aligned)))
      }
    }
    if(69868 call _cond_test(69841 call > i 0))
    {
      { scopeless
        (69866 return(69843 'new'(69865 call range idxType boundedType stridable(69858 call chpl_intToIdx(69855 call -(69852 call + _high 1) i)) high stride(69863 call _effAlmt) aligned)))
      }
    }
    (69887 return(69873 'new'(69886 call range idxType boundedType stridable low high stride(69884 call _effAlmt) aligned)))
  }
  function _unknown[51].exterior[69898](arg _mt[69903]:_MT[238], arg this[69900] :
  range, arg offset[69895] :
  integral) : _unknown[51] "method" "no doc"
  {
    (69931 call compilerError "exterior is not supported on unbounded ranges")
  }
  where {
    (69910 call != boundedType(69907 call . BoundedRangeType c"bounded"))
  }
  function _unknown[51].exterior[69944](arg _mt[69949]:_MT[238], arg this[69946] :
  range, arg offset[69941] :
  integral) : _unknown[51] "method"
  {
    { scopeless
      const i[69958] "const"(69957 call(69952 call . offset c"safeCast") intIdxType)
      (69961 'end of statement')
    }
    if(69995 call _cond_test(69965 call < i 0))
    {
      { scopeless
        (69993 return(69967 'new'(69992 call range idxType boundedType stridable(69979 call chpl_intToIdx(69976 call + _low i))(69986 call chpl_intToIdx(69983 call - _low 1)) stride(69990 call _effAlmt) aligned)))
      }
    }
    if(70032 call _cond_test(70002 call > i 0))
    {
      { scopeless
        (70030 return(70004 'new'(70029 call range idxType boundedType stridable(70016 call chpl_intToIdx(70013 call + _high 1))(70023 call chpl_intToIdx(70020 call + _high i)) stride(70027 call _effAlmt) aligned)))
      }
    }
    (70051 return(70037 'new'(70050 call range idxType boundedType stridable low high stride(70048 call _effAlmt) aligned)))
  }
  function _unknown[51].expand[70062](arg _mt[70067]:_MT[238], arg this[70064] :
  range, arg offset[70059] :
  integral) : _unknown[51] "method" "no doc"
  {
    (70095 call compilerError "expand() is not supported on unbounded ranges")
  }
  where {
    (70074 call != boundedType(70071 call . BoundedRangeType c"bounded"))
  }
  function _unknown[51].expand[70108](arg _mt[70113]:_MT[238], arg this[70110] :
  range, arg offset[70105] :
  integral) : _unknown[51] "method"
  {
    { scopeless
      const i[70122] "const"(70121 call(70116 call . offset c"safeCast") intIdxType)
      (70125 'end of statement')
    }
    (70151 return(70127 'new'(70150 call range idxType boundedType stridable(70139 call chpl_intToIdx(70136 call - _low i))(70146 call chpl_intToIdx(70143 call + _high i)) stride alignment _aligned)))
  }
  function =[70166](ref arg r1[70163] :
  (70162 call range(stridable = unknown s1[70158])), arg r2[70174] :
  (70173 call range(stridable = unknown s2[70169]))) : _unknown[51] "assignop" "inline"
  {
    if(70210 call _cond_test(70185 call !=(70178 call . r1 c"boundedType")(70182 call . r2 c"boundedType")))
    {
      { scopeless
        (70208 call compilerError "type mismatch in assignment of ranges with different boundedType parameters")
      }
    }
    if(70278 call _cond_test(70220 call &&(70217 call ! s1) s2))
    {
      { scopeless
        (70241 call compilerError "type mismatch in assignment of ranges with different stridable parameters")
      }
    }
    {
      { scopeless
        if(70272 call _cond_test(70245 call && s1 s2))
        {
          { scopeless
            (70255 call =(70248 call . r1 c"_stride")(70252 call . r2 c"stride"))
          }
        }
        {
          { scopeless
            if(70267 call _cond_test s1)
            {
              { scopeless
                (70264 call =(70260 call . r1 c"_stride") 1)
              }
            }
          }
        }
      }
    }
    (70292 call =(70285 call . r1 c"_low")(70289 call . r2 c"_low"))
    (70303 call =(70296 call . r1 c"_high")(70300 call . r2 c"_high"))
    if(70333 call _cond_test s1)
    {
      (70318 call =(70308 call . r1 c"_alignment")(70317 call chpl__idxToInt(70313 call . r2 c"alignment")))
      (70330 call =(70323 call . r1 c"_aligned")(70327 call . r2 c"aligned"))
    }
  }
  function +[70353](arg r[70350] :
  (70349 call range unknown e[70342] unknown b[70345] unknown s[70347]), arg offset[70356] :
  integral) : _unknown[51] "inline"
  {
    { scopeless
      const i[70366] "const"(70364 call _cast(70361 call . r c"intIdxType") offset)
      (70369 'end of statement')
    }
    unknown strType[70375] "type variable"(70374 call chpl__rangeStrideType e)
    (70440 return(70378 'new'(70439 call range e b s(70398 call(70387 call . r c"chpl_intToIdx")(70395 call +(70391 call . r c"_low") i))(70411 call(70400 call . r c"chpl_intToIdx")(70408 call +(70404 call . r c"_high") i))(70417 call _cast strType(70413 call . r c"stride"))(70434 call(70420 call . r c"chpl_intToIdx")(70431 call +(70429 call chpl__idxToInt(70425 call . r c"alignment")) i))(70436 call . r c"aligned"))))
  }
  function +[70450](arg i[70447] :
  integral, arg r[70461] :
  (70460 call range unknown e[70453] unknown b[70456] unknown s[70458])) : _unknown[51] "inline"
  {
    { scopeless
      (70468 return(70466 call + r i))
    }
  }
  function -[70487](arg r[70484] :
  (70483 call range unknown e[70476] unknown b[70479] unknown s[70481]), arg i[70490] :
  integral) : _unknown[51] "inline"
  {
    unknown strType[70497] "type variable"(70496 call chpl__rangeStrideType e)
    (70561 return(70501 'new'(70560 call range e b s(70519 call(70508 call . r c"chpl_intToIdx")(70516 call -(70512 call . r c"_low") i))(70532 call(70521 call . r c"chpl_intToIdx")(70529 call -(70525 call . r c"_high") i))(70538 call _cast strType(70534 call . r c"stride"))(70555 call(70541 call . r c"chpl_intToIdx")(70552 call -(70550 call chpl__idxToInt(70546 call . r c"alignment")) i))(70557 call . r c"aligned"))))
  }
  function chpl_check_step_integral[70569](arg step[70567]:_any[178](?)) : _unknown[51] "inline"
  {
    if(70604 call _cond_test(70576 call !(70575 call isIntegral(70573 'typeof' step))))
    {
      { scopeless
        (70602 call compilerError "can't apply 'by' using step of a non-integral type "(70600 call _cast string[26](70598 'typeof' step)))
      }
    }
  }
  function chpl_need_to_check_step[70616](arg step[70614]:_any[178](?), arg strType[70618]:_any[178](?)) param : _unknown[51]
  {
    (70626 call compilerAssert(70624 call isInt strType))
    (70647 return(70645 call &&(70632 call !=(70630 'typeof' step) strType)(70643 call >=(70638 call numBits(70636 'typeof' step))(70642 call numBits strType))))
  }
  function chpl_range_check_stride[70655](arg step[70653]:_any[178](?), arg idxType[70657]:_any[178](?)) : _unknown[51] "inline"
  {
    (70662 call chpl_check_step_integral step)
    unknown strType[70669] "type variable"(70668 call chpl__rangeStrideType idxType)
    if(70730 call _cond_test(70681 call >(70676 call numBits(70674 'typeof' step))(70680 call numBits strType)))
    {
      { scopeless
        (70728 call compilerError "can't apply 'by' to a range with idxType "(70704 call _cast string[26] idxType) " using a step of type "(70726 call _cast string[26](70724 'typeof' step)))
      }
    }
    if(70825 call _cond_test boundsChecking)
    {
      if(70764 call _cond_test(70738 call == step 0))
      {
        { scopeless
          (70762 call(70741 call . HaltWrappers c"boundsCheckHalt") "the step argument of the 'by' operator is zero")
        }
      }
      if(70820 call _cond_test(70786 call &&(70774 call chpl_need_to_check_step step strType)(70784 call > step(70782 call _cast(70781 'typeof' step)(70779 call max strType)))))
      {
        { scopeless
          (70818 call(70789 call . HaltWrappers c"boundsCheckHalt")(70815 call + "the step argument of the 'by' operator is too large and cannot be represented within the range's stride type "(70813 call _cast string[26] strType)))
        }
      }
    }
  }
  function chpl_range_check_stride[70835](param arg step[70833]:_any[178](?), arg idxType[70837]:_any[178](?)) : _unknown[51] "inline"
  {
    (70842 call chpl_check_step_integral step)
    unknown strType[70849] "type variable"(70848 call chpl__rangeStrideType idxType)
    if(70861 call _cond_test(70854 call == step 0))
    {
      { scopeless
        (70859 call compilerError "the step argument of the 'by' operator is zero")
      }
    }
    if(70895 call _cond_test(70882 call &&(70870 call chpl_need_to_check_step step strType)(70880 call > step(70878 call _cast(70877 'typeof' step)(70875 call max strType)))))
    {
      { scopeless
        (70893 call compilerError(70890 call + "the step argument of the 'by' operator is too large and cannot be represented within the range's stride type "(70888 call _cast string[26] strType)))
      }
    }
  }
  function chpl_by_help[70916](arg r[70913] :
  (70912 call range unknown i[70905] unknown b[70908] unknown s[70910]), arg step[70918]:_any[178](?)) : _unknown[51]
  {
    { scopeless
      const lw[70925] "const"(70922 call . r c"low") i
      const hh[70933] "const"(70930 call . r c"high") i
      const st[70955] "const"(70953 call *(70943 call . r c"stride")(70951 call _cast(70948 call . r c"strType") step))(70939 call . r c"strType")
      (70958 'end of statement')
    }
    { scopeless
      const tmp[71080] "const" "temp"(71077 IfExpr (70975 call(70971 call . r c"isAmbiguous")) then
      { scopeless(70999 IfExpr (70977 call . r c"stridable") then
        { scopeless
          (70986 call _build_tuple 0(70982 call . r c"alignment"))
        } else
        { scopeless
          (70997 call _build_tuple 0(70995 call(70990 call . r c"chpl_intToIdx") 0))
        } )
      } else
      { scopeless(71074 IfExpr (71012 call &&(71007 call(71003 call . r c"hasLowBound"))(71010 call > st 0)) then
        { scopeless
          (71020 call _build_tuple 1(71016 call . r c"alignedLow"))
        } else
        { scopeless(71071 IfExpr (71032 call &&(71027 call(71023 call . r c"hasHighBound"))(71030 call < st 0)) then
          { scopeless
            (71040 call _build_tuple 1(71036 call . r c"alignedHigh"))
          } else
          { scopeless(71068 IfExpr (71043 call . r c"stridable") then
            { scopeless
              (71055 call _build_tuple(71047 call . r c"aligned")(71051 call . r c"alignment"))
            } else
            { scopeless
              (71066 call _build_tuple 0(71064 call(71059 call . r c"chpl_intToIdx") 0))
            } )
          } )
        } )
      } )(70968 call _build_tuple bool[10] i)
      (71087 call _check_tuple_var_decl tmp[71080] 2)
      const ald[70960] "const"(71081 call tmp[71080] 0)
      const alt[70962] "const"(71084 call tmp[71080] 1)
      (71092 'end of statement')
    }
    (71105 return(71093 'new'(71104 call range i b 1 lw hh st alt ald)))
  }
  function chpl_by[71113](arg r[71111]:_any[178](?), arg step[71115]:_any[178](?)) : _unknown[51] "inline" "no doc"
  {
    if(71144 call _cond_test(71121 call !(71120 call isRange r)))
    {
      { scopeless
        (71142 call compilerError "the first argument of the 'by' operator is not a range")
      }
    }
    (71157 call chpl_range_check_stride step(71154 call . r c"idxType"))
    (71164 return(71163 call chpl_by_help r step))
  }
  function chpl_by[71177](arg r[71174] :
  (71173 call range ?[260]), param arg step[71179]:_any[178](?)) : _unknown[51] "inline" "no doc"
  {
    (71188 call chpl_range_check_stride step(71185 call . r c"idxType"))
    (71202 return(71201 call chpl_by_help r(71199 call _cast(71196 call . r c"strType") step)))
  }
  function chpl_align[71220](arg r[71217] :
  (71216 call range unknown i[71209] unknown b[71212] unknown s[71214]), arg algn[71223] :
  i) : _unknown[51] "inline" "no doc"
  {
    (71259 return(71226 'new'(71258 call range i b 1(71241 call(71233 call . r c"chpl_intToIdx")(71237 call . r c"_low"))(71251 call(71243 call . r c"chpl_intToIdx")(71247 call . r c"_high"))(71253 call . r c"stride") algn 1)))
  }
  function chpl_align[71278](arg r[71275] :
  (71274 call range unknown i[71267] unknown b[71270] unknown s[71272]), arg algn[71280]:_any[178](?)) : _unknown[51] "inline" "no doc"
  {
    (71327 call compilerError "can't align a range with idxType "(71303 call _cast string[26] i) " using a value of type "(71325 call _cast string[26](71323 'typeof' algn)))
    (71331 return r)
  }
  function _unknown[51].offset[71342](arg _mt[71347]:_MT[238], arg this[71344] :
  range, in arg offset[71339] :
  integral) : _unknown[51] "method"
  {
    { scopeless
      unknown offs[71356](71355 call(71350 call . offset c"safeCast") intIdxType)
      (71359 'end of statement')
    }
    if(71391 call _cond_test(71362 call ! stridable))
    {
      (71383 call compilerWarning "invoking 'offset' on an unstrided range has no effect.")
      (71388 call = offs 0)
    }
    if(71427 call _cond_test(71401 call && boundsChecking(71399 call !(71398 call hasFirst))))
    {
      { scopeless
        (71425 call(71404 call . HaltWrappers c"boundsCheckHalt") "invoking 'offset' on a range without the first index")
      }
    }
    (71453 return(71432 'new'(71452 call range idxType boundedType stridable low high stride(71450 call chpl_intToIdx(71447 call +(71443 call . this c"firstAsInt") offs)) 1)))
  }
  function _unknown[51].this[71467](arg _mt[71472]:_MT[238], const arg this[71469] :
  range, arg other[71464] :
  (71463 call range ?[260])) : _unknown[51] "method" "no doc"
  {
    { scopeless
      unknown ambig[71475] 0
      (71478 'end of statement')
    }
    if(71583 call _cond_test(71492 call ||(71485 call(71481 call . this c"isAmbiguous"))(71491 call(71487 call . other c"isAmbiguous"))))
    {
      { scopeless
        unknown st1[71501](71500 call abs(71496 call . this c"stride"))
        (71504 'end of statement')
      }
      { scopeless
        unknown st2[71513](71512 call abs(71508 call . other c"stride"))
        (71516 'end of statement')
      }
      { scopeless
        unknown tmp[71527] "temp"(71526 call chpl__extendedEuclid st1 st2)
        (71534 call _check_tuple_var_decl tmp[71527] 2)
        unknown g[71517](71528 call tmp[71527] 0)
        unknown x[71519](71531 call tmp[71527] 1)
        (71539 'end of statement')
      }
      if(71573 call _cond_test(71545 call && boundsChecking(71543 call > g 1)))
      {
        { scopeless
          (71571 call(71548 call . HaltWrappers c"boundsCheckHalt") "Cannot slice ranges with ambiguous alignments unless their strides are relatively prime.")
        }
      }
      (71580 call = ambig 1)
    }
    function computeBoundedType[71591](arg r1[71589]:_any[178](?), arg r2[71593]:_any[178](?)) param : _unknown[51]
    {
      { scopeless
        unknown low[71609] "param"(71607 call ||(71600 call(71596 call . r1 c"hasLowBound"))(71606 call(71602 call . r2 c"hasLowBound")))
        (71612 'end of statement')
      }
      { scopeless
        unknown high[71628] "param"(71626 call ||(71619 call(71615 call . r1 c"hasHighBound"))(71625 call(71621 call . r2 c"hasHighBound")))
        (71631 'end of statement')
      }
      if(71674 call _cond_test(71634 call && low high))
      {
        { scopeless
          (71640 return(71637 call . BoundedRangeType c"bounded"))
        }
      }
      {
        { scopeless
          if(71668 call _cond_test low)
          {
            { scopeless
              (71647 return(71644 call . BoundedRangeType c"boundedLow"))
            }
          }
          {
            { scopeless
              if(71662 call _cond_test high)
              {
                { scopeless
                  (71654 return(71651 call . BoundedRangeType c"boundedHigh"))
                }
              }
              {
                { scopeless
                  (71660 return(71657 call . BoundedRangeType c"boundedNone"))
                }
              }
            }
          }
        }
      }
    }
    { scopeless
      unknown lo1[71696](71693 IfExpr (71684 call hasLowBound) then
      { scopeless
        (71686 call . this c"_low")
      } else
      { scopeless
        (71690 call . other c"_low")
      } )
      (71699 'end of statement')
    }
    { scopeless
      unknown hi1[71714](71711 IfExpr (71702 call hasHighBound) then
      { scopeless
        (71704 call . this c"_high")
      } else
      { scopeless
        (71708 call . other c"_high")
      } )
      (71717 'end of statement')
    }
    { scopeless
      unknown st1[71725](71724 call abs(71720 call . this c"stride"))
      (71728 'end of statement')
    }
    { scopeless
      unknown lo2[71746](71743 IfExpr (71734 call(71730 call . other c"hasLowBound")) then
      { scopeless
        (71736 call . other c"_low")
      } else
      { scopeless
        (71740 call . this c"_low")
      } )
      (71749 'end of statement')
    }
    { scopeless
      unknown hi2[71767](71764 IfExpr (71755 call(71751 call . other c"hasHighBound")) then
      { scopeless
        (71757 call . other c"_high")
      } else
      { scopeless
        (71761 call . this c"_high")
      } )
      (71770 'end of statement')
    }
    { scopeless
      unknown st2[71778](71777 call abs(71773 call . other c"stride"))
      (71781 'end of statement')
    }
    if(71801 call _cond_test(71785 call isUintType intIdxType))
    {
      if(71795 call _cond_test(71788 call < lo1 0))
      {
        { scopeless
          (71792 call = lo1 0)
        }
      }
    }
    { scopeless
      unknown newStride[71810](71807 call . this c"stride") strType
      (71813 'end of statement')
    }
    { scopeless
      unknown lcm[71822](71821 call abs(71817 call . this c"stride")) strType
      (71825 'end of statement')
    }
    { scopeless
      unknown tmp[71843] "temp"(71841 call _build_tuple lcm(71838 call _cast strType 0))(71833 call * 2 strType)
      (71850 call _check_tuple_var_decl tmp[71843] 2)
      unknown g[71826](71844 call tmp[71843] 0)
      unknown x[71828](71847 call tmp[71843] 1)
      (71855 'end of statement')
    }
    if(71958 call _cond_test(71878 call &&(71864 call !=(71857 call . this c"stride")(71861 call . other c"stride"))(71876 call !=(71867 call . this c"stride")(71874 call -(71871 call . other c"stride")))))
    {
      { scopeless
        const tmp[71890] "const" "temp"(71889 call chpl__extendedEuclid st1 st2)
        (71897 call _check_tuple_var_decl tmp[71890] 2)
        const tg[71880] "const"(71891 call tmp[71890] 0)
        const tx[71882] "const"(71894 call tmp[71890] 1)
        (71902 'end of statement')
      }
      (71926 call =(71907 call _build_tuple g x)(71924 call _build_tuple(71915 call(71910 call . tg c"safeCast") strType)(71922 call(71917 call . tx c"safeCast") strType)))
      (71937 call = lcm(71935 call *(71932 call / st1 g) st2))
      (71955 call = newStride(71952 IfExpr (71946 call >(71942 call . this c"stride") 0) then
      { scopeless
        lcm
      } else
      { scopeless
        (71950 call - lcm)
      } ))
    }
    { scopeless
      unknown emptyIntersection[71963] bool[10]
      (71966 'end of statement')
    }
    function min[71973](arg x[71970] :
    int[13], arg y[71976] :
    uint[115]) : _unknown[51]
    {
      if(71990 call _cond_test(71984 call > y(71983 call max int[13])))
      {
        (71987 return x)
      }
      (72003 return(72002 call min x(72000 call _cast int[13] y)))
    }
    function min[72013](arg x[72010] :
    uint[115], arg y[72016] :
    int[13]) : _unknown[51]
    {
      if(72032 call _cond_test(72021 call < y 0))
      {
        (72025 call = emptyIntersection 1)
        (72030 return x)
      }
      (72045 return(72044 call min x(72042 call _cast uint[115] y)))
    }
    function max[72055](arg x[72052] :
    int[13], arg y[72058] :
    uint[115]) : _unknown[51]
    {
      if(72077 call _cond_test(72066 call > y(72065 call max int[13])))
      {
        (72070 call = emptyIntersection 1)
        (72075 return x)
      }
      (72090 return(72089 call max x(72087 call _cast int[13] y)))
    }
    function max[72100](arg x[72097] :
    uint[115], arg y[72103] :
    int[13]) : _unknown[51]
    {
      if(72114 call _cond_test(72108 call < y 0))
      {
        (72111 return x)
      }
      (72127 return(72126 call max x(72124 call _cast uint[115] y)))
    }
    (72133 call = emptyIntersection 0)
    { scopeless
      unknown newlo[72144](72142 call _cast intIdxType(72140 call max lo1 lo2))
      (72147 'end of statement')
    }
    { scopeless
      unknown newhi[72156](72154 call _cast intIdxType(72152 call min hi1 hi2))
      (72159 'end of statement')
    }
    if(72172 call _cond_test emptyIntersection)
    {
      (72163 call = newlo 1)
      (72169 call = newhi 0)
    }
    { scopeless
      unknown result[72224](72176 'new'(72223 call range idxType(72184 call computeBoundedType this other)(72193 call |(72186 call . this c"stridable")(72190 call . other c"stridable"))(72198 call chpl_intToIdx newlo)(72202 call chpl_intToIdx newhi) newStride(72207 call chpl_intToIdx 0)(72221 call &&(72209 call ! ambig)(72219 call ||(72212 call . this c"aligned")(72216 call . other c"aligned")))))
      (72227 'end of statement')
    }
    if(72433 call _cond_test(72229 call . result c"stridable"))
    {
      { scopeless
        unknown al1[72248](72246 call _cast int[13](72243 call %(72238 call chpl__idxToInt(72234 call . this c"alignment"))(72241 call _cast intIdxType st1)))
        (72251 'end of statement')
      }
      { scopeless
        unknown al2[72272](72270 call _cast int[13](72267 call %(72259 call chpl__idxToInt(72255 call . other c"alignment"))(72265 call _cast(72262 call . other c"intIdxType") st2)))
        (72275 'end of statement')
      }
      if(72429 call _cond_test(72284 call !=(72281 call %(72278 call - al2 al1) g) 0))
      {
        if(72321 call _cond_test(72293 call && boundsChecking(72291 call !(72290 call isBoundedRange result))))
        {
          { scopeless
            (72319 call(72296 call . HaltWrappers c"boundsCheckHalt") "could not represent range slice - it needs to be empty, but the slice type is not bounded")
          }
        }
        (72335 call =(72328 call . result c"_low")(72333 call _cast intIdxType 1))
        (72346 call =(72339 call . result c"_high")(72344 call _cast intIdxType 0))
        (72371 call =(72350 call . result c"_alignment")(72368 IfExpr (72358 call >(72354 call . this c"stride") 0) then
        { scopeless
          (72362 call _cast intIdxType 1)
        } else
        { scopeless
          (72366 call _cast intIdxType 0)
        } ))
      }
      {
        { scopeless
          unknown offset[72381](72379 call *(72376 call - al2 al1) x)
          (72384 'end of statement')
        }
        if(72395 call _cond_test(72388 call < offset 0))
        {
          { scopeless
            (72392 call += offset lcm)
          }
        }
        (72426 call =(72401 call . result c"_alignment")(72424 call +(72406 call _cast intIdxType al1)(72422 call /(72416 call *(72410 call _cast intIdxType offset)(72414 call _cast intIdxType st1))(72420 call _cast intIdxType g))))
      }
    }
    (72438 return result)
  }
  function chpl_count_help[72451](arg r[72448] :
  (72447 call range ?[260]), arg i[72453]:_any[178](?)) : _unknown[51]
  {
    (72486 call compilerError "count operator is not defined for unbounded ranges")
  }
  where {
    (72463 call ==(72456 call . r c"boundedType")(72460 call . BoundedRangeType c"boundedNone"))
  }
  function chpl_count_help[72496](arg r[72494]:_any[178](?), arg count[72499] :
  integral) : _unknown[51]
  {
    if(72534 call _cond_test(72509 call && boundsChecking(72508 call(72504 call . r c"isAmbiguous"))))
    {
      { scopeless
        (72532 call boundsCheckHalt "count -- Cannot count off elements from a range which is ambiguously aligned.")
      }
    }
    unknown resultType[72544] "type variable"(72541 call . r c"intIdxType")
    unknown strType[72551] "type variable"(72550 call chpl__rangeStrideType resultType)
    function absSameType[72558](arg str[72556]:_any[178](?)) : _unknown[51]
    {
      if(72589 call _cond_test(72565 call <(72561 call . r c"stride") 0))
      {
        (72576 return(72574 call _cast resultType(72571 call -(72568 call . r c"stride"))))
      }
      {
        (72586 return(72584 call _cast resultType(72580 call . r c"stride")))
      }
    }
    if(72798 call _cond_test(72598 call == count 0))
    {
      if(72792 call _cond_test(72605 call(72601 call . r c"hasLowBound")))
      {
        (72680 return(72606 'new'(72679 call range(idxType =(72609 call . r c"idxType"))(boundedType =(72615 call . BoundedRangeType c"bounded"))(stridable =(72620 call . r c"stridable"))(_low =(72634 call chpl__intToIdx(72626 call . r c"idxType")(72631 call . r c"_low")))(_high =(72655 call chpl__intToIdx(72638 call . r c"idxType")(72653 call -(72643 call . r c"_low")(72652 call absSameType(72648 call . r c"stride")))))(_stride =(72658 call . r c"stride"))(_alignment =(72672 call chpl__intToIdx(72664 call . r c"idxType")(72669 call . r c"_alignment")))(_aligned =(72675 call . r c"aligned")))))
      }
      {
        { scopeless
          if(72788 call _cond_test(72688 call(72684 call . r c"hasHighBound")))
          {
            (72763 return(72689 'new'(72762 call range(idxType =(72692 call . r c"idxType"))(boundedType =(72698 call . BoundedRangeType c"bounded"))(stridable =(72703 call . r c"stridable"))(_low =(72726 call chpl__intToIdx(72709 call . r c"idxType")(72724 call +(72714 call . r c"_high")(72723 call absSameType(72719 call . r c"stride")))))(_high =(72738 call chpl__intToIdx(72730 call . r c"idxType")(72735 call . r c"_high")))(_stride =(72741 call . r c"stride"))(_alignment =(72755 call chpl__intToIdx(72747 call . r c"idxType")(72752 call . r c"_alignment")))(_aligned =(72758 call . r c"aligned")))))
          }
          {
            (72785 call halt "Internal error: Unexpected case in chpl_count_help")
          }
        }
      }
    }
    if(72840 call _cond_test(72817 call &&(72811 call && boundsChecking(72809 call !(72808 call(72804 call . r c"hasFirst"))))(72815 call > count 0)))
    {
      { scopeless
        (72838 call boundsCheckHalt "With a positive count, the range must have a first index.")
      }
    }
    if(72885 call _cond_test(72862 call &&(72856 call && boundsChecking(72854 call !(72853 call(72849 call . r c"hasLast"))))(72860 call < count 0)))
    {
      { scopeless
        (72883 call boundsCheckHalt "With a negative count, the range must have a last index.")
      }
    }
    if(72984 call _cond_test(72932 call &&(72901 call && boundsChecking(72899 call ==(72892 call . r c"boundedType")(72896 call . BoundedRangeType c"bounded")))(72930 call >(72918 call _cast(72917 call uint[115] 64)(72913 call abs(72910 call _cast(72909 call chpl__maxIntTypeSameSign(72907 'typeof' count)) count)))(72928 call _cast(72927 call uint[115] 64)(72921 call . r c"size")))))
    {
      (72981 call boundsCheckHalt(72978 call +(72959 call + "bounded range is too small to access "(72957 call _cast string[26](72955 call abs count))) " elements"))
    }
    function chpl__computeTypeForCountMath[72992](arg t1[72990]:_any[178](?), arg t2[72994]:_any[178](?)) type : _unknown[51]
    {
      if(73052 call _cond_test(72998 call == t1 t2))
      {
        (73004 return(73003 call chpl__idxTypeToIntIdxType t1))
      }
      {
        { scopeless
          if(73048 call _cond_test(73021 call ||(73012 call ==(73010 call numBits t1) 64)(73019 call ==(73017 call numBits t2) 64)))
          {
            (73027 return(73026 call int[13] 64))
          }
          {
            { scopeless
              unknown x1[73031] t1
              (73034 'end of statement')
            }
            { scopeless
              unknown x2[73037] t2
              (73040 'end of statement')
            }
            (73046 return(73045 'typeof'(73043 call + x1 x2)))
          }
        }
      }
    }
    unknown computeType[73066] "type variable"(73065 call chpl__computeTypeForCountMath resultType(73064 'typeof' count))
    unknown signedComputeType[73073] "type variable"(73072 call chpl__signedType computeType)
    { scopeless
      unknown diff[73089](73087 call *(73078 call _cast signedComputeType count)(73085 call _cast signedComputeType(73081 call . r c"stride")))
      (73092 'end of statement')
    }
    { scopeless
      unknown lo[73123](73120 IfExpr (73096 call > diff 0) then
      { scopeless
        (73099 call . r c"_low")
      } else
      { scopeless
        (73119 call chpl__add(73108 call _cast computeType(73104 call . r c"_high"))(73116 call _cast computeType(73113 call + diff 1)) resultType)
      } ) resultType
      (73126 'end of statement')
    }
    { scopeless
      unknown hi[73157](73154 IfExpr (73130 call < diff 0) then
      { scopeless
        (73133 call . r c"_high")
      } else
      { scopeless
        (73153 call chpl__add(73142 call _cast computeType(73138 call . r c"_low"))(73150 call -(73147 call _cast computeType diff) 1) resultType)
      } ) resultType
      (73160 'end of statement')
    }
    if(73222 call _cond_test(73162 call . r c"stridable"))
    {
      if(73188 call _cond_test(73178 call &&(73170 call(73166 call . r c"hasLowBound"))(73176 call < lo(73173 call . r c"_low"))))
      {
        { scopeless
          (73185 call = lo(73182 call . r c"_low"))
        }
      }
      if(73217 call _cond_test(73207 call &&(73199 call(73195 call . r c"hasHighBound"))(73205 call > hi(73202 call . r c"_high"))))
      {
        { scopeless
          (73214 call = hi(73211 call . r c"_high"))
        }
      }
    }
    (73303 return(73226 'new'(73302 call range(idxType =(73229 call . r c"idxType"))(boundedType =(73235 call . BoundedRangeType c"bounded"))(stridable =(73240 call . r c"stridable"))(_low =(73250 call(73245 call . r c"chpl_intToIdx") lo))(_high =(73258 call(73253 call . r c"chpl_intToIdx") hi))(_stride =(73272 IfExpr (73261 call . r c"stridable") then
    { scopeless
      (73269 call _cast strType(73265 call . r c"stride"))
    } else
    { scopeless
      none[57]
    } ))(_alignment =(73285 IfExpr (73277 call . r c"stridable") then
    { scopeless
      (73281 call . r c"alignment")
    } else
    { scopeless
      none[57]
    } ))(_aligned =(73298 IfExpr (73290 call . r c"stridable") then
    { scopeless
      (73294 call . r c"aligned")
    } else
    { scopeless
      none[57]
    } )))))
  }
  function #[73317](arg r[73314] :
  (73313 call range unknown i[73310]), arg count[73323] :
  (73322 call chpl__rangeStrideType i)) : _unknown[51]
  {
    (73331 return(73330 call chpl_count_help r count))
  }
  function #[73346](arg r[73343] :
  (73342 call range unknown i[73339]), arg count[73352] :
  (73351 call chpl__rangeUnsignedType i)) : _unknown[51]
  {
    (73360 return(73359 call chpl_count_help r count))
  }
  function #[73375](arg r[73372] :
  (73371 call range unknown i[73368]), arg count[73377]:_any[178](?)) : _unknown[51]
  {
    (73424 call compilerError "can't apply '#' to a range with idxType "(73400 call _cast string[26] i) " using a count of type "(73422 call _cast string[26](73420 'typeof' count)))
    (73428 return r)
  }
  function chpl_checkIfRangeIterWillOverflow[73436](arg idxType[73434]:_any[178](?), arg low[73438]:_any[178](?), arg high[73440]:_any[178](?), arg stride[73442]:_any[178](?), arg first[73445] =
  low, arg last[73449] =
  high, arg shouldHalt[73453] =
  1) : _unknown[51]
  {
    if(73464 call _cond_test(73458 call > low high))
    {
      (73461 return 0)
    }
    { scopeless
      unknown willOverFlow[73470] 0
      (73473 'end of statement')
    }
    if(73657 call _cond_test(73477 call isIntType idxType))
    {
      if(73544 call _cond_test(73486 call &&(73480 call > last 0)(73484 call > stride 0)))
      {
        if(73504 call _cond_test(73496 call > stride(73494 call -(73492 call max idxType) last)))
        {
          (73500 call = willOverFlow 1)
        }
      }
      {
        { scopeless
          if(73540 call _cond_test(73517 call &&(73511 call < last 0)(73515 call < stride 0)))
          {
            if(73535 call _cond_test(73527 call < stride(73525 call -(73523 call min idxType) last)))
            {
              (73531 call = willOverFlow 1)
            }
          }
        }
      }
    }
    {
      { scopeless
        if(73653 call _cond_test(73553 call isUintType idxType))
        {
          if(73608 call _cond_test(73556 call > stride 0))
          {
            if(73574 call _cond_test(73566 call <(73563 call + last(73561 call _cast idxType stride)) last))
            {
              (73570 call = willOverFlow 1)
            }
          }
          {
            { scopeless
              if(73604 call _cond_test(73581 call < stride 0))
              {
                if(73599 call _cond_test(73591 call >(73588 call + last(73586 call _cast idxType stride)) last))
                {
                  (73595 call = willOverFlow 1)
                }
              }
            }
          }
        }
        {
          (73650 call compilerError "Iterator overflow checking is only supported " "for integral types")
        }
      }
    }
    if(73691 call _cond_test(73664 call && willOverFlow shouldHalt))
    {
      (73688 call(73667 call . HaltWrappers c"boundsCheckHalt") "Iteration over a bounded range may be incorrect due to overflow.")
    }
    (73696 return willOverFlow)
  }
  function _unknown[51].checkIfIterWillOverflow[73707](arg _mt[73712]:_MT[238], arg this[73709] :
  range, arg shouldHalt[73704] =
  1) : _unknown[51] "method" "no doc"
  {
    (73742 return(73741 call chpl_checkIfRangeIterWillOverflow(73716 call . this c"intIdxType")(73721 call . this c"_low")(73725 call . this c"_high")(73729 call . this c"stride")(73733 call . this c"firstAsInt")(73737 call . this c"lastAsInt") shouldHalt))
  }
  function chpl_direct_range_iter[73757](arg low[73754] :
  (73753 call int[13] unknown w[73750]), arg high[73763] :
  (73762 call int[13] w), arg stride[73770] :
  (73769 call int[13] w)) : _unknown[51] "iterator fn"
  {
    { scopeless
      const r[73780] "const"(73778 call chpl_by(73775 call chpl_build_bounded_range low high) stride)
      (73783 'end of statement')
    }
    {
      unknown _indexOfInterest[73790] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[73791] "expr temp" "temp"
      (73800 'move' _iterator[73791](73798 call _getIterator r))
      Defer
      {
        {
          (73816 call _freeIterator _iterator[73791])
        }
      }
      { scopeless type
        (73805 'move' _indexOfInterest[73790](73802 call iteratorIndex _iterator[73791]))
      }
      ForLoop[73792]
      {
        unknown i[73809] "index var" "insert auto destroy"
        (73811 'move' i[73809] _indexOfInterest[73790])
        { scopeless
          (73788 yield i)
        }
        label _continueLabel[73795]
        _indexOfInterest[73790]
        _iterator[73791]
      }
      label _breakLabel[73796]
    }
  }
  function chpl_direct_range_iter[73835](arg low[73832] :
  (73831 call uint[115] unknown w[73828]), arg high[73841] :
  (73840 call uint[115] w), arg stride[73848] :
  (73847 call int[13] w)) : _unknown[51] "iterator fn"
  {
    { scopeless
      const r[73858] "const"(73856 call chpl_by(73853 call chpl_build_bounded_range low high) stride)
      (73861 'end of statement')
    }
    {
      unknown _indexOfInterest[73868] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[73869] "expr temp" "temp"
      (73878 'move' _iterator[73869](73876 call _getIterator r))
      Defer
      {
        {
          (73894 call _freeIterator _iterator[73869])
        }
      }
      { scopeless type
        (73883 'move' _indexOfInterest[73868](73880 call iteratorIndex _iterator[73869]))
      }
      ForLoop[73870]
      {
        unknown i[73887] "index var" "insert auto destroy"
        (73889 'move' i[73887] _indexOfInterest[73868])
        { scopeless
          (73866 yield i)
        }
        label _continueLabel[73873]
        _indexOfInterest[73868]
        _iterator[73869]
      }
      label _breakLabel[73874]
    }
  }
  function chpl_direct_range_iter[73909](arg low[73906] :
  enum[187](?), arg high[73912] :
  enum[187](?), arg stride[73916] :
  integral) : _unknown[51] "iterator fn"
  {
    { scopeless
      const r[73926] "const"(73924 call chpl_by(73921 call chpl_build_bounded_range low high) stride)
      (73929 'end of statement')
    }
    {
      unknown _indexOfInterest[73936] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[73937] "expr temp" "temp"
      (73946 'move' _iterator[73937](73944 call _getIterator r))
      Defer
      {
        {
          (73962 call _freeIterator _iterator[73937])
        }
      }
      { scopeless type
        (73951 'move' _indexOfInterest[73936](73948 call iteratorIndex _iterator[73937]))
      }
      ForLoop[73938]
      {
        unknown i[73955] "index var" "insert auto destroy"
        (73957 'move' i[73955] _indexOfInterest[73936])
        { scopeless
          (73934 yield i)
        }
        label _continueLabel[73941]
        _indexOfInterest[73936]
        _iterator[73937]
      }
      label _breakLabel[73942]
    }
  }
  function chpl_direct_range_iter[73977](arg low[73974] :
  bool[10], arg high[73980] :
  bool[10], arg stride[73984] :
  integral) : _unknown[51] "iterator fn"
  {
    { scopeless
      const r[73994] "const"(73992 call chpl_by(73989 call chpl_build_bounded_range low high) stride)
      (73997 'end of statement')
    }
    {
      unknown _indexOfInterest[74004] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74005] "expr temp" "temp"
      (74014 'move' _iterator[74005](74012 call _getIterator r))
      Defer
      {
        {
          (74030 call _freeIterator _iterator[74005])
        }
      }
      { scopeless type
        (74019 'move' _indexOfInterest[74004](74016 call iteratorIndex _iterator[74005]))
      }
      ForLoop[74006]
      {
        unknown i[74023] "index var" "insert auto destroy"
        (74025 'move' i[74023] _indexOfInterest[74004])
        { scopeless
          (74002 yield i)
        }
        label _continueLabel[74009]
        _indexOfInterest[74004]
        _iterator[74005]
      }
      label _breakLabel[74010]
    }
  }
  function chpl_direct_range_iter[74049](arg low[74046] :
  (74045 call int[13] unknown w[74042]), arg high[74055] :
  (74054 call int[13] w), param arg stride[74062] :
  (74061 call int[13] w)) : _unknown[51] "iterator fn"
  {
    {
      unknown _indexOfInterest[74075] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74076] "expr temp" "temp"
      (74085 'move' _iterator[74076](74083 call _getIterator(74071 call chpl_direct_param_stride_range_iter low high stride)))
      Defer
      {
        {
          (74102 call _freeIterator _iterator[74076])
        }
      }
      { scopeless type
        (74091 'move' _indexOfInterest[74075](74088 call iteratorIndex _iterator[74076]))
      }
      ForLoop[74077]
      {
        unknown i[74095] "index var" "insert auto destroy"
        (74097 'move' i[74095] _indexOfInterest[74075])
        { scopeless
          (74073 yield i)
        }
        label _continueLabel[74080]
        _indexOfInterest[74075]
        _iterator[74076]
      }
      label _breakLabel[74081]
    }
  }
  function chpl_direct_range_iter[74122](arg low[74119] :
  (74118 call uint[115] unknown w[74115]), arg high[74128] :
  (74127 call uint[115] w), param arg stride[74135] :
  (74134 call int[13] w)) : _unknown[51] "iterator fn"
  {
    {
      unknown _indexOfInterest[74148] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74149] "expr temp" "temp"
      (74158 'move' _iterator[74149](74156 call _getIterator(74144 call chpl_direct_param_stride_range_iter low high stride)))
      Defer
      {
        {
          (74175 call _freeIterator _iterator[74149])
        }
      }
      { scopeless type
        (74164 'move' _indexOfInterest[74148](74161 call iteratorIndex _iterator[74149]))
      }
      ForLoop[74150]
      {
        unknown i[74168] "index var" "insert auto destroy"
        (74170 'move' i[74168] _indexOfInterest[74148])
        { scopeless
          (74146 yield i)
        }
        label _continueLabel[74153]
        _indexOfInterest[74148]
        _iterator[74149]
      }
      label _breakLabel[74154]
    }
  }
  function chpl_direct_range_iter[74191](arg low[74188] :
  enum[187](?), arg high[74194] :
  enum[187](?), param arg stride[74198] :
  integral) : _unknown[51] "iterator fn"
  {
    if(74302 call _cond_test(74203 call == stride 1))
    {
      { scopeless
        const r[74209] "const"(74207 call chpl_build_bounded_range low high)
        (74212 'end of statement')
      }
      {
        unknown _indexOfInterest[74219] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[74220] "expr temp" "temp"
        (74229 'move' _iterator[74220](74227 call _getIterator r))
        Defer
        {
          {
            (74245 call _freeIterator _iterator[74220])
          }
        }
        { scopeless type
          (74234 'move' _indexOfInterest[74219](74231 call iteratorIndex _iterator[74220]))
        }
        ForLoop[74221]
        {
          unknown i[74238] "index var" "insert auto destroy"
          (74240 'move' i[74238] _indexOfInterest[74219])
          { scopeless
            (74217 yield i)
          }
          label _continueLabel[74224]
          _indexOfInterest[74219]
          _iterator[74220]
        }
        label _breakLabel[74225]
      }
    }
    {
      { scopeless
        const r[74259] "const"(74257 call chpl_by(74254 call chpl_build_bounded_range low high) stride)
        (74262 'end of statement')
      }
      {
        unknown _indexOfInterest[74269] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[74270] "expr temp" "temp"
        (74279 'move' _iterator[74270](74277 call _getIterator r))
        Defer
        {
          {
            (74295 call _freeIterator _iterator[74270])
          }
        }
        { scopeless type
          (74284 'move' _indexOfInterest[74269](74281 call iteratorIndex _iterator[74270]))
        }
        ForLoop[74271]
        {
          unknown i[74288] "index var" "insert auto destroy"
          (74290 'move' i[74288] _indexOfInterest[74269])
          { scopeless
            (74267 yield i)
          }
          label _continueLabel[74274]
          _indexOfInterest[74269]
          _iterator[74270]
        }
        label _breakLabel[74275]
      }
    }
  }
  function chpl_direct_range_iter[74315](arg low[74312] :
  bool[10], arg high[74318] :
  bool[10], param arg stride[74322] :
  integral) : _unknown[51] "iterator fn"
  {
    if(74426 call _cond_test(74327 call == stride 1))
    {
      { scopeless
        const r[74333] "const"(74331 call chpl_build_bounded_range low high)
        (74336 'end of statement')
      }
      {
        unknown _indexOfInterest[74343] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[74344] "expr temp" "temp"
        (74353 'move' _iterator[74344](74351 call _getIterator r))
        Defer
        {
          {
            (74369 call _freeIterator _iterator[74344])
          }
        }
        { scopeless type
          (74358 'move' _indexOfInterest[74343](74355 call iteratorIndex _iterator[74344]))
        }
        ForLoop[74345]
        {
          unknown i[74362] "index var" "insert auto destroy"
          (74364 'move' i[74362] _indexOfInterest[74343])
          { scopeless
            (74341 yield i)
          }
          label _continueLabel[74348]
          _indexOfInterest[74343]
          _iterator[74344]
        }
        label _breakLabel[74349]
      }
    }
    {
      { scopeless
        const r[74383] "const"(74381 call chpl_by(74378 call chpl_build_bounded_range low high) stride)
        (74386 'end of statement')
      }
      {
        unknown _indexOfInterest[74393] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[74394] "expr temp" "temp"
        (74403 'move' _iterator[74394](74401 call _getIterator r))
        Defer
        {
          {
            (74419 call _freeIterator _iterator[74394])
          }
        }
        { scopeless type
          (74408 'move' _indexOfInterest[74393](74405 call iteratorIndex _iterator[74394]))
        }
        ForLoop[74395]
        {
          unknown i[74412] "index var" "insert auto destroy"
          (74414 'move' i[74412] _indexOfInterest[74393])
          { scopeless
            (74391 yield i)
          }
          label _continueLabel[74398]
          _indexOfInterest[74393]
          _iterator[74394]
        }
        label _breakLabel[74399]
      }
    }
  }
  function chpl_direct_range_iter[74443](arg low[74440] :
  (74439 call int[13] unknown w[74436]), arg high[74449] :
  (74448 call int[13] w), arg stride[74456] :
  (74455 call uint[115] w)) : _unknown[51] "iterator fn"
  {
    {
      unknown _indexOfInterest[74469] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74470] "expr temp" "temp"
      (74479 'move' _iterator[74470](74477 call _getIterator(74465 call chpl_direct_pos_stride_range_iter low high stride)))
      Defer
      {
        {
          (74496 call _freeIterator _iterator[74470])
        }
      }
      { scopeless type
        (74485 'move' _indexOfInterest[74469](74482 call iteratorIndex _iterator[74470]))
      }
      ForLoop[74471]
      {
        unknown i[74489] "index var" "insert auto destroy"
        (74491 'move' i[74489] _indexOfInterest[74469])
        { scopeless
          (74467 yield i)
        }
        label _continueLabel[74474]
        _indexOfInterest[74469]
        _iterator[74470]
      }
      label _breakLabel[74475]
    }
  }
  function chpl_direct_range_iter[74516](arg low[74513] :
  (74512 call uint[115] unknown w[74509]), arg high[74522] :
  (74521 call uint[115] w), arg stride[74529] :
  (74528 call uint[115] w)) : _unknown[51] "iterator fn"
  {
    {
      unknown _indexOfInterest[74542] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74543] "expr temp" "temp"
      (74552 'move' _iterator[74543](74550 call _getIterator(74538 call chpl_direct_pos_stride_range_iter low high stride)))
      Defer
      {
        {
          (74569 call _freeIterator _iterator[74543])
        }
      }
      { scopeless type
        (74558 'move' _indexOfInterest[74542](74555 call iteratorIndex _iterator[74543]))
      }
      ForLoop[74544]
      {
        unknown i[74562] "index var" "insert auto destroy"
        (74564 'move' i[74562] _indexOfInterest[74542])
        { scopeless
          (74540 yield i)
        }
        label _continueLabel[74547]
        _indexOfInterest[74542]
        _iterator[74543]
      }
      label _breakLabel[74548]
    }
  }
  function chpl_direct_range_iter[74589](arg low[74586] :
  (74585 call int[13] unknown w[74582]), arg high[74595] :
  (74594 call int[13] w), arg stride[74598]:_any[178](?)) : _unknown[51] "iterator fn"
  {
    (74616 call compilerError "can't apply 'by' to a range with idxType "(74608 call _cast string[26](74606 call int[13] w)) " using a step of type "(74614 call _cast string[26](74612 'typeof' stride)))
  }
  function chpl_direct_range_iter[74631](arg low[74628] :
  (74627 call uint[115] unknown w[74624]), arg high[74637] :
  (74636 call uint[115] w), arg stride[74640]:_any[178](?)) : _unknown[51] "iterator fn"
  {
    (74658 call compilerError "can't apply 'by' to a range with idxType "(74650 call _cast string[26](74648 call uint[115] w)) " using a step of type "(74656 call _cast string[26](74654 'typeof' stride)))
  }
  function chpl_direct_range_iter[74667](arg low[74665]:_any[178](?), arg high[74669]:_any[178](?), arg stride[74671]:_any[178](?)) : _unknown[51] "iterator fn"
  {
    (74676 call compilerError "Bounds of 'low..high' must be integers of compatible types.")
  }
  function chpl_direct_counted_range_iter[74691](arg low[74688] :
  (74687 call int[13] unknown w[74684]), arg count[74697] :
  (74696 call int[13] w)) : _unknown[51] "iterator fn"
  {
    {
      unknown _indexOfInterest[74709] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74710] "expr temp" "temp"
      (74719 'move' _iterator[74710](74717 call _getIterator(74705 call chpl_direct_counted_range_iter_helper low count)))
      Defer
      {
        {
          (74736 call _freeIterator _iterator[74710])
        }
      }
      { scopeless type
        (74725 'move' _indexOfInterest[74709](74722 call iteratorIndex _iterator[74710]))
      }
      ForLoop[74711]
      {
        unknown i[74729] "index var" "insert auto destroy"
        (74731 'move' i[74729] _indexOfInterest[74709])
        { scopeless
          (74707 yield i)
        }
        label _continueLabel[74714]
        _indexOfInterest[74709]
        _iterator[74710]
      }
      label _breakLabel[74715]
    }
  }
  function chpl_direct_counted_range_iter[74756](arg low[74753] :
  (74752 call int[13] unknown w[74749]), arg count[74762] :
  (74761 call uint[115] w)) : _unknown[51] "iterator fn"
  {
    {
      unknown _indexOfInterest[74774] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74775] "expr temp" "temp"
      (74784 'move' _iterator[74775](74782 call _getIterator(74770 call chpl_direct_counted_range_iter_helper low count)))
      Defer
      {
        {
          (74801 call _freeIterator _iterator[74775])
        }
      }
      { scopeless type
        (74790 'move' _indexOfInterest[74774](74787 call iteratorIndex _iterator[74775]))
      }
      ForLoop[74776]
      {
        unknown i[74794] "index var" "insert auto destroy"
        (74796 'move' i[74794] _indexOfInterest[74774])
        { scopeless
          (74772 yield i)
        }
        label _continueLabel[74779]
        _indexOfInterest[74774]
        _iterator[74775]
      }
      label _breakLabel[74780]
    }
  }
  function chpl_direct_counted_range_iter[74821](arg low[74818] :
  (74817 call uint[115] unknown w[74814]), arg count[74827] :
  (74826 call int[13] w)) : _unknown[51] "iterator fn"
  {
    {
      unknown _indexOfInterest[74839] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74840] "expr temp" "temp"
      (74849 'move' _iterator[74840](74847 call _getIterator(74835 call chpl_direct_counted_range_iter_helper low count)))
      Defer
      {
        {
          (74866 call _freeIterator _iterator[74840])
        }
      }
      { scopeless type
        (74855 'move' _indexOfInterest[74839](74852 call iteratorIndex _iterator[74840]))
      }
      ForLoop[74841]
      {
        unknown i[74859] "index var" "insert auto destroy"
        (74861 'move' i[74859] _indexOfInterest[74839])
        { scopeless
          (74837 yield i)
        }
        label _continueLabel[74844]
        _indexOfInterest[74839]
        _iterator[74840]
      }
      label _breakLabel[74845]
    }
  }
  function chpl_direct_counted_range_iter[74886](arg low[74883] :
  (74882 call uint[115] unknown w[74879]), arg count[74892] :
  (74891 call uint[115] w)) : _unknown[51] "iterator fn"
  {
    {
      unknown _indexOfInterest[74904] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74905] "expr temp" "temp"
      (74914 'move' _iterator[74905](74912 call _getIterator(74900 call chpl_direct_counted_range_iter_helper low count)))
      Defer
      {
        {
          (74931 call _freeIterator _iterator[74905])
        }
      }
      { scopeless type
        (74920 'move' _indexOfInterest[74904](74917 call iteratorIndex _iterator[74905]))
      }
      ForLoop[74906]
      {
        unknown i[74924] "index var" "insert auto destroy"
        (74926 'move' i[74924] _indexOfInterest[74904])
        { scopeless
          (74902 yield i)
        }
        label _continueLabel[74909]
        _indexOfInterest[74904]
        _iterator[74905]
      }
      label _breakLabel[74910]
    }
  }
  function chpl_direct_counted_range_iter[74947](arg low[74944] :
  enum[187](?), arg count[74954] :
  (74953 call int[13] unknown w[74950])) : _unknown[51] "iterator fn"
  {
    { scopeless
      const r[74960] "const"(74958 call chpl_build_low_bounded_range low)
      (74963 'end of statement')
    }
    {
      unknown _indexOfInterest[74973] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74974] "expr temp" "temp"
      (74983 'move' _iterator[74974](74981 call _getIterator(74968 call # r count)))
      Defer
      {
        {
          (75001 call _freeIterator _iterator[74974])
        }
      }
      { scopeless type
        (74990 'move' _indexOfInterest[74973](74987 call iteratorIndex _iterator[74974]))
      }
      ForLoop[74975]
      {
        unknown i[74994] "index var" "insert auto destroy"
        (74996 'move' i[74994] _indexOfInterest[74973])
        { scopeless
          (74971 yield i)
        }
        label _continueLabel[74978]
        _indexOfInterest[74973]
        _iterator[74974]
      }
      label _breakLabel[74979]
    }
  }
  function chpl_direct_counted_range_iter[75016](arg low[75013] :
  enum[187](?), arg count[75023] :
  (75022 call uint[115] unknown w[75019])) : _unknown[51] "iterator fn"
  {
    { scopeless
      const r[75029] "const"(75027 call chpl_build_low_bounded_range low)
      (75032 'end of statement')
    }
    {
      unknown _indexOfInterest[75042] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[75043] "expr temp" "temp"
      (75052 'move' _iterator[75043](75050 call _getIterator(75037 call # r count)))
      Defer
      {
        {
          (75070 call _freeIterator _iterator[75043])
        }
      }
      { scopeless type
        (75059 'move' _indexOfInterest[75042](75056 call iteratorIndex _iterator[75043]))
      }
      ForLoop[75044]
      {
        unknown i[75063] "index var" "insert auto destroy"
        (75065 'move' i[75063] _indexOfInterest[75042])
        { scopeless
          (75040 yield i)
        }
        label _continueLabel[75047]
        _indexOfInterest[75042]
        _iterator[75043]
      }
      label _breakLabel[75048]
    }
  }
  function chpl_direct_counted_range_iter[75085](arg low[75082] :
  bool[10], arg count[75092] :
  (75091 call int[13] unknown w[75088])) : _unknown[51] "iterator fn"
  {
    { scopeless
      const r[75098] "const"(75096 call chpl_build_low_bounded_range low)
      (75101 'end of statement')
    }
    {
      unknown _indexOfInterest[75111] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[75112] "expr temp" "temp"
      (75121 'move' _iterator[75112](75119 call _getIterator(75106 call # r count)))
      Defer
      {
        {
          (75139 call _freeIterator _iterator[75112])
        }
      }
      { scopeless type
        (75128 'move' _indexOfInterest[75111](75125 call iteratorIndex _iterator[75112]))
      }
      ForLoop[75113]
      {
        unknown i[75132] "index var" "insert auto destroy"
        (75134 'move' i[75132] _indexOfInterest[75111])
        { scopeless
          (75109 yield i)
        }
        label _continueLabel[75116]
        _indexOfInterest[75111]
        _iterator[75112]
      }
      label _breakLabel[75117]
    }
  }
  function chpl_direct_counted_range_iter[75154](arg low[75151] :
  bool[10], arg count[75161] :
  (75160 call uint[115] unknown w[75157])) : _unknown[51] "iterator fn"
  {
    { scopeless
      const r[75167] "const"(75165 call chpl_build_low_bounded_range low)
      (75170 'end of statement')
    }
    {
      unknown _indexOfInterest[75180] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[75181] "expr temp" "temp"
      (75190 'move' _iterator[75181](75188 call _getIterator(75175 call # r count)))
      Defer
      {
        {
          (75208 call _freeIterator _iterator[75181])
        }
      }
      { scopeless type
        (75197 'move' _indexOfInterest[75180](75194 call iteratorIndex _iterator[75181]))
      }
      ForLoop[75182]
      {
        unknown i[75201] "index var" "insert auto destroy"
        (75203 'move' i[75201] _indexOfInterest[75180])
        { scopeless
          (75178 yield i)
        }
        label _continueLabel[75185]
        _indexOfInterest[75180]
        _iterator[75181]
      }
      label _breakLabel[75186]
    }
  }
  function chpl_direct_counted_range_iter[75223](arg low[75220] :
  integral, arg count[75225]:_any[178](?)) : _unknown[51] "iterator fn"
  {
    (75241 call compilerError "can't apply '#' to a range with idxType "(75233 call _cast string[26](75231 'typeof' low)) " using a count of type "(75239 call _cast string[26](75237 'typeof' count)))
  }
  function chpl_direct_counted_range_iter[75250](arg low[75248]:_any[178](?), arg count[75252]:_any[178](?)) : _unknown[51] "iterator fn"
  {
    (75257 call compilerError "Bound of 'low..' must be an integer")
  }
  function chpl_direct_counted_range_iter_helper[75266](arg low[75264]:_any[178](?), arg count[75268]:_any[178](?)) : _unknown[51] "iterator fn"
  {
    if(75292 call _cond_test(75282 call &&(75276 call && boundsChecking(75275 call isIntType(75273 'typeof' count)))(75280 call < count 0)))
    {
      { scopeless
        (75290 call(75285 call . HaltWrappers c"boundsCheckHalt") "With a negative count, the range must have a last index.")
      }
    }
    { scopeless
      const tmp[75340] "const" "temp"(75337 IfExpr (75305 call == count 0) then
      { scopeless
        (75320 call _build_tuple low(75317 call _cast(75316 'typeof' low)(75313 call -(75310 call _cast uint[115] low) 1)))
      } else
      { scopeless
        (75335 call _build_tuple low(75332 call + low(75330 call -(75327 call _cast(75326 'typeof' low) count) 1)))
      } )
      (75347 call _check_tuple_var_decl tmp[75340] 2)
      const start[75298] "const"(75341 call tmp[75340] 0)
      const end[75300] "const"(75344 call tmp[75340] 1)
      (75352 'end of statement')
    }
    {
      unknown _indexOfInterest[75363] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[75364] "expr temp" "temp"
      (75373 'move' _iterator[75364](75371 call _getIterator(75359 call chpl_direct_param_stride_range_iter start end 1)))
      Defer
      {
        {
          (75390 call _freeIterator _iterator[75364])
        }
      }
      { scopeless type
        (75379 'move' _indexOfInterest[75363](75376 call iteratorIndex _iterator[75364]))
      }
      ForLoop[75365]
      {
        unknown i[75383] "index var" "insert auto destroy"
        (75385 'move' i[75383] _indexOfInterest[75363])
        { scopeless
          (75361 yield i)
        }
        label _continueLabel[75368]
        _indexOfInterest[75363]
        _iterator[75364]
      }
      label _breakLabel[75369]
    }
  }
  function chpl_direct_pos_stride_range_iter[75406](arg low[75403] :
  unknown t[75401], arg high[75408]:_any[178](?), arg stride[75410]:_any[178](?)) : _unknown[51] "iterator fn"
  {
    if(75554 call _cond_test useOptimizedRangeIterators)
    {
      (75417 call chpl_range_check_stride stride t)
      if(75429 call _cond_test boundsChecking)
      {
        { scopeless
          (75427 call chpl_checkIfRangeIterWillOverflow t low high stride)
        }
      }
      { scopeless
        unknown i[75435] t
        (75438 'end of statement')
      }
      { scopeless
        CForLoop[75481]
        {
          {
            (75477 yield i)
          }
          label _continueLabel[75497]
          {
            (75482 '=' i low)
          }
          {
            (75485 '<=' i high)
          }
          {
            (75488 '+=' i(75491 call _cast t stride))
          }
        }
        label _breakLabel[75498]
      }
    }
    {
      {
        unknown _indexOfInterest[75519] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[75520] "expr temp" "temp"
        (75529 'move' _iterator[75520](75527 call _getIterator(75515 call(75511 call .(75507 call chpl_by(75504 call chpl_build_bounded_range low high) stride) c"generalIterator"))))
        Defer
        {
          {
            (75546 call _freeIterator _iterator[75520])
          }
        }
        { scopeless type
          (75535 'move' _indexOfInterest[75519](75532 call iteratorIndex _iterator[75520]))
        }
        ForLoop[75521]
        {
          unknown i[75539] "index var" "insert auto destroy"
          (75541 'move' i[75539] _indexOfInterest[75519])
          { scopeless
            (75517 yield i)
          }
          label _continueLabel[75524]
          _indexOfInterest[75519]
          _iterator[75520]
        }
        label _breakLabel[75525]
      }
    }
  }
  function chpl_direct_param_stride_range_iter[75568](arg low[75565] :
  unknown t[75563], arg high[75570]:_any[178](?), param arg stride[75572]:_any[178](?)) : _unknown[51] "iterator fn"
  {
    if(75779 call _cond_test useOptimizedRangeIterators)
    {
      (75579 call chpl_range_check_stride stride t)
      { scopeless
        unknown i[75583] t
        (75586 'end of statement')
      }
      if(75723 call _cond_test(75589 call > stride 0))
      {
        if(75600 call _cond_test boundsChecking)
        {
          { scopeless
            (75598 call chpl_checkIfRangeIterWillOverflow t low high stride)
          }
        }
        { scopeless
          CForLoop[75632]
          {
            {
              (75628 yield i)
            }
            label _continueLabel[75648]
            {
              (75633 '=' i low)
            }
            {
              (75636 '<=' i high)
            }
            {
              (75639 '+=' i(75642 call _cast t stride))
            }
          }
          label _breakLabel[75649]
        }
      }
      {
        { scopeless
          if(75719 call _cond_test(75654 call < stride 0))
          {
            if(75667 call _cond_test boundsChecking)
            {
              { scopeless
                (75665 call chpl_checkIfRangeIterWillOverflow t low high stride high low)
              }
            }
            { scopeless
              CForLoop[75699]
              {
                {
                  (75695 yield i)
                }
                label _continueLabel[75715]
                {
                  (75700 '=' i high)
                }
                {
                  (75703 '>=' i low)
                }
                {
                  (75706 '+=' i(75709 call _cast t stride))
                }
              }
              label _breakLabel[75716]
            }
          }
        }
      }
    }
    {
      {
        unknown _indexOfInterest[75744] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[75745] "expr temp" "temp"
        (75754 'move' _iterator[75745](75752 call _getIterator(75740 call(75736 call .(75734 call chpl_by(75731 call chpl_build_bounded_range low high) stride) c"generalIterator"))))
        Defer
        {
          {
            (75771 call _freeIterator _iterator[75745])
          }
        }
        { scopeless type
          (75760 'move' _indexOfInterest[75744](75757 call iteratorIndex _iterator[75745]))
        }
        ForLoop[75746]
        {
          unknown i[75764] "index var" "insert auto destroy"
          (75766 'move' i[75764] _indexOfInterest[75744])
          { scopeless
            (75742 yield i)
          }
          label _continueLabel[75749]
          _indexOfInterest[75744]
          _iterator[75745]
        }
        label _breakLabel[75750]
      }
    }
  }
  function _unknown[51].these[75789](arg _mt[75794]:_MT[238], arg this[75791] :
  range) : _unknown[51] "iterator fn" "method" "no doc"
  {
    if(75831 call _cond_test(75808 call == boundedType(75805 call . BoundedRangeType c"boundedNone")))
    {
      { scopeless
        (75829 call compilerError "iteration over a range with no bounds")
      }
    }
    if(75911 call _cond_test boundsChecking)
    {
      if(75870 call _cond_test(75844 call !(75843 call(75839 call . this c"hasFirst"))))
      {
        { scopeless
          (75868 call(75847 call . HaltWrappers c"boundsCheckHalt") "iteration over range that has no first index")
        }
      }
      if(75906 call _cond_test(75881 call(75877 call . this c"isAmbiguous")))
      {
        { scopeless
          (75904 call(75883 call . HaltWrappers c"boundsCheckHalt") "these -- Attempt to iterate over a range with ambiguous alignment.")
        }
      }
    }
    { scopeless
      unknown i[75916] intIdxType
      (75919 'end of statement')
    }
    { scopeless
      const start[75927] "const"(75926 call chpl__idxToInt(75922 call . this c"first"))
      (75930 'end of statement')
    }
    { scopeless
      CForLoop[75956]
      {
        {
          (75952 yield(75951 call chpl_intToIdx i))
        }
        label _continueLabel[75970]
        {
          (75957 '=' i start)
        }
        {
          1
        }
        {
          (75961 '+=' i(75964 call _cast intIdxType stride))
        }
      }
      label _breakLabel[75971]
    }
  }
  where {
    (75801 call != boundedType(75798 call . BoundedRangeType c"bounded"))
  }
  function _unknown[51].these[75980](arg _mt[75985]:_MT[238], arg this[75982] :
  range) : _unknown[51] "iterator fn" "method" "no doc"
  {
    if(76167 call _cond_test useOptimizedRangeIterators)
    {
      if(76026 call _cond_test boundsChecking)
      {
        (76004 call checkIfIterWillOverflow)
        if(76021 call _cond_test(76012 call(76008 call . this c"isAmbiguous")))
        {
          { scopeless
            (76019 call(76014 call . HaltWrappers c"boundsCheckHalt") "these -- Attempt to iterate over a range with ambiguous alignment.")
          }
        }
      }
      { scopeless
        unknown i[76032] intIdxType
        (76035 'end of statement')
      }
      { scopeless
        const start[76040] "const"(76037 call . this c"firstAsInt")
        (76043 'end of statement')
      }
      { scopeless
        const end[76069] "const"(76066 IfExpr (76053 call >(76046 call . this c"low")(76050 call . this c"high")) then
        { scopeless
          start
        } else
        { scopeless
          (76064 call +(76057 call . this c"lastAsInt")(76062 call _cast intIdxType stride))
        } ) intIdxType
        (76072 'end of statement')
      }
      { scopeless
        CForLoop[76102]
        {
          {
            (76098 yield(76097 call chpl_intToIdx i))
          }
          label _continueLabel[76118]
          {
            (76103 '=' i start)
          }
          {
            (76106 '!=' i end)
          }
          {
            (76109 '+=' i(76112 call _cast intIdxType stride))
          }
        }
        label _breakLabel[76119]
      }
    }
    {
      {
        unknown _indexOfInterest[76132] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[76133] "expr temp" "temp"
        (76142 'move' _iterator[76133](76140 call _getIterator(76128 call(76124 call . this c"generalIterator"))))
        Defer
        {
          {
            (76159 call _freeIterator _iterator[76133])
          }
        }
        { scopeless type
          (76148 'move' _indexOfInterest[76132](76145 call iteratorIndex _iterator[76133]))
        }
        ForLoop[76134]
        {
          unknown i[76152] "index var" "insert auto destroy"
          (76154 'move' i[76152] _indexOfInterest[76132])
          { scopeless
            (76130 yield i)
          }
          label _continueLabel[76137]
          _indexOfInterest[76132]
          _iterator[76133]
        }
        label _breakLabel[76138]
      }
    }
  }
  where {
    (75998 call &&(75992 call == boundedType(75989 call . BoundedRangeType c"bounded"))(75996 call == stridable 1))
  }
  function _unknown[51].these[76178](arg _mt[76183]:_MT[238], arg this[76180] :
  range) : _unknown[51] "iterator fn" "method" "no doc"
  {
    if(76325 call _cond_test useOptimizedRangeIterators)
    {
      if(76204 call _cond_test boundsChecking)
      {
        { scopeless
          (76202 call checkIfIterWillOverflow)
        }
      }
      { scopeless
        unknown i[76211] intIdxType
        (76214 'end of statement')
      }
      { scopeless
        const start[76219] "const"(76216 call . this c"_low")
        (76222 'end of statement')
      }
      { scopeless
        const end[76227] "const"(76224 call . this c"_high")
        (76230 'end of statement')
      }
      { scopeless
        CForLoop[76260]
        {
          {
            (76256 yield(76255 call chpl_intToIdx i))
          }
          label _continueLabel[76276]
          {
            (76261 '=' i start)
          }
          {
            (76264 '<=' i end)
          }
          {
            (76267 '+=' i(76270 call _cast intIdxType stride))
          }
        }
        label _breakLabel[76277]
      }
    }
    {
      {
        unknown _indexOfInterest[76290] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[76291] "expr temp" "temp"
        (76300 'move' _iterator[76291](76298 call _getIterator(76286 call(76282 call . this c"generalIterator"))))
        Defer
        {
          {
            (76317 call _freeIterator _iterator[76291])
          }
        }
        { scopeless type
          (76306 'move' _indexOfInterest[76290](76303 call iteratorIndex _iterator[76291]))
        }
        ForLoop[76292]
        {
          unknown i[76310] "index var" "insert auto destroy"
          (76312 'move' i[76310] _indexOfInterest[76290])
          { scopeless
            (76288 yield i)
          }
          label _continueLabel[76295]
          _indexOfInterest[76290]
          _iterator[76291]
        }
        label _breakLabel[76296]
      }
    }
  }
  where {
    (76196 call &&(76190 call == boundedType(76187 call . BoundedRangeType c"bounded"))(76194 call == stridable 0))
  }
  function _unknown[51].generalIterator[76336](arg _mt[76341]:_MT[238], arg this[76338] :
  range) : _unknown[51] "iterator fn" "method" "no doc"
  {
    if(76360 call _cond_test(76350 call && boundsChecking(76349 call(76345 call . this c"isAmbiguous"))))
    {
      { scopeless
        (76358 call(76353 call . HaltWrappers c"boundsCheckHalt") "these -- Attempt to iterate over a range with ambiguous alignment.")
      }
    }
    { scopeless
      unknown i[76367] intIdxType
      (76370 'end of statement')
    }
    { scopeless
      const start[76375] "const"(76372 call . this c"first")
      (76378 'end of statement')
    }
    { scopeless
      const end[76399] "const"(76396 IfExpr (76387 call >(76380 call . this c"low")(76384 call . this c"high")) then
      { scopeless
        start
      } else
      { scopeless
        (76393 call . this c"last")
      } )
      (76402 'end of statement')
    }
    { scopeless
      CForLoop[76441]
      {
        {
          (76425 yield i)
          if(76435 call _cond_test(76430 call == i end))
          {
            { scopeless
              break nil[44]
            }
          }
        }
        label _continueLabel[76457]
        {
          (76442 '=' i start)
        }
        {
          (76445 '>=' high low)
        }
        {
          (76448 '+=' i(76451 call _cast intIdxType stride))
        }
      }
      label _breakLabel[76458]
    }
  }
  function _unknown[51].these[76470](arg _mt[76475]:_MT[238], arg this[76472] :
  range, param arg tag[76467] :
  iterKind) : _unknown[51] "iterator fn" "method" "no doc"
  {
    if(76517 call _cond_test(76493 call !(76492 call isBoundedRange this)))
    {
      (76514 call compilerError "parallel iteration is not supported over unbounded ranges")
    }
    if(76540 call _cond_test(76529 call && boundsChecking(76528 call(76524 call . this c"isAmbiguous"))))
    {
      (76537 call(76532 call . HaltWrappers c"boundsCheckHalt") "these -- Attempt to iterate over a range with ambiguous alignment.")
    }
    if(76567 call _cond_test debugChapelRange)
    {
      (76564 call chpl_debug_writeln "*** In range standalone iterator:")
    }
    { scopeless
      const len[76575] "const"(76572 call . this c"size")
      (76578 'end of statement')
    }
    { scopeless
      const numChunks[76606] "const"(76603 IfExpr (76597 'task_get_serial') then
      { scopeless
        1
      } else
      { scopeless
        (76602 call _computeNumChunks len)
      } )
      (76609 'end of statement')
    }
    if(76652 call _cond_test debugChapelRange)
    {
      (76649 call chpl_debug_writeln "*** RI: length=" len " numChunks=" numChunks)
    }
    if(77307 call _cond_test(76658 call <= numChunks 1))
    {
      {
        unknown _indexOfInterest[76666] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[76667] "expr temp" "temp"
        (76676 'move' _iterator[76667](76674 call _getIterator this))
        Defer
        {
          {
            (76692 call _freeIterator _iterator[76667])
          }
        }
        { scopeless type
          (76681 'move' _indexOfInterest[76666](76678 call iteratorIndex _iterator[76667]))
        }
        ForLoop[76668]
        {
          unknown i[76685] "index var" "insert auto destroy"
          (76687 'move' i[76685] _indexOfInterest[76666])
          {
            (76663 yield i)
          }
          label _continueLabel[76671]
          _indexOfInterest[76666]
          _iterator[76667]
        }
        label _breakLabel[76672]
      }
    }
    {
      {
        unknown tmpIter[76942] "expr temp" "maybe ref" "no copy" "temp"
        (76945 'move' tmpIter[76942](76705 call #(76702 call chpl_build_low_bounded_range 0) numChunks))
        unknown isRngDomArr[77287] "maybe param" "temp"
        (77302 'move' isRngDomArr[77287](77300 call ||(77289 call isBoundedRange tmpIter[76942])(77298 call ||(77292 call isDomain tmpIter[76942])(77295 call isArray tmpIter[76942]))))
        if isRngDomArr[77287]
        {
          const _coforallCount[77154] "const" "end count" "temp"
          (77223 'move' _coforallCount[77154](77220 call _endCountAlloc 1))
          unknown numTasks[77155] "temp"
          (77207 'move' numTasks[77155](77203 call . tmpIter[76942] c"size"))
          (77198 call _upEndCount _coforallCount[77154] 1 numTasks[77155])
          (77195 call chpl_resetTaskSpawn numTasks[77155])
          unknown _indexOfInterest[77162] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[77163] "expr temp" "temp"
          (77172 'move' _iterator[77163](77170 call _getIterator tmpIter[76942]))
          Defer
          {
            {
              (77188 call _freeIterator _iterator[77163])
            }
          }
          { scopeless type
            (77177 'move' _indexOfInterest[77162](77174 call iteratorIndex _iterator[77163]))
          }
          ForLoop[77164]
          {
            unknown chunk[77181] "coforall index var" "index var" "insert auto destroy"
            (77183 'move' chunk[77181] _indexOfInterest[77162])
            {
              {
                if(76949 call _cond_test stridable)
                {
                  { scopeless
                    const tmp[76953] "const" "temp"(76955 call _computeBlock len numChunks chunk(76960 call - len 1))
                    (76965 call _check_tuple_var_decl tmp[76953] 2)
                    const lo[76968] "const"(76970 call tmp[76953] 0)
                    const hi[76973] "const"(76975 call tmp[76953] 1)
                    (76978 'end of statement')
                  }
                  { scopeless
                    const mylen[76980] "const"(76982 call - hi(76985 call - lo 1))
                    (76989 'end of statement')
                  }
                  { scopeless
                    unknown low[76991](76993 call orderToIndex lo)
                    (76996 'end of statement')
                  }
                  { scopeless
                    unknown high[76998](77000 call chpl_intToIdx(77002 call +(77004 call _cast strType(77007 call chpl__idxToInt low))(77010 call * stride(77013 call _cast strType(77016 call - mylen 1)))))
                    (77020 'end of statement')
                  }
                  if(77022 call _cond_test(77024 call < stride 0))
                  {
                    { scopeless
                      (77030 call <=> low high)
                    }
                  }
                  {
                    unknown _indexOfInterest[77035] "an _indexOfInterest or chpl__followIdx variable" "temp"
                    unknown _iterator[77037] "expr temp" "temp"
                    (77039 'move' _iterator[77037](77042 call _getIterator(77044 call chpl_direct_range_iter low high stride)))
                    Defer
                    {
                      {
                        (77050 call _freeIterator _iterator[77037])
                      }
                    }
                    { scopeless type
                      (77054 'move' _indexOfInterest[77035](77057 call iteratorIndex _iterator[77037]))
                    }
                    ForLoop[77059]
                    {
                      unknown i[77062] "index var" "insert auto destroy"
                      (77064 'move' i[77062] _indexOfInterest[77035])
                      {
                        (77068 yield i)
                      }
                      label _continueLabel[77070]
                      _indexOfInterest[77035]
                      _iterator[77037]
                    }
                    label _breakLabel[77072]
                  }
                }
                {
                  { scopeless
                    const tmp[77076] "const" "temp"(77078 call _computeBlock len numChunks chunk(77083 call . this c"_high")(77087 call . this c"_low")(77091 call . this c"_low"))
                    (77096 call _check_tuple_var_decl tmp[77076] 2)
                    const lo[77099] "const"(77101 call tmp[77076] 0)
                    const hi[77104] "const"(77106 call tmp[77076] 1)
                    (77109 'end of statement')
                  }
                  {
                    unknown _indexOfInterest[77111] "an _indexOfInterest or chpl__followIdx variable" "temp"
                    unknown _iterator[77113] "expr temp" "temp"
                    (77115 'move' _iterator[77113](77118 call _getIterator(77120 call chpl_direct_range_iter lo hi 1)))
                    Defer
                    {
                      {
                        (77126 call _freeIterator _iterator[77113])
                      }
                    }
                    { scopeless type
                      (77130 'move' _indexOfInterest[77111](77133 call iteratorIndex _iterator[77113]))
                    }
                    ForLoop[77135]
                    {
                      unknown i[77138] "index var" "insert auto destroy"
                      (77140 'move' i[77138] _indexOfInterest[77111])
                      {
                        (77144 yield(77146 call chpl_intToIdx i))
                      }
                      label _continueLabel[77148]
                      _indexOfInterest[77111]
                      _iterator[77113]
                    }
                    label _breakLabel[77150]
                  }
                }
              }
              (77157 call _downEndCount _coforallCount[77154] nil[44])
              (77156 'coforall loop')
            }
            label _continueLabel[77167]
            _indexOfInterest[77162]
            _iterator[77163]
          }
          label _breakLabel[77168]
          Defer
          {
            {
              (77210 call _endCountFree _coforallCount[77154])
            }
          }
          (77215 call _waitEndCount _coforallCount[77154] 1 numTasks[77155])
        }
        {
          const _coforallCount[77227] "const" "end count" "temp"
          (77284 'move' _coforallCount[77227](77281 call _endCountAlloc 1))
          unknown _indexOfInterest[77235] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[77236] "expr temp" "temp"
          (77245 'move' _iterator[77236](77243 call _getIterator tmpIter[76942]))
          Defer
          {
            {
              (77261 call _freeIterator _iterator[77236])
            }
          }
          { scopeless type
            (77250 'move' _indexOfInterest[77235](77247 call iteratorIndex _iterator[77236]))
          }
          ForLoop[77237]
          {
            unknown chunk[77254] "coforall index var" "index var" "insert auto destroy"
            (77256 'move' chunk[77254] _indexOfInterest[77235])
            (77268 call _upEndCount _coforallCount[77227] 1)
            {
              {
                if(76937 call _cond_test stridable)
                {
                  { scopeless
                    const tmp[76723] "const" "temp"(76722 call _computeBlock len numChunks chunk(76720 call - len 1))
                    (76730 call _check_tuple_var_decl tmp[76723] 2)
                    const lo[76708] "const"(76724 call tmp[76723] 0)
                    const hi[76710] "const"(76727 call tmp[76723] 1)
                    (76735 'end of statement')
                  }
                  { scopeless
                    const mylen[76744] "const"(76742 call - hi(76740 call - lo 1))
                    (76747 'end of statement')
                  }
                  { scopeless
                    unknown low[76752](76751 call orderToIndex lo)
                    (76755 'end of statement')
                  }
                  { scopeless
                    unknown high[76778](76777 call chpl_intToIdx(76774 call +(76762 call _cast strType(76760 call chpl__idxToInt low))(76772 call * stride(76770 call _cast strType(76767 call - mylen 1)))))
                    (76781 'end of statement')
                  }
                  if(76791 call _cond_test(76784 call < stride 0))
                  {
                    { scopeless
                      (76788 call <=> low high)
                    }
                  }
                  {
                    unknown _indexOfInterest[76808] "an _indexOfInterest or chpl__followIdx variable" "temp"
                    unknown _iterator[76809] "expr temp" "temp"
                    (76818 'move' _iterator[76809](76816 call _getIterator(76827 call chpl_direct_range_iter low high stride)))
                    Defer
                    {
                      {
                        (76843 call _freeIterator _iterator[76809])
                      }
                    }
                    { scopeless type
                      (76832 'move' _indexOfInterest[76808](76829 call iteratorIndex _iterator[76809]))
                    }
                    ForLoop[76810]
                    {
                      unknown i[76836] "index var" "insert auto destroy"
                      (76838 'move' i[76836] _indexOfInterest[76808])
                      {
                        (76805 yield i)
                      }
                      label _continueLabel[76813]
                      _indexOfInterest[76808]
                      _iterator[76809]
                    }
                    label _breakLabel[76814]
                  }
                }
                {
                  { scopeless
                    const tmp[76873] "const" "temp"(76872 call _computeBlock len numChunks chunk(76861 call . this c"_high")(76865 call . this c"_low")(76869 call . this c"_low"))
                    (76880 call _check_tuple_var_decl tmp[76873] 2)
                    const lo[76850] "const"(76874 call tmp[76873] 0)
                    const hi[76852] "const"(76877 call tmp[76873] 1)
                    (76885 'end of statement')
                  }
                  {
                    unknown _indexOfInterest[76899] "an _indexOfInterest or chpl__followIdx variable" "temp"
                    unknown _iterator[76900] "expr temp" "temp"
                    (76909 'move' _iterator[76900](76907 call _getIterator(76914 call chpl_direct_range_iter lo hi 1)))
                    Defer
                    {
                      {
                        (76930 call _freeIterator _iterator[76900])
                      }
                    }
                    { scopeless type
                      (76919 'move' _indexOfInterest[76899](76916 call iteratorIndex _iterator[76900]))
                    }
                    ForLoop[76901]
                    {
                      unknown i[76923] "index var" "insert auto destroy"
                      (76925 'move' i[76923] _indexOfInterest[76899])
                      {
                        (76896 yield(76895 call chpl_intToIdx i))
                      }
                      label _continueLabel[76904]
                      _indexOfInterest[76899]
                      _iterator[76900]
                    }
                    label _breakLabel[76905]
                  }
                }
              }
              (77230 call _downEndCount _coforallCount[77227] nil[44])
              (77229 'coforall loop')
            }
            label _continueLabel[77240]
            _indexOfInterest[77235]
            _iterator[77236]
          }
          label _breakLabel[77241]
          Defer
          {
            {
              (77272 call _endCountFree _coforallCount[77227])
            }
          }
          (77277 call _waitEndCount _coforallCount[77227] 1)
        }
      }
    }
  }
  where {
    (76487 call &&(76482 call == tag(76479 call . iterKind c"standalone"))(76485 call ! localeModelHasSublocales))
  }
  function _unknown[51].these[77321](arg _mt[77326]:_MT[238], arg this[77323] :
  range, param arg tag[77318] :
  iterKind) : _unknown[51] "iterator fn" "method" "no doc"
  {
    if(77346 call _cond_test(77339 call !(77338 call isBoundedRange this)))
    {
      { scopeless
        (77344 call compilerError "parallel iteration is not supported over unbounded ranges")
      }
    }
    if(77369 call _cond_test(77359 call && boundsChecking(77358 call(77354 call . this c"isAmbiguous"))))
    {
      { scopeless
        (77367 call(77362 call . HaltWrappers c"boundsCheckHalt") "these -- Attempt to iterate over a range with ambiguous alignment.")
      }
    }
    if(77396 call _cond_test debugChapelRange)
    {
      { scopeless
        (77394 call chpl_debug_writeln "*** In range leader:")
      }
    }
    { scopeless
      const numSublocs[77409] "const"(77408 call(77404 call . here c"getChildCount"))
      (77412 'end of statement')
    }
    if(79138 call _cond_test(77418 call && localeModelHasSublocales(77416 call != numSublocs 0)))
    {
      { scopeless
        const len[77424] "const"(77421 call . this c"size")
        (77427 'end of statement')
      }
      { scopeless
        const tasksPerLocale[77430] "const" dataParTasksPerLocale
        (77433 'end of statement')
      }
      { scopeless
        const ignoreRunning[77435] "const" dataParIgnoreRunningTasks
        (77438 'end of statement')
      }
      { scopeless
        const minIndicesPerTask[77440] "const" dataParMinGranularity
        (77443 'end of statement')
      }
      { scopeless
        unknown dptpl[77456](77453 IfExpr (77446 call == tasksPerLocale 0) then
        { scopeless
          (77449 call . here c"maxTaskPar")
        } else
        { scopeless
          tasksPerLocale
        } )
        (77459 'end of statement')
      }
      if(77498 call _cond_test(77461 call ! ignoreRunning))
      {
        { scopeless
          const otherTasks[77474] "const"(77472 call -(77470 call(77466 call . here c"runningTasks")) 1)
          (77477 'end of statement')
        }
        (77495 call = dptpl(77492 IfExpr (77482 call < otherTasks dptpl) then
        { scopeless
          (77489 call _cast int[13](77486 call - dptpl otherTasks))
        } else
        { scopeless
          1
        } ))
      }
      { scopeless
        const numSublocTasks[77507] "const"(77506 call min numSublocs dptpl)
        (77510 'end of statement')
      }
      { scopeless
        const numChunks[77526] "const"(77523 IfExpr (77513 'task_get_serial') then
        { scopeless
          1
        } else
        { scopeless
          (77522 call _computeNumChunks numSublocTasks(ignoreRunning = 1) minIndicesPerTask len)
        } )
        (77529 'end of statement')
      }
      if(77646 call _cond_test debugDataParNuma)
      {
        (77643 call chpl_debug_writeln "### numSublocs = " numSublocs "\n" "### numTasksPerSubloc = " numSublocTasks "\n" "### ignoreRunning = " ignoreRunning "\n" "### minIndicesPerTask = " minIndicesPerTask "\n" "### numChunks = " numChunks)
      }
      if(78751 call _cond_test(77652 call == numChunks 1))
      {
        (77663 yield(77661 call _build_tuple(77659 call chpl_build_bounded_range 0(77657 call - len 1))))
      }
      {
        {
          unknown tmpIter[78210] "expr temp" "maybe ref" "no copy" "temp"
          (78213 'move' tmpIter[78210](77671 call #(77668 call chpl_build_low_bounded_range 0) numChunks))
          unknown isRngDomArr[78731] "maybe param" "temp"
          (78746 'move' isRngDomArr[78731](78744 call ||(78733 call isBoundedRange tmpIter[78210])(78742 call ||(78736 call isDomain tmpIter[78210])(78739 call isArray tmpIter[78210]))))
          if isRngDomArr[78731]
          {
            const _coforallCount[78603] "const" "end count" "temp"
            (78668 'move' _coforallCount[78603](78665 call _endCountAlloc 0))
            unknown numTasks[78604] "temp"
            (78652 'move' numTasks[78604](78648 call . tmpIter[78210] c"size"))
            (78643 call _upEndCount _coforallCount[78603] 0 numTasks[78604])
            unknown _indexOfInterest[78610] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
            unknown _iterator[78611] "expr temp" "temp"
            (78620 'move' _iterator[78611](78618 call _getIterator tmpIter[78210]))
            Defer
            {
              {
                (78636 call _freeIterator _iterator[78611])
              }
            }
            { scopeless type
              (78625 'move' _indexOfInterest[78610](78622 call iteratorIndex _iterator[78611]))
            }
            ForLoop[78612]
            {
              unknown chunk[78629] "coforall index var" "index var" "insert auto destroy"
              (78631 'move' chunk[78629] _indexOfInterest[78610])
              { scopeless
                { scopeless
                  const tmp[78216] "const" "temp"
                  (78218 'move' tmp[78216](78220 'deref'(78221 '_wide_get_locale'(78226 call(78223 call . here c"getChild") chunk))))
                  {
                    {
                      if(78234 call _cond_test debugDataParNuma)
                      {
                        if(78238 call _cond_test(78240 call != chunk(78243 call chpl_getSubloc)))
                        {
                          { scopeless
                            (78247 call chpl_debug_writeln "*** ERROR: ON WRONG SUBLOC (should be " chunk ", on "(78252 call chpl_getSubloc) ") ***")
                          }
                        }
                      }
                      { scopeless
                        const tmp[78257] "const" "temp"(78259 call _computeBlock len numChunks chunk(78264 call - len 1))
                        (78269 call _check_tuple_var_decl tmp[78257] 2)
                        const lo[78272] "const"(78274 call tmp[78257] 0)
                        const hi[78277] "const"(78279 call tmp[78257] 1)
                        (78282 'end of statement')
                      }
                      { scopeless
                        const locRange[78284] "const"(78286 call chpl_build_bounded_range lo hi)
                        (78290 'end of statement')
                      }
                      { scopeless
                        const locLen[78292] "const"(78294 call . locRange c"size")
                        (78298 'end of statement')
                      }
                      { scopeless
                        const numSublocTasks[78300] "const"(78321 IfExpr (78302 call < chunk(78305 call % dptpl numChunks)) then
                        { scopeless
                          (78310 call +(78312 call / dptpl numChunks) 1)
                        } else
                        { scopeless
                          (78318 call / dptpl numChunks)
                        } )
                        (78323 'end of statement')
                      }
                      { scopeless
                        const numTasks[78325] "const"(78327 call _computeNumChunks numSublocTasks(ignoreRunning = 1) minIndicesPerTask locLen)
                        (78334 'end of statement')
                      }
                      {
                        unknown tmpIter[78336] "expr temp" "maybe ref" "no copy" "temp"
                        (78338 'move' tmpIter[78336](78341 call #(78343 call chpl_build_low_bounded_range 0) numTasks))
                        unknown isRngDomArr[78346] "maybe param" "temp"
                        (78348 'move' isRngDomArr[78346](78351 call ||(78353 call isBoundedRange tmpIter[78336])(78356 call ||(78358 call isDomain tmpIter[78336])(78361 call isArray tmpIter[78336]))))
                        if isRngDomArr[78346]
                        {
                          const _coforallCount[78365] "const" "end count" "temp"
                          (78367 'move' _coforallCount[78365](78370 call _endCountAlloc 1))
                          unknown numTasks[78372] "temp"
                          (78374 'move' numTasks[78372](78377 call . tmpIter[78336] c"size"))
                          (78381 call _upEndCount _coforallCount[78365] 1 numTasks[78372])
                          (78386 call chpl_resetTaskSpawn numTasks[78372])
                          unknown _indexOfInterest[78388] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
                          unknown _iterator[78390] "expr temp" "temp"
                          (78392 'move' _iterator[78390](78395 call _getIterator tmpIter[78336]))
                          Defer
                          {
                            {
                              (78399 call _freeIterator _iterator[78390])
                            }
                          }
                          { scopeless type
                            (78403 'move' _indexOfInterest[78388](78406 call iteratorIndex _iterator[78390]))
                          }
                          ForLoop[78408]
                          {
                            unknown core[78411] "coforall index var" "index var" "insert auto destroy"
                            (78413 'move' core[78411] _indexOfInterest[78388])
                            {
                              {
                                { scopeless
                                  const tmp[78420] "const" "temp"(78422 call _computeBlock locLen numTasks core hi lo lo)
                                  (78431 call _check_tuple_var_decl tmp[78420] 2)
                                  const low[78434] "const"(78436 call tmp[78420] 0)
                                  const high[78439] "const"(78441 call tmp[78420] 1)
                                  (78444 'end of statement')
                                }
                                if(78446 call _cond_test debugDataParNuma)
                                {
                                  (78450 call chpl_debug_writeln "### chunk = " chunk "  core = " core "  " "locRange = " locRange "  coreRange = "(78460 call chpl_build_bounded_range low high))
                                }
                                (78464 yield(78466 call _build_tuple(78468 call chpl_build_bounded_range low high)))
                              }
                              (78472 call _downEndCount _coforallCount[78365] nil[44])
                              (78417 'coforall loop')
                            }
                            label _continueLabel[78475]
                            _indexOfInterest[78388]
                            _iterator[78390]
                          }
                          label _breakLabel[78477]
                          Defer
                          {
                            {
                              (78481 call _endCountFree _coforallCount[78365])
                            }
                          }
                          (78485 call _waitEndCount _coforallCount[78365] 1 numTasks[78372])
                        }
                        {
                          const _coforallCount[78490] "const" "end count" "temp"
                          (78492 'move' _coforallCount[78490](78495 call _endCountAlloc 1))
                          unknown _indexOfInterest[78497] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
                          unknown _iterator[78499] "expr temp" "temp"
                          (78501 'move' _iterator[78499](78504 call _getIterator tmpIter[78336]))
                          Defer
                          {
                            {
                              (78508 call _freeIterator _iterator[78499])
                            }
                          }
                          { scopeless type
                            (78512 'move' _indexOfInterest[78497](78515 call iteratorIndex _iterator[78499]))
                          }
                          ForLoop[78517]
                          {
                            unknown core[78520] "coforall index var" "index var" "insert auto destroy"
                            (78522 'move' core[78520] _indexOfInterest[78497])
                            (78526 call _upEndCount _coforallCount[78490] 1)
                            {
                              {
                                { scopeless
                                  const tmp[78533] "const" "temp"(78535 call _computeBlock locLen numTasks core hi lo lo)
                                  (78544 call _check_tuple_var_decl tmp[78533] 2)
                                  const low[78547] "const"(78549 call tmp[78533] 0)
                                  const high[78552] "const"(78554 call tmp[78533] 1)
                                  (78557 'end of statement')
                                }
                                if(78559 call _cond_test debugDataParNuma)
                                {
                                  (78563 call chpl_debug_writeln "### chunk = " chunk "  core = " core "  " "locRange = " locRange "  coreRange = "(78573 call chpl_build_bounded_range low high))
                                }
                                (78577 yield(78579 call _build_tuple(78581 call chpl_build_bounded_range low high)))
                              }
                              (78585 call _downEndCount _coforallCount[78490] nil[44])
                              (78530 'coforall loop')
                            }
                            label _continueLabel[78588]
                            _indexOfInterest[78497]
                            _iterator[78499]
                          }
                          label _breakLabel[78590]
                          Defer
                          {
                            {
                              (78594 call _endCountFree _coforallCount[78490])
                            }
                          }
                          (78598 call _waitEndCount _coforallCount[78490] 1)
                        }
                      }
                    }
                    (78605 call _downEndCount _coforallCount[78603] nil[44])
                    (78229 'coforall on block' 1 tmp[78216])
                  }
                }
              }
              label _continueLabel[78615]
              _indexOfInterest[78610]
              _iterator[78611]
            }
            label _breakLabel[78616]
            Defer
            {
              {
                (78655 call _endCountFree _coforallCount[78603])
              }
            }
            (78660 call _waitEndCount _coforallCount[78603] 0 numTasks[78604])
          }
          {
            const _coforallCount[78672] "const" "end count" "temp"
            (78728 'move' _coforallCount[78672](78725 call _endCountAlloc 0))
            unknown _indexOfInterest[78679] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
            unknown _iterator[78680] "expr temp" "temp"
            (78689 'move' _iterator[78680](78687 call _getIterator tmpIter[78210]))
            Defer
            {
              {
                (78705 call _freeIterator _iterator[78680])
              }
            }
            { scopeless type
              (78694 'move' _indexOfInterest[78679](78691 call iteratorIndex _iterator[78680]))
            }
            ForLoop[78681]
            {
              unknown chunk[78698] "coforall index var" "index var" "insert auto destroy"
              (78700 'move' chunk[78698] _indexOfInterest[78679])
              (78712 call _upEndCount _coforallCount[78672] 0)
              { scopeless
                { scopeless
                  const tmp[78199] "const" "temp"
                  (78201 'move' tmp[78199](78197 'deref'(78196 '_wide_get_locale'(77681 call(77676 call . here c"getChild") chunk))))
                  {
                    {
                      if(77754 call _cond_test debugDataParNuma)
                      {
                        if(77748 call _cond_test(77687 call != chunk(77686 call chpl_getSubloc)))
                        {
                          { scopeless
                            (77746 call chpl_debug_writeln "*** ERROR: ON WRONG SUBLOC (should be " chunk ", on "(77728 call chpl_getSubloc) ") ***")
                          }
                        }
                      }
                      { scopeless
                        const tmp[77774] "const" "temp"(77773 call _computeBlock len numChunks chunk(77771 call - len 1))
                        (77781 call _check_tuple_var_decl tmp[77774] 2)
                        const lo[77759] "const"(77775 call tmp[77774] 0)
                        const hi[77761] "const"(77778 call tmp[77774] 1)
                        (77786 'end of statement')
                      }
                      { scopeless
                        const locRange[77791] "const"(77789 call chpl_build_bounded_range lo hi)
                        (77794 'end of statement')
                      }
                      { scopeless
                        const locLen[77799] "const"(77796 call . locRange c"size")
                        (77802 'end of statement')
                      }
                      { scopeless
                        const numSublocTasks[77824] "const"(77821 IfExpr (77808 call < chunk(77806 call % dptpl numChunks)) then
                        { scopeless
                          (77815 call +(77812 call / dptpl numChunks) 1)
                        } else
                        { scopeless
                          (77819 call / dptpl numChunks)
                        } )
                        (77827 'end of statement')
                      }
                      { scopeless
                        const numTasks[77836] "const"(77835 call _computeNumChunks numSublocTasks(ignoreRunning = 1) minIndicesPerTask locLen)
                        (77839 'end of statement')
                      }
                      {
                        unknown tmpIter[77985] "expr temp" "maybe ref" "no copy" "temp"
                        (77988 'move' tmpIter[77985](77845 call #(77842 call chpl_build_low_bounded_range 0) numTasks))
                        unknown isRngDomArr[78177] "maybe param" "temp"
                        (78192 'move' isRngDomArr[78177](78190 call ||(78179 call isBoundedRange tmpIter[77985])(78188 call ||(78182 call isDomain tmpIter[77985])(78185 call isArray tmpIter[77985]))))
                        if isRngDomArr[78177]
                        {
                          const _coforallCount[78044] "const" "end count" "temp"
                          (78113 'move' _coforallCount[78044](78110 call _endCountAlloc 1))
                          unknown numTasks[78045] "temp"
                          (78097 'move' numTasks[78045](78093 call . tmpIter[77985] c"size"))
                          (78088 call _upEndCount _coforallCount[78044] 1 numTasks[78045])
                          (78085 call chpl_resetTaskSpawn numTasks[78045])
                          unknown _indexOfInterest[78052] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
                          unknown _iterator[78053] "expr temp" "temp"
                          (78062 'move' _iterator[78053](78060 call _getIterator tmpIter[77985]))
                          Defer
                          {
                            {
                              (78078 call _freeIterator _iterator[78053])
                            }
                          }
                          { scopeless type
                            (78067 'move' _indexOfInterest[78052](78064 call iteratorIndex _iterator[78053]))
                          }
                          ForLoop[78054]
                          {
                            unknown core[78071] "coforall index var" "index var" "insert auto destroy"
                            (78073 'move' core[78071] _indexOfInterest[78052])
                            {
                              {
                                { scopeless
                                  const tmp[77992] "const" "temp"(77994 call _computeBlock locLen numTasks core hi lo lo)
                                  (78003 call _check_tuple_var_decl tmp[77992] 2)
                                  const low[78006] "const"(78008 call tmp[77992] 0)
                                  const high[78011] "const"(78013 call tmp[77992] 1)
                                  (78016 'end of statement')
                                }
                                if(78018 call _cond_test debugDataParNuma)
                                {
                                  (78022 call chpl_debug_writeln "### chunk = " chunk "  core = " core "  " "locRange = " locRange "  coreRange = "(78032 call chpl_build_bounded_range low high))
                                }
                                (78036 yield(78038 call _build_tuple(78040 call chpl_build_bounded_range low high)))
                              }
                              (78047 call _downEndCount _coforallCount[78044] nil[44])
                              (78046 'coforall loop')
                            }
                            label _continueLabel[78057]
                            _indexOfInterest[78052]
                            _iterator[78053]
                          }
                          label _breakLabel[78058]
                          Defer
                          {
                            {
                              (78100 call _endCountFree _coforallCount[78044])
                            }
                          }
                          (78105 call _waitEndCount _coforallCount[78044] 1 numTasks[78045])
                        }
                        {
                          const _coforallCount[78117] "const" "end count" "temp"
                          (78174 'move' _coforallCount[78117](78171 call _endCountAlloc 1))
                          unknown _indexOfInterest[78125] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
                          unknown _iterator[78126] "expr temp" "temp"
                          (78135 'move' _iterator[78126](78133 call _getIterator tmpIter[77985]))
                          Defer
                          {
                            {
                              (78151 call _freeIterator _iterator[78126])
                            }
                          }
                          { scopeless type
                            (78140 'move' _indexOfInterest[78125](78137 call iteratorIndex _iterator[78126]))
                          }
                          ForLoop[78127]
                          {
                            unknown core[78144] "coforall index var" "index var" "insert auto destroy"
                            (78146 'move' core[78144] _indexOfInterest[78125])
                            (78158 call _upEndCount _coforallCount[78117] 1)
                            {
                              {
                                { scopeless
                                  const tmp[77861] "const" "temp"(77860 call _computeBlock locLen numTasks core hi lo lo)
                                  (77868 call _check_tuple_var_decl tmp[77861] 2)
                                  const low[77847] "const"(77862 call tmp[77861] 0)
                                  const high[77849] "const"(77865 call tmp[77861] 1)
                                  (77873 'end of statement')
                                }
                                if(77973 call _cond_test debugDataParNuma)
                                {
                                  (77970 call chpl_debug_writeln "### chunk = " chunk "  core = " core "  " "locRange = " locRange "  coreRange = "(77968 call chpl_build_bounded_range low high))
                                }
                                (77983 yield(77981 call _build_tuple(77979 call chpl_build_bounded_range low high)))
                              }
                              (78120 call _downEndCount _coforallCount[78117] nil[44])
                              (78119 'coforall loop')
                            }
                            label _continueLabel[78130]
                            _indexOfInterest[78125]
                            _iterator[78126]
                          }
                          label _breakLabel[78131]
                          Defer
                          {
                            {
                              (78162 call _endCountFree _coforallCount[78117])
                            }
                          }
                          (78167 call _waitEndCount _coforallCount[78117] 1)
                        }
                      }
                    }
                    (78674 call _downEndCount _coforallCount[78672] nil[44])
                    (78204 'coforall on block' 1 tmp[78199])
                  }
                }
              }
              label _continueLabel[78684]
              _indexOfInterest[78679]
              _iterator[78680]
            }
            label _breakLabel[78685]
            Defer
            {
              {
                (78716 call _endCountFree _coforallCount[78672])
              }
            }
            (78721 call _waitEndCount _coforallCount[78672] 0)
          }
        }
      }
    }
    {
      { scopeless
        unknown v[78759](78756 call . this c"size")
        (78762 'end of statement')
      }
      { scopeless
        const numChunks[78775] "const"(78772 IfExpr (78766 'task_get_serial') then
        { scopeless
          1
        } else
        { scopeless
          (78771 call _computeNumChunks v)
        } )
        (78778 'end of statement')
      }
      if(78828 call _cond_test debugChapelRange)
      {
        (78786 call chpl_debug_writeln "*** RI: length=" v " numChunks=" numChunks)
        (78826 call chpl_debug_writeln "*** RI: Using " numChunks " chunk(s)")
      }
      if(79133 call _cond_test(78834 call == numChunks 1))
      {
        { scopeless
          (78845 yield(78843 call _build_tuple(78841 call chpl_build_bounded_range 0(78839 call - v 1))))
        }
      }
      {
        {
          unknown tmpIter[78924] "expr temp" "maybe ref" "no copy" "temp"
          (78927 'move' tmpIter[78924](78852 call #(78849 call chpl_build_low_bounded_range 0) numChunks))
          unknown isRngDomArr[79113] "maybe param" "temp"
          (79128 'move' isRngDomArr[79113](79126 call ||(79115 call isBoundedRange tmpIter[78924])(79124 call ||(79118 call isDomain tmpIter[78924])(79121 call isArray tmpIter[78924]))))
          if isRngDomArr[79113]
          {
            const _coforallCount[78980] "const" "end count" "temp"
            (79049 'move' _coforallCount[78980](79046 call _endCountAlloc 1))
            unknown numTasks[78981] "temp"
            (79033 'move' numTasks[78981](79029 call . tmpIter[78924] c"size"))
            (79024 call _upEndCount _coforallCount[78980] 1 numTasks[78981])
            (79021 call chpl_resetTaskSpawn numTasks[78981])
            unknown _indexOfInterest[78988] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
            unknown _iterator[78989] "expr temp" "temp"
            (78998 'move' _iterator[78989](78996 call _getIterator tmpIter[78924]))
            Defer
            {
              {
                (79014 call _freeIterator _iterator[78989])
              }
            }
            { scopeless type
              (79003 'move' _indexOfInterest[78988](79000 call iteratorIndex _iterator[78989]))
            }
            ForLoop[78990]
            {
              unknown chunk[79007] "coforall index var" "index var" "insert auto destroy"
              (79009 'move' chunk[79007] _indexOfInterest[78988])
              {
                {
                  { scopeless
                    const tmp[78931] "const" "temp"(78933 call _computeBlock v numChunks chunk(78938 call - v 1))
                    (78943 call _check_tuple_var_decl tmp[78931] 2)
                    const lo[78946] "const"(78948 call tmp[78931] 0)
                    const hi[78951] "const"(78953 call tmp[78931] 1)
                    (78956 'end of statement')
                  }
                  if(78958 call _cond_test debugChapelRange)
                  {
                    { scopeless
                      (78963 call chpl_debug_writeln "*** RI: tuple = "(78966 call _build_tuple(78968 call chpl_build_bounded_range lo hi)))
                    }
                  }
                  (78972 yield(78974 call _build_tuple(78976 call chpl_build_bounded_range lo hi)))
                }
                (78983 call _downEndCount _coforallCount[78980] nil[44])
                (78982 'coforall loop')
              }
              label _continueLabel[78993]
              _indexOfInterest[78988]
              _iterator[78989]
            }
            label _breakLabel[78994]
            Defer
            {
              {
                (79036 call _endCountFree _coforallCount[78980])
              }
            }
            (79041 call _waitEndCount _coforallCount[78980] 1 numTasks[78981])
          }
          {
            const _coforallCount[79053] "const" "end count" "temp"
            (79110 'move' _coforallCount[79053](79107 call _endCountAlloc 1))
            unknown _indexOfInterest[79061] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
            unknown _iterator[79062] "expr temp" "temp"
            (79071 'move' _iterator[79062](79069 call _getIterator tmpIter[78924]))
            Defer
            {
              {
                (79087 call _freeIterator _iterator[79062])
              }
            }
            { scopeless type
              (79076 'move' _indexOfInterest[79061](79073 call iteratorIndex _iterator[79062]))
            }
            ForLoop[79063]
            {
              unknown chunk[79080] "coforall index var" "index var" "insert auto destroy"
              (79082 'move' chunk[79080] _indexOfInterest[79061])
              (79094 call _upEndCount _coforallCount[79053] 1)
              {
                {
                  { scopeless
                    const tmp[78869] "const" "temp"(78868 call _computeBlock v numChunks chunk(78866 call - v 1))
                    (78876 call _check_tuple_var_decl tmp[78869] 2)
                    const lo[78854] "const"(78870 call tmp[78869] 0)
                    const hi[78856] "const"(78873 call tmp[78869] 1)
                    (78881 'end of statement')
                  }
                  if(78911 call _cond_test debugChapelRange)
                  {
                    { scopeless
                      (78909 call chpl_debug_writeln "*** RI: tuple = "(78907 call _build_tuple(78905 call chpl_build_bounded_range lo hi)))
                    }
                  }
                  (78922 yield(78920 call _build_tuple(78918 call chpl_build_bounded_range lo hi)))
                }
                (79056 call _downEndCount _coforallCount[79053] nil[44])
                (79055 'coforall loop')
              }
              label _continueLabel[79066]
              _indexOfInterest[79061]
              _iterator[79062]
            }
            label _breakLabel[79067]
            Defer
            {
              {
                (79098 call _endCountFree _coforallCount[79053])
              }
            }
            (79103 call _waitEndCount _coforallCount[79053] 1)
          }
        }
      }
    }
  }
  where {
    (77333 call == tag(77330 call . iterKind c"leader"))
  }
  function _unknown[51].these[79152](arg _mt[79159]:_MT[238], arg this[79156] :
  range, param arg tag[79149] :
  iterKind, arg followThis[79154]:_any[178](?)) : _unknown[51] "iterator fn" "method" "no doc"
  {
    if(79185 call _cond_test(79175 call && boundsChecking(79174 call(79170 call . this c"isAmbiguous"))))
    {
      { scopeless
        (79183 call(79178 call . HaltWrappers c"boundsCheckHalt") "these -- Attempt to iterate over a range with ambiguous alignment.")
      }
    }
    if(79203 call _cond_test(79196 call == boundedType(79193 call . BoundedRangeType c"boundedNone")))
    {
      { scopeless
        (79201 call compilerError "iteration over a range with no bounds")
      }
    }
    if(79241 call _cond_test(79218 call &&(79209 call ! stridable)(79216 call == boundedType(79213 call . BoundedRangeType c"boundedHigh"))))
    {
      { scopeless
        (79239 call compilerError "iteration over a range with no first index")
      }
    }
    if(79274 call _cond_test(79251 call !=(79247 call . followThis c"size") 1))
    {
      { scopeless
        (79272 call compilerError "iteration over a range with multi-dimensional iterator")
      }
    }
    if(79302 call _cond_test debugChapelRange)
    {
      { scopeless
        (79300 call chpl_debug_writeln "In range follower code: Following " followThis)
      }
    }
    { scopeless
      unknown myFollowThis[79311](79310 call followThis 0)
      (79314 'end of statement')
    }
    if(79338 call _cond_test debugChapelRange)
    {
      { scopeless
        (79336 call chpl_debug_writeln "Range = " myFollowThis)
      }
    }
    if(79412 call _cond_test(79352 call && boundsChecking(79350 call !(79349 call(79345 call . this c"hasFirst")))))
    {
      if(79407 call _cond_test(79359 call(79355 call . this c"isEmpty")))
      {
        if(79392 call _cond_test(79366 call !(79365 call(79361 call . myFollowThis c"isEmpty"))))
        {
          { scopeless
            (79390 call(79369 call . HaltWrappers c"boundsCheckHalt") "size mismatch in zippered iteration")
          }
        }
      }
      {
        (79404 call(79399 call . HaltWrappers c"boundsCheckHalt") "iteration over a range with no first index")
      }
    }
    if(79475 call _cond_test(79425 call && boundsChecking(79423 call !(79422 call(79418 call . myFollowThis c"hasFirst")))))
    {
      if(79469 call _cond_test(79443 call !(79441 call &&(79433 call !(79432 call(79428 call . myFollowThis c"isAmbiguous")))(79440 call(79436 call . myFollowThis c"isEmpty")))))
      {
        { scopeless
          (79467 call(79446 call . HaltWrappers c"boundsCheckHalt") "zippered iteration over a range with no first index")
        }
      }
    }
    if(80147 call _cond_test(79497 call ||(79489 call &&(79482 call isBoundedRange myFollowThis)(79487 call !(79484 call . myFollowThis c"stridable")))(79496 call(79492 call . myFollowThis c"hasLast"))))
    {
      { scopeless
        const flwlen[79503] "const"(79500 call . myFollowThis c"size")
        (79506 'end of statement')
      }
      if(79586 call _cond_test(79515 call && boundsChecking(79514 call(79510 call . this c"hasLast"))))
      {
        if(79580 call _cond_test(79520 call isBoundedRange this))
        {
          if(79552 call _cond_test(79526 call <(79522 call . this c"size") flwlen))
          {
            { scopeless
              (79550 call(79529 call . HaltWrappers c"boundsCheckHalt") "zippered iteration over a range with too few indices")
            }
          }
        }
        {
          { scopeless
            (79578 call assert 0 "hasFirst && hasLast do not imply isBoundedRange")
          }
        }
      }
      if(79936 call _cond_test(79598 call ||(79591 call . this c"stridable")(79595 call . myFollowThis c"stridable")))
      {
        { scopeless
          unknown r[79619](79617 call chpl_by(79608 call chpl_build_bounded_range(79603 call chpl_intToIdx 1)(79607 call chpl_intToIdx 0))(79615 call _cast(79614 call chpl__rangeStrideType intIdxType) 1))
          (79622 'end of statement')
        }
        if(79728 call _cond_test(79626 call != flwlen 0))
        {
          { scopeless
            const stride[79638] "const"(79636 call *(79629 call . this c"stride")(79633 call . myFollowThis c"stride"))
            (79641 'end of statement')
          }
          { scopeless
            unknown low[79653](79652 call(79644 call . this c"orderToIndex")(79648 call . myFollowThis c"first"))
            (79656 'end of statement')
          }
          { scopeless
            unknown high[79679](79678 call chpl_intToIdx(79675 call +(79663 call _cast strType(79661 call chpl__idxToInt low))(79673 call * stride(79671 call _cast strType(79668 call - flwlen 1)))))
            (79682 'end of statement')
          }
          (79698 call assert(79695 call == high(79694 call(79686 call . this c"orderToIndex")(79690 call . myFollowThis c"last"))))
          if(79709 call _cond_test(79702 call < stride 0))
          {
            { scopeless
              (79706 call <=> low high)
            }
          }
          (79725 call = r(79723 call chpl_by(79717 call chpl_build_bounded_range low high)(79721 call _cast strType stride)))
        }
        if(79755 call _cond_test debugChapelRange)
        {
          { scopeless
            (79753 call chpl_debug_writeln "Expanded range = " r)
          }
        }
        {
          unknown _indexOfInterest[79765] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[79766] "expr temp" "temp"
          (79775 'move' _iterator[79766](79773 call _getIterator r))
          Defer
          {
            {
              (79791 call _freeIterator _iterator[79766])
            }
          }
          { scopeless type
            (79780 'move' _indexOfInterest[79765](79777 call iteratorIndex _iterator[79766]))
          }
          ForLoop[79767]
          {
            unknown i[79784] "index var" "insert auto destroy"
            (79786 'move' i[79784] _indexOfInterest[79765])
            { scopeless
              (79763 yield i)
            }
            label _continueLabel[79770]
            _indexOfInterest[79765]
            _iterator[79766]
          }
          label _breakLabel[79771]
        }
      }
      {
        { scopeless
          unknown r[79810](79808 call chpl_build_bounded_range(79802 call chpl__intToIdx idxType 1)(79807 call chpl__intToIdx idxType 0))
          (79813 'end of statement')
        }
        if(79882 call _cond_test(79817 call != flwlen 0))
        {
          { scopeless
            const low[79829] "const"(79828 call(79820 call . this c"orderToIndex")(79824 call . myFollowThis c"first"))
            (79832 'end of statement')
          }
          { scopeless
            const high[79853] "const"(79852 call chpl_intToIdx(79849 call +(79840 call _cast strType(79838 call chpl__idxToInt low))(79847 call _cast strType(79844 call - flwlen 1))))
            (79856 'end of statement')
          }
          (79872 call assert(79869 call == high(79868 call(79860 call . this c"orderToIndex")(79864 call . myFollowThis c"last"))))
          (79879 call = r(79877 call chpl_build_bounded_range low high))
        }
        if(79893 call _cond_test debugChapelRange)
        {
          { scopeless
            (79891 call chpl_debug_writeln "Expanded range = " r)
          }
        }
        {
          unknown _indexOfInterest[79903] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[79904] "expr temp" "temp"
          (79913 'move' _iterator[79904](79911 call _getIterator r))
          Defer
          {
            {
              (79929 call _freeIterator _iterator[79904])
            }
          }
          { scopeless type
            (79918 'move' _indexOfInterest[79903](79915 call iteratorIndex _iterator[79904]))
          }
          ForLoop[79905]
          {
            unknown i[79922] "index var" "insert auto destroy"
            (79924 'move' i[79922] _indexOfInterest[79903])
            { scopeless
              (79901 yield i)
            }
            label _continueLabel[79908]
            _indexOfInterest[79903]
            _iterator[79904]
          }
          label _breakLabel[79909]
        }
      }
    }
    {
      if(79977 call _cond_test(79947 call && boundsChecking(79946 call(79942 call . this c"hasLast"))))
      {
        { scopeless
          (79975 call(79952 call . HaltWrappers c"zipLengthHalt") "zippered iteration where a bounded range follows an unbounded iterator")
        }
      }
      { scopeless
        const first[79993] "const"(79992 call(79984 call . this c"orderToIndex")(79988 call . myFollowThis c"first"))
        (79996 'end of statement')
      }
      { scopeless
        const stride[80007] "const"(80005 call *(79998 call . this c"stride")(80002 call . myFollowThis c"stride"))
        (80010 'end of statement')
      }
      if(80143 call _cond_test(80013 call > stride 0))
      {
        { scopeless
          const r[80024] "const"(80022 call chpl_by(80016 call chpl_build_low_bounded_range first)(80020 call _cast strType stride))
          (80027 'end of statement')
        }
        if(80036 call _cond_test debugChapelRange)
        {
          { scopeless
            (80034 call chpl_debug_writeln "Expanded range = " r)
          }
        }
        {
          unknown _indexOfInterest[80046] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[80047] "expr temp" "temp"
          (80056 'move' _iterator[80047](80054 call _getIterator r))
          Defer
          {
            {
              (80072 call _freeIterator _iterator[80047])
            }
          }
          { scopeless type
            (80061 'move' _indexOfInterest[80046](80058 call iteratorIndex _iterator[80047]))
          }
          ForLoop[80048]
          {
            unknown i[80065] "index var" "insert auto destroy"
            (80067 'move' i[80065] _indexOfInterest[80046])
            { scopeless
              (80044 yield i)
            }
            label _continueLabel[80051]
            _indexOfInterest[80046]
            _iterator[80047]
          }
          label _breakLabel[80052]
        }
      }
      {
        { scopeless
          const r[80088] "const"(80086 call chpl_by(80080 call chpl_build_high_bounded_range first)(80084 call _cast strType stride))
          (80091 'end of statement')
        }
        if(80100 call _cond_test debugChapelRange)
        {
          { scopeless
            (80098 call chpl_debug_writeln "Expanded range = " r)
          }
        }
        {
          unknown _indexOfInterest[80110] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[80111] "expr temp" "temp"
          (80120 'move' _iterator[80111](80118 call _getIterator r))
          Defer
          {
            {
              (80136 call _freeIterator _iterator[80111])
            }
          }
          { scopeless type
            (80125 'move' _indexOfInterest[80110](80122 call iteratorIndex _iterator[80111]))
          }
          ForLoop[80112]
          {
            unknown i[80129] "index var" "insert auto destroy"
            (80131 'move' i[80129] _indexOfInterest[80110])
            { scopeless
              (80108 yield i)
            }
            label _continueLabel[80115]
            _indexOfInterest[80110]
            _iterator[80111]
          }
          label _breakLabel[80116]
        }
      }
    }
  }
  where {
    (79166 call == tag(79163 call . iterKind c"follower"))
  }
  function _cast[80160](arg t[80157] :
  string[26], arg x[80166] :
  (80165 call range ?[260])) : _unknown[51]
  {
    { scopeless
      unknown ret[80170] string[26]
      (80173 'end of statement')
    }
    if(80192 call _cond_test(80180 call(80176 call . x c"hasLowBound")))
    {
      { scopeless
        (80189 call += ret(80187 call _cast string[26](80183 call . x c"low")))
      }
    }
    (80215 call += ret "..")
    if(80235 call _cond_test(80223 call(80219 call . x c"hasHighBound")))
    {
      { scopeless
        (80232 call += ret(80230 call _cast string[26](80226 call . x c"high")))
      }
    }
    if(80261 call _cond_test(80245 call !=(80241 call . x c"stride") 1))
    {
      { scopeless
        (80258 call += ret(80256 call + " by "(80254 call _cast string[26](80250 call . x c"stride"))))
      }
    }
    { scopeless
      unknown alignCheckRange[80267] x
      (80270 'end of statement')
    }
    (80278 call(80274 call . alignCheckRange c"normalizeAlignment"))
    if(80330 call _cond_test(80288 call !(80287 call(80283 call . alignCheckRange c"isNaturallyAligned"))))
    {
      { scopeless
        (80327 call += ret(80325 call + " align "(80323 call _cast string[26](80321 call chpl__mod(80315 call chpl__idxToInt(80311 call . x c"alignment"))(80318 call . x c"stride")))))
      }
    }
    (80336 return ret)
  }
  function _unknown[51].normalizeAlignment[80343](arg _mt[80348]:_MT[238], ref arg this[80345] :
  range) : _unknown[51] "method" "no doc"
  {
    if(80406 call _cond_test(80354 call && stridable(80352 call ! aligned)))
    {
      (80402 call = _alignment(80399 IfExpr (80360 call isBoundedRange this) then
      { scopeless(80367 IfExpr (80363 call > stride 0) then
        { scopeless
          _low
        } else
        { scopeless
          _high
        } )
      } else
      { scopeless(80396 IfExpr (80378 call ==(80371 call . this c"boundedType")(80375 call . BoundedRangeType c"boundedLow")) then
        { scopeless
          _low
        } else
        { scopeless(80393 IfExpr (80389 call ==(80382 call . this c"boundedType")(80386 call . BoundedRangeType c"boundedHigh")) then
          { scopeless
            _high
          } else
          { scopeless
            0
          } )
        } )
      } ))
    }
  }
  function _unknown[51].chpl__unTranslate[80420](arg _mt[80425]:_MT[238], arg this[80422] :
  range, arg i[80417] :
  intIdxType) : _unknown[51] "inline" "method" "no doc"
  {
    { scopeless
      (80431 return(80429 call - this i))
    }
  }
  function _unknown[51].chpl__unTranslate[80441](arg _mt[80446]:_MT[238], arg this[80443] :
  range, arg i[80439]:_any[178](?)) : _unknown[51] "inline" "method" "no doc"
  {
    if(80468 call _cond_test(80452 call isIntType(80450 'typeof' i)))
    {
      { scopeless
        (80457 return(80455 call - this i))
      }
    }
    {
      { scopeless
        (80466 return(80464 call + this(80463 call abs i)))
      }
    }
  }
  function chpl__hasAlignment[80486](arg r[80483] :
  (80482 call range ?[260])) : _unknown[51]
  {
    if(80506 call _cond_test(80501 call &&(80493 call(80489 call . r c"hasLowBound"))(80499 call >=(80495 call . r c"stride") 2)))
    {
      { scopeless
        (80504 return 1)
      }
    }
    if(80532 call _cond_test(80527 call &&(80517 call(80513 call . r c"hasHighBound"))(80525 call <=(80519 call . r c"stride")(80523 call - 2))))
    {
      { scopeless
        (80530 return 1)
      }
    }
    (80538 return 0)
  }
  function chpl__mod[80548](arg dividend[80545] :
  integral, arg modulus[80551] :
  integral) : _unknown[51]
  {
    { scopeless
      const m[80565] "const"(80564 call(80558 call .(80557 call abs modulus) c"safeCast")(80562 'typeof' dividend))
      (80568 'end of statement')
    }
    { scopeless
      unknown tmp[80574](80572 call % dividend m)
      (80577 'end of statement')
    }
    if(80596 call _cond_test(80581 call isInt dividend))
    {
      { scopeless
        if(80591 call _cond_test(80584 call < tmp 0))
        {
          { scopeless
            (80588 call += tmp m)
          }
        }
      }
    }
    (80602 return tmp)
  }
  function chpl__diffMod[80612](arg minuend[80609] :
  integral, arg subtrahend[80615] :
  integral, arg modulus[80619] :
  integral) : _unknown[51]
  {
    { scopeless
      const m[80641] "const"(80640 call(80634 call .(80633 call abs modulus) c"safeCast")(80638 'typeof' minuend))
      (80644 'end of statement')
    }
    { scopeless
      unknown minMod[80651](80650 call chpl__mod minuend m)
      (80654 'end of statement')
    }
    { scopeless
      unknown subMod[80660](80659 call chpl__mod subtrahend m)
      (80663 'end of statement')
    }
    (80682 return(80679 IfExpr (80666 call < minMod subMod) then
    { scopeless
      (80673 call - m(80671 call - subMod minMod))
    } else
    { scopeless
      (80677 call - minMod subMod)
    } ))
  }
  where {
    (80628 call ==(80625 'typeof' minuend)(80627 'typeof' subtrahend))
  }
  { scopeless type
    (80623 'typeof' minuend)
  }
  function chpl__diffMod[80694](arg minuend[80691] :
  integral, arg subtrahend[80697] :
  integral, arg modulus[80701] :
  integral) : _unknown[51]
  {
    (80723 call compilerError "chpl__diffMod -- Operand types must match.")
  }
  function chpl__add[80735](arg a[80732] :
  unknown t[80730], arg b[80738] :
  t, arg resultType[80741]:_any[178](?)) : _unknown[51]
  {
    if(80770 call _cond_test(80747 call !(80746 call isIntegralType t)))
    {
      { scopeless
        (80768 call compilerError "Values must be of integral type.")
      }
    }
    if(80804 call _cond_test(80796 call &&(80784 call &&(80778 call > a 0)(80782 call > b 0))(80794 call > b(80792 call -(80790 call max t) a))))
    {
      { scopeless
        (80802 return(80801 call max resultType))
      }
    }
    if(80837 call _cond_test(80829 call &&(80817 call &&(80811 call < a 0)(80815 call < b 0))(80827 call < b(80825 call -(80823 call min t) a))))
    {
      { scopeless
        (80835 return(80834 call min resultType))
      }
    }
    if(80922 call _cond_test(80845 call isUintType resultType))
    {
      if(80916 call _cond_test(80908 call ||(80875 call &&(80854 call &&(80848 call < a 0)(80852 call > b 0))(80873 call ||(80861 call == a(80860 call min t))(80871 call >(80866 call abs a)(80870 call abs b))))(80906 call &&(80885 call &&(80879 call > a 0)(80883 call < b 0))(80904 call ||(80892 call == b(80891 call min t))(80902 call >(80897 call abs b)(80901 call abs a))))))
      {
        { scopeless
          (80914 return(80912 call _cast resultType 0))
        }
      }
    }
    (80933 return(80931 call _cast resultType(80928 call + a b)))
  }
  function chpl__addRangeStrides[80941](arg start[80939]:_any[178](?), arg stride[80943]:_any[178](?), arg count[80945]:_any[178](?)) : _unknown[51]
  {
    function convert[80953](arg a[80951]:_any[178](?), arg b[80955]:_any[178](?)) param : _unknown[51]
    {
      { scopeless
        (80995 return(80993 call ||(80973 call &&(80963 call ==(80958 'typeof' a)(80962 call int[13] 64))(80971 call ==(80966 'typeof' b)(80970 call uint[115] 64)))(80991 call &&(80981 call ==(80976 'typeof' a)(80980 call uint[115] 64))(80989 call ==(80984 'typeof' b)(80988 call int[13] 64)))))
      }
    }
    function mul[81005](arg a[81003]:_any[178](?), arg b[81007]:_any[178](?)) : _unknown[51]
    {
      { scopeless
        (81037 return(81034 IfExpr (81013 call convert a b) then
        { scopeless
          (81028 call *(81019 call _cast(81018 call int[13] 64) a)(81026 call _cast(81025 call int[13] 64) b))
        } else
        { scopeless
          (81032 call * a b)
        } ))
      }
    }
    function add[81046](arg a[81044]:_any[178](?), arg b[81048]:_any[178](?)) : _unknown[51]
    {
      { scopeless
        (81078 return(81075 IfExpr (81054 call convert a b) then
        { scopeless
          (81069 call +(81060 call _cast(81059 call int[13] 64) a)(81067 call _cast(81066 call int[13] 64) b))
        } else
        { scopeless
          (81073 call + a b)
        } ))
      }
    }
    (81096 return(81094 call _cast(81093 'typeof' start)(81091 call add start(81090 call mul stride count))))
  }
  { scopeless type
    (80948 'typeof' start)
  }
  function chpl__extendedEuclidHelper[81105](arg u[81103]:_any[178](?), arg v[81107]:_any[178](?)) : _unknown[51]
  {
    { scopeless
      unknown zero[81112] 0(81110 'typeof' u)
      (81115 'end of statement')
    }
    { scopeless
      unknown one[81120] 1(81118 'typeof' u)
      (81123 'end of statement')
    }
    { scopeless
      unknown U[81130](81128 call _build_tuple one zero u)
      (81133 'end of statement')
    }
    { scopeless
      unknown V[81140](81138 call _build_tuple zero one v)
      (81143 'end of statement')
    }
    {
      unknown tmp[81192] "temp"
      (81220 'move' tmp[81192](81213 call _cond_test(81215 call !=(81217 call V 2) 0)))
      WhileDo[81197]
      {
        {
          { scopeless
            unknown oldU[81152] U
            (81155 'end of statement')
          }
          { scopeless
            unknown q[81167](81165 call /(81160 call U 2)(81164 call V 2))
            (81170 'end of statement')
          }
          (81173 call = U V)
          (81189 call = V(81187 call - oldU(81185 call * V(81183 call _build_tuple q q q))))
        }
        label _continueLabel[81195]
        (81208 'move' tmp[81192](81201 call _cond_test(81203 call !=(81205 call V 2) 0)))
        tmp[81192]
      }
      label _breakLabel[81196]
    }
    (81234 return(81232 call _build_tuple(81226 call U 2)(81230 call U 0)))
  }
  function chpl__extendedEuclid[81247](arg u[81244] :
  (81243 call int[13] 32), arg v[81253] :
  (81252 call int[13] 32)) : _unknown[51] "inline"
  {
    (81261 return(81260 call chpl__extendedEuclidHelper u v))
  }
  function chpl__extendedEuclid[81275](arg u[81272] :
  (81271 call int[13] 64), arg v[81281] :
  (81280 call int[13] 64)) : _unknown[51] "inline"
  {
    (81289 return(81288 call chpl__extendedEuclidHelper u v))
  }
  function chpl__rangeIdxTypeError[81298](arg idxType[81296]:_any[178](?)) : _unknown[51] "private"
  {
    (81340 call compilerError "ranges don't support '"(81321 call _cast string[26] idxType) "' as their idxType")
  }
  function chpl__rangeStrideType[81349](arg idxType[81347]:_any[178](?)) type : _unknown[51] "private"
  {
    if(81386 call _cond_test(81354 call isIntegralType idxType))
    {
      (81359 return(81358 call chpl__signedType idxType))
    }
    {
      { scopeless
        if(81382 call _cond_test(81370 call ||(81365 call isEnumType idxType)(81369 call isBoolType idxType)))
        {
          (81373 return int[13])
        }
        {
          (81379 call chpl__rangeIdxTypeError idxType)
        }
      }
    }
  }
  function chpl__rangeUnsignedType[81398](arg idxType[81396]:_any[178](?)) type : _unknown[51] "private"
  {
    if(81435 call _cond_test(81403 call isIntegralType idxType))
    {
      (81408 return(81407 call chpl__unsignedType idxType))
    }
    {
      { scopeless
        if(81431 call _cond_test(81419 call ||(81414 call isEnumType idxType)(81418 call isBoolType idxType)))
        {
          (81422 return uint[115])
        }
        {
          (81428 call chpl__rangeIdxTypeError idxType)
        }
      }
    }
  }
  function chpl__idxTypeToIntIdxType[81447](arg idxType[81445]:_any[178](?)) type : _unknown[51] "no doc"
  {
    if(81506 call _cond_test(81452 call isBoolType idxType))
    {
      (81454 return int[13])
    }
    {
      { scopeless
        if(81502 call _cond_test(81460 call isEnumType idxType))
        {
          if(81489 call _cond_test(81466 call <(81462 call . idxType c"size") 2))
          {
            { scopeless
              (81487 call compilerError "ranges are not currently supported for enums with fewer than two values")
            }
          }
          (81496 return int[13])
        }
        {
          (81499 return idxType)
        }
      }
    }
  }
  function _unknown[51].chpl_intToIdx[81519](arg _mt[81524]:_MT[238], arg this[81521] :
  range, arg i[81517]:_any[178](?)) : _unknown[51] "inline" "method" "no doc"
  {
    (81534 return(81533 call chpl__intToIdx(81528 call . this c"idxType") i))
  }
  function chpl__intToIdx[81545](arg idxType[81542] :
  integral, arg i[81548] :
  integral) : _unknown[51] "inline"
  {
    if(81565 call _cond_test(81554 call ==(81552 'typeof' i) idxType))
    {
      { scopeless
        (81557 return i)
      }
    }
    {
      { scopeless
        (81563 return(81561 call _cast idxType i))
      }
    }
  }
  function chpl__intToIdx[81580](arg idxType[81577] :
  integral, param arg i[81583] :
  integral) : _unknown[51] "inline"
  {
    if(81600 call _cond_test(81589 call ==(81587 'typeof' i) idxType))
    {
      { scopeless
        (81592 return i)
      }
    }
    {
      { scopeless
        (81598 return(81596 call _cast idxType i))
      }
    }
  }
  function chpl__intToIdx[81615](arg idxType[81612] :
  enum[187](?), arg i[81618] :
  integral) : _unknown[51] "inline"
  {
    (81626 return(81625 call chpl__orderToEnum i idxType))
  }
  function chpl__intToIdx[81635](arg idxType[81633]:_any[178](?), arg i[81638] :
  integral) : _unknown[51] "inline"
  {
    (81649 return(81647 call _cast bool[10] i))
  }
  where {
    (81644 call isBoolType idxType)
  }
  function chpl__intToIdx[81659](arg idxType[81657]:_any[178](?), param arg i[81662] :
  integral) param : _unknown[51] "inline"
  {
    (81673 return(81671 call _cast bool[10] i))
  }
  where {
    (81668 call isBoolType idxType)
  }
  function chpl__intToIdx[81683](arg idxType[81681]:_any[178](?), arg i[81686] :
  nothing[7]) : _unknown[51] "inline"
  {
    (81690 return none[57])
  }
  function chpl__idxToInt[81701](arg i[81698] :
  integral) : _unknown[51] "inline"
  {
    (81704 return i)
  }
  function chpl__idxToInt[81715](param arg i[81712] :
  integral) param : _unknown[51] "inline"
  {
    (81718 return i)
  }
  function chpl__idxToInt[81729](arg i[81726] :
  enum[187](?)) : _unknown[51] "inline"
  {
    (81735 return(81734 call chpl__enumToOrder i))
  }
  function chpl__idxToInt[81746](arg i[81743] :
  bool[10]) : _unknown[51] "inline"
  {
    (81752 return(81750 call _cast int[13] i))
  }
  function chpl__idxToInt[81763](param arg i[81760] :
  bool[10]) param : _unknown[51] "inline"
  {
    (81769 return(81767 call _cast int[13] i))
  }
}