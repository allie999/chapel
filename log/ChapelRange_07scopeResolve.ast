AST dump for ChapelRange after pass scopeResolve.
Module use list: ChapelBase SysBasic HaltWrappers Math DSIUtil 

{
  unknown debugChapelRange[64195] "config" "no doc" "param" 0
  (64198 'end of statement')
  unknown useOptimizedRangeIterators[64200] "config" "no doc" "param" 1
  (64203 'end of statement')
  type BoundedRangeType[64213] def bounded[64205]:BoundedRangeType[64213] def boundedLow[64207]:BoundedRangeType[64213] def boundedHigh[64209]:BoundedRangeType[64213] def boundedNone[64211]:BoundedRangeType[64213]
  {
  }
  function range[64316](?).strType[64294](arg _mt[64320]:_MT[238], arg this[64318]:range[64316](?)) type : _unknown[51] "method" "primary method" "no parens"
  {
    (64300 return(64299 call chpl__rangeStrideType(373687 call . this[64318] c"idxType")))
  }
  function range[64316](?).chpl__promotionType[64307](arg _mt[64324]:_MT[238], arg this[64322]:range[64316](?)) type : _unknown[51] "method" "primary method"
  {
    (64310 return(373692 call . this[64322] c"idxType"))
  }
  type range[64316](?) unknown idxType[64220] "type variable" int(64)[13] unknown boundedType[64230] "param" bounded[64205] BoundedRangeType[64213] unknown stridable[64236] "param" 0 bool[10] unknown _low[64244](64243 call chpl__idxTypeToIntIdxType idxType[64220]) unknown _high[64252](64251 call chpl__idxTypeToIntIdxType idxType[64220]) unknown _stride[64265](64262 IfExpr  stridable[64236] then
  { scopeless
    (64260 call chpl__rangeStrideType idxType[64220])
  } else
  { scopeless
    nothing[7]
  } ) unknown _alignment[64278](64275 IfExpr  stridable[64236] then
  { scopeless
    (64273 call chpl__idxTypeToIntIdxType idxType[64220])
  } else
  { scopeless
    nothing[7]
  } ) unknown _aligned[64288](64285 IfExpr  stridable[64236] then
  { scopeless
    bool[10]
  } else
  { scopeless
    nothing[7]
  } )
  function range[64316](?).intIdxType[64330](arg _mt[64335]:_MT[238], arg this[64332]:range[64316](?) :
  range[64316](?)) type : _unknown[51] "method" "no parens"
  {
    (64341 return(64340 call chpl__idxTypeToIntIdxType(373697 call . this[64332] c"idxType")))
  }
  function range[64316](?).init[64353](arg _mt[64418]:_MT[238], arg this[64415]:range[64316](?) :
  range[64316](?), arg idxType[64350]:_any[178](?) =
  int(64)[13], param arg boundedType[64360] :
  BoundedRangeType[64213] =
  bounded[64205], param arg stridable[64366] :
  bool[10] =
  0, arg _low[64376] :
  idxType[64350] =
  (64375 call chpl__intToIdx idxType[64350] 1), arg _high[64386] :
  idxType[64350] =
  (64385 call chpl__intToIdx idxType[64350] 0), arg _stride[64395] :
  (64393 call chpl__rangeStrideType idxType[64350]) =
  1, arg _alignment[64405] :
  idxType[64350] =
  (64404 call chpl__intToIdx idxType[64350] 0), arg _aligned[64411] :
  bool[10] =
  0) : _unknown[51] "method" "no doc" "no return value for void"
  {
    (64425 call =(64421 call . this[64415] c"idxType") idxType[64350])
    (64436 call =(64432 call . this[64415] c"boundedType") boundedType[64360])
    (64444 call =(64440 call . this[64415] c"stridable") stridable[64366])
    (64457 call =(64450 call . this[64415] c"_low")(64456 call chpl__idxToInt _low[64376]))
    (64470 call =(64463 call . this[64415] c"_high")(64469 call chpl__idxToInt _high[64386]))
    (64478 call(64474 call . this[64415] c"complete"))
    if(64515 call _cond_test stridable[64366])
    {
      (64488 call =(64484 call . this[64415] c"_stride") _stride[64395])
      (64502 call =(64495 call . this[64415] c"_alignment")(64501 call chpl__idxToInt _alignment[64405]))
      (64512 call =(64508 call . this[64415] c"_aligned") _aligned[64411])
    }
    if(64533 call _cond_test(64523 call &&(64520 call ! stridable[64366]) 1))
    {
      (64531 call assert(64528 call == _stride[64395] 1))
    }
  }
  function _isAnyNothing[64546](arg args[64543]:_any[178](?) ...) param : _unknown[51] "private"
  {
    {
      unknown i[64576] 0
      unknown tmp[64577] "maybe param" "temp"
      (64589 'move' tmp[64577](64587 call chpl_compute_low_param_loop_bound 0(64555 call -(64551 call . args[64543] c"size") 1)))
      unknown tmp[64578] "maybe param" "temp"
      (64602 'move' tmp[64578](64600 call chpl_compute_high_param_loop_bound 0(64594 call -(64596 call . args[64543] c"size") 1)))
      unknown tmp[64579] "maybe param" "temp"
      (64605 'move' tmp[64579] 1)
      ParamForLoop[64607]
      { i[64576] tmp[64577] tmp[64578] tmp[64579]
        {
          if(64570 call _cond_test(64566 call isNothingType(64564 'typeof'(64563 call args[64543] i[64576]))))
          {
            (64568 return 1)
          }
        }
      }
      label _unused_continueLabel[64581]
      label _breakLabel[64580]
    }
    (64618 return 0)
  }
  { scopeless type
    bool[10]
  }
  function range[64316](?).init[64630](arg _mt[64676]:_MT[238], arg this[64673]:range[64316](?) :
  range[64316](?), arg idxType[64627]:_any[178](?) =
  int(64)[13], param arg boundedType[64637] :
  BoundedRangeType[64213] =
  bounded[64205], param arg stridable[64643] :
  bool[10] =
  0, arg _low[64653] :
  idxType[64627] =
  (64652 call chpl__intToIdx idxType[64627] 1), arg _high[64663] :
  idxType[64627] =
  (64662 call chpl__intToIdx idxType[64627] 0), arg _stride[64667]:_any[178](?), arg _alignment[64669]:_any[178](?), arg _aligned[64671]:_any[178](?)) : _unknown[51] "method" "no doc" "no return value for void"
  {
    (64689 call =(64685 call . this[64673] c"idxType") idxType[64627])
    (64698 call =(64694 call . this[64673] c"boundedType") boundedType[64637])
    (64706 call =(64702 call . this[64673] c"stridable") stridable[64643])
    (64717 call =(64710 call . this[64673] c"_low")(64716 call chpl__idxToInt _low[64653]))
    (64728 call =(64721 call . this[64673] c"_high")(64727 call chpl__idxToInt _high[64663]))
    (64736 call(64732 call . this[64673] c"complete"))
    if(64760 call _cond_test stridable[64643])
    {
      (64758 call compilerError "non-stridable range initializer called with stridable=true")
    }
  }
  where {
    (64683 call _isAnyNothing _stride[64667] _alignment[64669] _aligned[64671])
  }
  function range[64316](?).init=[64783](arg _mt[64788]:_MT[238], arg this[64785]:range[64316](?) :
  range[64316](?), arg other[64780] :
  (64779 call range[64316](?) unknown i[64772] unknown b[64775] unknown s[64777])) : _unknown[51] "method" "no doc" "no return value for void"
  {
    unknown idxType[64807] "type variable"(64804 IfExpr (64796 call ==(64792 call .(64791 'typeof' this[64785]) c"idxType") ?[260]) then
    { scopeless
      i[64772]
    } else
    { scopeless
      (64801 call .(64800 'typeof' this[64785]) c"idxType")
    } )
    unknown boundedType[64828] "param"(64825 IfExpr (64817 call ==(64813 call .(64812 'typeof' this[64785]) c"boundedType") ?[260]) then
    { scopeless
      b[64775]
    } else
    { scopeless
      (64822 call .(64821 'typeof' this[64785]) c"boundedType")
    } )
    (64831 'end of statement')
    unknown stridable[64849] "param"(64846 IfExpr (64838 call ==(64834 call .(64833 'typeof' this[64785]) c"stridable") ?[260]) then
    { scopeless
      s[64777]
    } else
    { scopeless
      (64843 call .(64842 'typeof' this[64785]) c"stridable")
    } )
    (64852 'end of statement')
    if(64917 call _cond_test(64855 call != boundedType[64828] b[64775]))
    {
      (64914 call compilerError(64911 call +(64908 call +(64902 call +(64883 call + "range(boundedType="(64881 call _cast string[26](64877 call .(64876 'typeof' this[64785]) c"boundedType"))) ") cannot be initialized from range(boundedType=")(64906 call _cast string[26] b[64775])) ")"))
    }
    if(64948 call _cond_test(64925 call &&(64922 call ! stridable[64849]) s[64777]))
    {
      (64946 call compilerError "cannot initialize a non-stridable range from a stridable range")
    }
    const str[64971] "const"(64968 IfExpr (64955 call && stridable[64849] s[64777]) then
    { scopeless
      (64958 call . other[64780] c"stride")
    } else
    { scopeless
      (64966 call _cast(64965 call chpl__rangeStrideType idxType[64807]) 1)
    } )
    (64974 'end of statement')
    (65019 call(64976 call . this[64785] c"init") idxType[64807] boundedType[64828] stridable[64849](64990 call chpl__intToIdx idxType[64807](64987 call . other[64780] c"_low"))(64998 call chpl__intToIdx idxType[64807](64995 call . other[64780] c"_high")) str[64971](65012 call chpl__intToIdx idxType[64807](65011 call chpl__idxToInt(65007 call . other[64780] c"alignment")))(65016 call . other[64780] c"aligned"))
  }
  function range[64316](?).displayRepresentation[65048](arg _mt[65053]:_MT[238], arg this[65050]:range[64316](?) :
  range[64316](?), arg msg[65044] :
  string[26] =
  "") : _unknown[51] "method" "no doc" "no return value for void"
  {
    (65149 call chpl_debug_writeln msg[65044] "("(65078 call _cast string[26](373765 call . this[65050] c"idxType")) ","(373770 call . this[65050] c"boundedType") ","(373775 call . this[65050] c"stridable") " : "(373779 call . this[65050] c"low") ","(373783 call . this[65050] c"high") ","(373787 call . this[65050] c"stride") ","(65145 IfExpr (373791 call . this[65050] c"aligned") then
    { scopeless
      (65126 call _cast string[26](373795 call . this[65050] c"alignment"))
    } else
    { scopeless
      "\?"
    } ) ")")
  }
  { scopeless type
    void[4]
  }
  function chpl_build_bounded_range[65165](arg low[65162] :
  (65161 call int(64)[13] unknown w[65158]), arg high[65171] :
  (65170 call int(64)[13] w[65158])) : _unknown[51]
  {
    (65186 return(65174 'new'(65185 call range[64316](?)(65179 call int(64)[13] w[65158])(_low = low[65162])(_high = high[65171]))))
  }
  function chpl_build_bounded_range[65201](arg low[65198] :
  (65197 call uint(64)[115] unknown w[65194]), arg high[65207] :
  (65206 call uint(64)[115] w[65194])) : _unknown[51]
  {
    (65222 return(65210 'new'(65221 call range[64316](?)(65215 call uint(64)[115] w[65194])(_low = low[65198])(_high = high[65207]))))
  }
  function chpl_build_bounded_range[65233](arg low[65230] :
  enum[187](?), arg high[65236] :
  enum[187](?)) : _unknown[51]
  {
    if(65266 call _cond_test(65243 call !=(65240 'typeof' low[65230])(65242 'typeof' high[65236])))
    {
      (65264 call compilerError "ranges of enums must use a single enum type")
    }
    (65282 return(65272 'new'(65281 call range[64316](?)(65275 'typeof' low[65230])(_low = low[65230])(_high = high[65236]))))
  }
  function chpl_build_bounded_range[65292](arg low[65289] :
  bool[10], arg high[65295] :
  bool[10]) : _unknown[51]
  {
    (65307 return(65298 'new'(65306 call range[64316](?) bool[10](_low = low[65289])(_high = high[65295]))))
  }
  function chpl_build_bounded_range[65316](arg low[65314]:_any[178](?), arg high[65318]:_any[178](?)) : _unknown[51] "no return value for void"
  {
    (65339 call compilerError "Bounds of 'low..high' must be integers of compatible types.")
  }
  function chpl_build_low_bounded_range[65350](arg low[65347] :
  integral[199](?)) : _unknown[51]
  {
    (65364 return(65352 'new'(65363 call range[64316](?)(65355 'typeof' low[65347]) boundedLow[64207](_low = low[65347]))))
  }
  function chpl_build_low_bounded_range[65375](arg low[65372] :
  enum[187](?)) : _unknown[51]
  {
    (65389 return(65377 'new'(65388 call range[64316](?)(65380 'typeof' low[65372]) boundedLow[64207](_low = low[65372]))))
  }
  function chpl_build_low_bounded_range[65400](arg low[65397] :
  bool[10]) : _unknown[51]
  {
    (65414 return(65402 'new'(65413 call range[64316](?)(65405 'typeof' low[65397]) boundedLow[64207](_low = low[65397]))))
  }
  function chpl_build_low_bounded_range[65423](arg low[65421]:_any[178](?)) : _unknown[51] "no return value for void"
  {
    (65444 call compilerError "Bound of 'low..' must be an integer")
  }
  function chpl_build_high_bounded_range[65455](arg high[65452] :
  integral[199](?)) : _unknown[51]
  {
    (65469 return(65457 'new'(65468 call range[64316](?)(65460 'typeof' high[65452]) boundedHigh[64209](_high = high[65452]))))
  }
  function chpl_build_high_bounded_range[65480](arg high[65477] :
  enum[187](?)) : _unknown[51]
  {
    (65494 return(65482 'new'(65493 call range[64316](?)(65485 'typeof' high[65477]) boundedHigh[64209](_high = high[65477]))))
  }
  function chpl_build_high_bounded_range[65505](arg high[65502] :
  bool[10]) : _unknown[51]
  {
    (65519 return(65507 'new'(65518 call range[64316](?)(65510 'typeof' high[65502]) boundedHigh[64209](_high = high[65502]))))
  }
  function chpl_build_high_bounded_range[65528](arg high[65526]:_any[178](?)) : _unknown[51] "no return value for void"
  {
    (65549 call compilerError "Bound of '..high' must be an integer.")
  }
  function chpl_build_unbounded_range[65556]() : _unknown[51]
  {
    (65569 return(65558 'new'(65568 call range[64316](?) int(64)[13] boundedNone[64211])))
  }
  function chpl_compute_low_param_loop_bound[65584](param arg low[65581] :
  (65580 call int(64)[13] unknown w[65577]), param arg high[65590] :
  (65589 call int(64)[13] w[65577])) param : _unknown[51]
  {
    (65594 return low[65581])
  }
  function chpl_compute_high_param_loop_bound[65609](param arg low[65606] :
  (65605 call int(64)[13] unknown w[65602]), param arg high[65615] :
  (65614 call int(64)[13] w[65602])) param : _unknown[51]
  {
    (65619 return high[65615])
  }
  function chpl_compute_low_param_loop_bound[65634](param arg low[65631] :
  (65630 call uint(64)[115] unknown w[65627]), param arg high[65640] :
  (65639 call uint(64)[115] w[65627])) param : _unknown[51]
  {
    (65644 return low[65631])
  }
  function chpl_compute_high_param_loop_bound[65659](param arg low[65656] :
  (65655 call uint(64)[115] unknown w[65652]), param arg high[65665] :
  (65664 call uint(64)[115] w[65652])) param : _unknown[51]
  {
    (65669 return high[65665])
  }
  function chpl_compute_low_param_loop_bound[65680](param arg low[65677] :
  bool[10], param arg high[65683] :
  bool[10]) param : _unknown[51]
  {
    (65687 return low[65677])
  }
  function chpl_compute_high_param_loop_bound[65698](param arg low[65695] :
  bool[10], param arg high[65701] :
  bool[10]) param : _unknown[51]
  {
    (65705 return high[65701])
  }
  function chpl_compute_low_param_loop_bound[65714](param arg low[65712]:_any[178](?), param arg high[65716]:_any[178](?)) param : _unknown[51] "last resort" "no return value for void"
  {
    (65739 call compilerError "Range bounds must be integers of compatible types in param for-loops")
  }
  function chpl_compute_low_param_loop_bound[65748](arg low[65746]:_any[178](?), arg high[65750]:_any[178](?)) : _unknown[51] "last resort" "no return value for void"
  {
    (65771 call compilerError "param for-loops must be defined over a bounded param range")
  }
  function chpl_compute_count_param_loop[65782](param arg count[65779] :
  integral[199](?)) param : _unknown[51]
  {
    (65785 return count[65779])
  }
  function chpl_compute_count_param_loop[65794](arg count[65792]:_any[178](?)) : _unknown[51] "last resort" "no return value for void"
  {
    (65817 call compilerError "in a param for-loop, the count operator requires a param integral value")
  }
  function chpl_low_bound_count_for_param_loop[65828](param arg high[65825] :
  integral[199](?), param arg count[65831] :
  integral[199](?)) param : _unknown[51]
  {
    if(65885 call _cond_test(65836 call > count[65831] 0))
    {
      (65857 call compilerError "count operators with positive count require the range to have a low bound")
    }
    {
      if(65881 call _cond_test(65862 call == count[65831] 0))
      {
        (65868 return(65866 call + high[65825] 1))
      }
      {
        (65878 return(65876 call +(65873 call + high[65825] count[65831]) 1))
      }
    }
  }
  function chpl_low_bound_count_for_param_loop[65897](arg high[65895]:_any[178](?), arg count[65899]:_any[178](?)) : _unknown[51] "last resort" "no return value for void"
  {
    (65904 call compilerError "Range bounds must be integers of compatible types in param for-loops")
  }
  function chpl_high_bound_count_for_param_loop[65915](param arg low[65912] :
  integral[199](?), param arg count[65918] :
  integral[199](?)) param : _unknown[51]
  {
    if(65974 call _cond_test(65923 call < count[65918] 0))
    {
      (65946 call compilerError "count operators with negative count require the range to have a high bound")
    }
    {
      if(65970 call _cond_test(65951 call == count[65918] 0))
      {
        (65957 return(65955 call - low[65912] 1))
      }
      {
        (65967 return(65965 call -(65962 call + low[65912] count[65918]) 1))
      }
    }
  }
  function chpl_high_bound_count_for_param_loop[65986](arg low[65984]:_any[178](?), arg count[65988]:_any[178](?)) : _unknown[51] "last resort" "no return value for void"
  {
    (65993 call compilerError "Range bounds must be integers of compatible types in param for-loops")
  }
  function chpl_bounded_count_for_param_loop_low[66004](param arg low[66001] :
  integral[199](?), param arg high[66007] :
  integral[199](?), param arg count[66011] :
  integral[199](?)) param : _unknown[51]
  {
    unknown abs_count[66025] "param"(66022 IfExpr (66016 call < count[66011] 0) then
    { scopeless
      (66019 call - count[66011])
    } else
    { scopeless
      count[66011]
    } )
    (66028 'end of statement')
    unknown size[66037] "param"(66035 call +(66032 call - high[66007] low[66001]) 1)
    (66040 'end of statement')
    if(66130 call _cond_test(66043 call < size[66037] abs_count[66025]))
    {
      (66089 call compilerError "Count of "(66066 call _cast string[26] abs_count[66025]) " is too small for range of size "(66087 call _cast string[26] size[66037]))
    }
    {
      if(66125 call _cond_test(66094 call == count[66011] 0))
      {
        (66100 return(66098 call + high[66007] 1))
      }
      {
        if(66121 call _cond_test(66105 call < count[66011] 0))
        {
          (66114 return(66112 call +(66109 call + high[66007] count[66011]) 1))
        }
        {
          (66118 return low[66001])
        }
      }
    }
  }
  function chpl_bounded_count_for_param_loop_low[66141](arg low[66139]:_any[178](?), arg high[66143]:_any[178](?), arg count[66145]:_any[178](?)) : _unknown[51] "last resort" "no return value for void"
  {
    (66168 call compilerError "Range bounds and counts must be integers of compatible types in param for-loops")
  }
  function chpl_bounded_count_for_param_loop_high[66179](param arg low[66176] :
  integral[199](?), param arg high[66182] :
  integral[199](?), param arg count[66186] :
  integral[199](?)) param : _unknown[51]
  {
    if(66222 call _cond_test(66191 call == count[66186] 0))
    {
      (66197 return(66195 call - low[66176] 1))
    }
    {
      if(66218 call _cond_test(66202 call < count[66186] 0))
      {
        (66205 return high[66182])
      }
      {
        (66215 return(66213 call -(66210 call + low[66176] count[66186]) 1))
      }
    }
  }
  function chpl_bounded_count_for_param_loop_high[66234](arg low[66232]:_any[178](?), arg high[66236]:_any[178](?), arg count[66238]:_any[178](?)) : _unknown[51] "last resort" "no return value for void"
  {
    (66243 call compilerError "Range bounds and counts must be integers of compatible types in param for-loops")
  }
  function isRangeType[66252](arg t[66250]:_any[178](?)) param : _unknown[51]
  {
    function isRangeHelp[66263](arg t[66260] :
    (66259 call range[64316](?) ?[260])) param : _unknown[51]
    {
      (66266 return 1)
    }
    function isRangeHelp[66276](arg t[66274]:_any[178](?)) param : _unknown[51]
    {
      (66279 return 0)
    }
    (66288 return(66287 call isRangeHelp t[66250]))
  }
  function isRangeValue[66301](arg r[66298] :
  (66297 call range[64316](?) ?[260])) param : _unknown[51] "no doc"
  {
    (66304 return 1)
  }
  function isRangeValue[66313](arg r[66311]:_any[178](?)) param : _unknown[51] "no doc"
  {
    (66316 return 0)
  }
  function isBoundedRange[66325](arg r[66323]:_any[178](?)) param : _unknown[51] "no doc"
  {
    (66328 return 0)
  }
  function isBoundedRange[66342](arg r[66339] :
  (66338 call range[64316](?) ?[260])) param : _unknown[51]
  {
    (66351 return(66350 call isBoundedRange(66346 call . r[66339] c"boundedType")))
  }
  function isBoundedRange[66362](param arg B[66359] :
  BoundedRangeType[64213]) param : _unknown[51] "no doc"
  {
    (66371 return(66369 call == B[66359] bounded[64205]))
  }
  function range[64316](?).isBounded[66379](arg _mt[66384]:_MT[238], arg this[66381]:range[64316](?) :
  range[64316](?)) param : _unknown[51] "method"
  {
    (66393 return(66391 call ==(373899 call . this[66381] c"boundedType") bounded[64205]))
  }
  function range[64316](?).hasLowBound[66401](arg _mt[66406]:_MT[238], arg this[66403]:range[64316](?) :
  range[64316](?)) param : _unknown[51] "method"
  {
    (66424 return(66422 call ||(66413 call ==(373904 call . this[66403] c"boundedType") bounded[64205])(66420 call ==(373909 call . this[66403] c"boundedType") boundedLow[64207])))
  }
  function range[64316](?).hasHighBound[66432](arg _mt[66437]:_MT[238], arg this[66434]:range[64316](?) :
  range[64316](?)) param : _unknown[51] "method"
  {
    (66455 return(66453 call ||(66444 call ==(373914 call . this[66434] c"boundedType") bounded[64205])(66451 call ==(373919 call . this[66434] c"boundedType") boundedHigh[64209])))
  }
  function range[64316](?).stride[66463](arg _mt[66468]:_MT[238], arg this[66465]:range[64316](?) :
  range[64316](?)) : _unknown[51] "inline" "method" "no parens"
  {
    (66472 return(373929 call . this[66465] c"_stride"))
  }
  where {
    (373924 call . this[66465] c"stridable")
  }
  function range[64316](?).stride[66481](arg _mt[66486]:_MT[238], arg this[66483]:range[64316](?) :
  range[64316](?)) param : _unknown[51] "method" "no doc" "no parens"
  {
    (66495 return(66493 call _cast(373938 call . this[66483] c"strType") 1))
  }
  where {
    (66489 call !(373934 call . this[66483] c"stridable"))
  }
  function range[64316](?).alignment[66504](arg _mt[66509]:_MT[238], arg this[66506]:range[64316](?) :
  range[64316](?)) : _unknown[51] "inline" "method" "no parens"
  {
    (66516 return(66515 call(373947 call . this[66506] c"chpl_intToIdx")(373952 call . this[66506] c"_alignment")))
  }
  where {
    (373943 call . this[66506] c"stridable")
  }
  function range[64316](?).alignment[66525](arg _mt[66530]:_MT[238], arg this[66527]:range[64316](?) :
  range[64316](?)) : _unknown[51] "method" "no doc" "no parens"
  {
    (66541 return(373965 call . this[66527] c"low"))
  }
  where {
    (66538 call &&(66533 call !(373957 call . this[66527] c"stridable"))(66537 call(373961 call . this[66527] c"hasLowBound")))
  }
  function range[64316](?).alignment[66550](arg _mt[66555]:_MT[238], arg this[66552]:range[64316](?) :
  range[64316](?)) : _unknown[51] "method" "no doc" "no parens"
  {
    (66561 return(66560 call(373969 call . this[66552] c"chpl_intToIdx") 0))
  }
  function range[64316](?).aligned[66569](arg _mt[66574]:_MT[238], arg this[66571]:range[64316](?) :
  range[64316](?)) : _unknown[51] "inline" "method" "no parens"
  {
    (66578 return(373979 call . this[66571] c"_aligned"))
  }
  where {
    (373974 call . this[66571] c"stridable")
  }
  function range[64316](?).aligned[66587](arg _mt[66592]:_MT[238], arg this[66589]:range[64316](?) :
  range[64316](?)) param : _unknown[51] "method" "no doc" "no parens"
  {
    (66616 return 1)
  }
  where {
    (66613 call &&(66595 call !(373984 call . this[66589] c"stridable"))(66611 call ||(66602 call ==(373989 call . this[66589] c"boundedType") bounded[64205])(66609 call ==(373994 call . this[66589] c"boundedType") boundedLow[64207])))
  }
  function range[64316](?).aligned[66625](arg _mt[66630]:_MT[238], arg this[66627]:range[64316](?) :
  range[64316](?)) param : _unknown[51] "method" "no doc" "no parens"
  {
    (66633 return 0)
  }
  function range[64316](?).first[66641](arg _mt[66646]:_MT[238], arg this[66643]:range[64316](?) :
  range[64316](?)) : _unknown[51] "inline" "method" "no parens"
  {
    (66657 return(66656 call(373998 call . this[66643] c"chpl_intToIdx")(66652 call . this[66643] c"firstAsInt")))
  }
  function range[64316](?).firstAsInt[66665](arg _mt[66670]:_MT[238], arg this[66667]:range[64316](?) :
  range[64316](?)) : _unknown[51] "inline" "method" "no doc" "no parens"
  {
    if(66699 call _cond_test(66673 call !(374003 call . this[66667] c"stridable")))
    {
      (66676 return(374008 call . this[66667] c"_low"))
    }
    {
      (66697 return(66694 IfExpr (66680 call >(374013 call . this[66667] c"_stride") 0) then
      { scopeless
        (66685 call . this[66667] c"alignedLowAsInt")
      } else
      { scopeless
        (66691 call . this[66667] c"alignedHighAsInt")
      } ))
    }
  }
  function range[64316](?).last[66711](arg _mt[66716]:_MT[238], arg this[66713]:range[64316](?) :
  range[64316](?)) : _unknown[51] "inline" "method" "no parens"
  {
    (66727 return(66726 call(374017 call . this[66713] c"chpl_intToIdx")(66722 call . this[66713] c"lastAsInt")))
  }
  function range[64316](?).lastAsInt[66735](arg _mt[66740]:_MT[238], arg this[66737]:range[64316](?) :
  range[64316](?)) : _unknown[51] "inline" "method" "no doc" "no parens"
  {
    if(66765 call _cond_test(66743 call !(374022 call . this[66737] c"stridable")))
    {
      (66746 return(374027 call . this[66737] c"_high"))
    }
    {
      (66763 return(66760 IfExpr (66750 call >(374031 call . this[66737] c"stride") 0) then
      { scopeless
        (66753 call . this[66737] c"alignedHighAsInt")
      } else
      { scopeless
        (66757 call . this[66737] c"alignedLowAsInt")
      } ))
    }
  }
  function range[64316](?).low[66777](arg _mt[66782]:_MT[238], arg this[66779]:range[64316](?) :
  range[64316](?)) : _unknown[51] "inline" "method" "no parens"
  {
    (66788 return(66787 call(374035 call . this[66779] c"chpl_intToIdx")(374040 call . this[66779] c"_low")))
  }
  function range[64316](?).high[66796](arg _mt[66801]:_MT[238], arg this[66798]:range[64316](?) :
  range[64316](?)) : _unknown[51] "inline" "method" "no parens"
  {
    (66807 return(66806 call(374044 call . this[66798] c"chpl_intToIdx")(374049 call . this[66798] c"_high")))
  }
  function range[64316](?).alignedLow[66815](arg _mt[66820]:_MT[238], arg this[66817]:range[64316](?) :
  range[64316](?)) : _unknown[51] "inline" "method" "no parens"
  {
    (66830 return(66829 call(374058 call . this[66817] c"chpl_intToIdx")(66825 call . this[66817] c"alignedLowAsInt")))
  }
  { scopeless type
    (374054 call . this[66817] c"idxType")
  }
  function range[64316](?).alignedLowAsInt[66839](arg _mt[66844]:_MT[238], arg this[66841]:range[64316](?) :
  range[64316](?)) : _unknown[51] "inline" "method" "no doc" "no parens"
  {
    if(66863 call _cond_test(66847 call !(374063 call . this[66841] c"stridable")))
    {
      (66850 return(374068 call . this[66841] c"_low"))
    }
    {
      (66861 return(66859 call +(374073 call . this[66841] c"_low")(66858 call chpl__diffMod(374078 call . this[66841] c"_alignment")(374083 call . this[66841] c"_low")(374087 call . this[66841] c"stride"))))
    }
  }
  function range[64316](?).alignedHigh[66875](arg _mt[66880]:_MT[238], arg this[66877]:range[64316](?) :
  range[64316](?)) : _unknown[51] "inline" "method" "no parens"
  {
    (66890 return(66889 call(374096 call . this[66877] c"chpl_intToIdx")(66885 call . this[66877] c"alignedHighAsInt")))
  }
  { scopeless type
    (374092 call . this[66877] c"idxType")
  }
  function range[64316](?).alignedHighAsInt[66899](arg _mt[66904]:_MT[238], arg this[66901]:range[64316](?) :
  range[64316](?)) : _unknown[51] "inline" "method" "no doc" "no parens"
  {
    if(66923 call _cond_test(66907 call !(374101 call . this[66901] c"stridable")))
    {
      (66910 return(374106 call . this[66901] c"_high"))
    }
    {
      (66921 return(66919 call -(374111 call . this[66901] c"_high")(66918 call chpl__diffMod(374116 call . this[66901] c"_high")(374121 call . this[66901] c"_alignment")(374125 call . this[66901] c"stride"))))
    }
  }
  function range[64316](?).isEmpty[66935](arg _mt[66940]:_MT[238], arg this[66937]:range[64316](?) :
  range[64316](?)) : _unknown[51] "inline" "method"
  {
    if(66990 call _cond_test(66946 call && 1(66945 call(374130 call . this[66937] c"isAmbiguous"))))
    {
      (66970 call boundsCheckHalt module=[255] HaltWrappers[209998] "isEmpty() is invoked on an ambiguously-aligned range")
      (357549 'referenced modules list' HaltWrappers[209998])
    }
    {
      (66988 return(66986 call &&(66975 call isBoundedRange this[66937])(66984 call >(66977 call . this[66937] c"alignedLow")(66981 call . this[66937] c"alignedHigh"))))
    }
  }
  function range[64316](?).length[67002](arg _mt[67007]:_MT[238], arg this[67004]:range[64316](?) :
  range[64316](?)) : _unknown[51] "inline" "method" "no parens"
  {
    (67048 call compilerWarning(67045 call + "'range.length' is deprecated - " "please use 'range.size' instead"))
    (67055 return(67052 call . this[67004] c"size"))
  }
  { scopeless type
    (374135 call . this[67004] c"intIdxType")
  }
  function range[64316](?).size[67063](arg _mt[67068]:_MT[238], arg this[67065]:range[64316](?) :
  range[64316](?)) : _unknown[51] "method" "no parens"
  {
    if(67098 call _cond_test(67075 call !(67074 call isBoundedRange this[67065])))
    {
      (67096 call compilerError "'size' is not defined on unbounded ranges")
    }
    const ah[67108] "const"(67105 call . this[67065] c"alignedHighAsInt")
    const al[67115] "const"(67112 call . this[67065] c"alignedLowAsInt")
    (67118 'end of statement')
    if(67129 call _cond_test(67121 call > al[67115] ah[67108]))
    {
      (67127 return(67125 call _cast(374146 call . this[67065] c"intIdxType") 0))
    }
    const s[67144] "const"(67142 call _cast(374150 call . this[67065] c"intIdxType")(67140 call abs(67136 call . this[67065] c"stride")))
    (67147 'end of statement')
    (67161 return(67159 call +(67153 call /(67150 call - ah[67108] al[67115]) s[67144])(67157 call _cast(374157 call . this[67065] c"intIdxType") 1)))
  }
  { scopeless type
    (374139 call . this[67065] c"intIdxType")
  }
  function range[64316](?).hasFirst[67169](arg _mt[67174]:_MT[238], arg this[67171]:range[64316](?) :
  range[64316](?)) param : _unknown[51] "method"
  {
    (67189 return(67188 call(374170 call . this[67171] c"hasLowBound")))
  }
  where {
    (67184 call &&(67177 call !(374162 call . this[67171] c"stridable"))(67182 call !(67181 call(374166 call . this[67171] c"hasHighBound"))))
  }
  function range[64316](?).hasFirst[67198](arg _mt[67203]:_MT[238], arg this[67200]:range[64316](?) :
  range[64316](?)) : _unknown[51] "inline" "method" "no doc"
  {
    (67230 return(67227 IfExpr (67211 call ||(67207 call(374174 call . this[67200] c"isAmbiguous"))(67210 call(374178 call . this[67200] c"isEmpty"))) then
    { scopeless
      0
    } else
    { scopeless(67224 IfExpr (67216 call >(374182 call . this[67200] c"stride") 0) then
      { scopeless
        (67220 call(374186 call . this[67200] c"hasLowBound"))
      } else
      { scopeless
        (67223 call(374190 call . this[67200] c"hasHighBound"))
      } )
    } ))
  }
  function range[64316](?).hasLast[67238](arg _mt[67243]:_MT[238], arg this[67240]:range[64316](?) :
  range[64316](?)) param : _unknown[51] "method"
  {
    (67258 return(67257 call(374203 call . this[67240] c"hasHighBound")))
  }
  where {
    (67253 call &&(67246 call !(374195 call . this[67240] c"stridable"))(67251 call !(67250 call(374199 call . this[67240] c"hasLowBound"))))
  }
  function range[64316](?).hasLast[67267](arg _mt[67272]:_MT[238], arg this[67269]:range[64316](?) :
  range[64316](?)) : _unknown[51] "inline" "method" "no doc"
  {
    (67299 return(67296 IfExpr (67280 call ||(67276 call(374207 call . this[67269] c"isAmbiguous"))(67279 call(374211 call . this[67269] c"isEmpty"))) then
    { scopeless
      0
    } else
    { scopeless(67293 IfExpr (67285 call >(374215 call . this[67269] c"stride") 0) then
      { scopeless
        (67289 call(374219 call . this[67269] c"hasHighBound"))
      } else
      { scopeless
        (67292 call(374223 call . this[67269] c"hasLowBound"))
      } )
    } ))
  }
  function range[64316](?).isNaturallyAligned[67307](arg _mt[67312]:_MT[238], arg this[67309]:range[64316](?) :
  range[64316](?)) : _unknown[51] "method"
  {
    if(67340 call _cond_test(67329 call >(374232 call . this[67309] c"stride") 0))
    {
      (67338 return(67336 call ==(67332 call . this[67309] c"alignedLowAsInt")(374237 call . this[67309] c"_low")))
    }
    if(67359 call _cond_test(67348 call <(374241 call . this[67309] c"stride") 0))
    {
      (67357 return(67355 call ==(67351 call . this[67309] c"alignedHighAsInt")(374246 call . this[67309] c"_high")))
    }
    (67365 return 0)
  }
  where {
    (67325 call &&(374228 call . this[67309] c"stridable")(67323 call ==(67316 call . this[67309] c"boundedType") bounded[64205]))
  }
  function range[64316](?).isNaturallyAligned[67373](arg _mt[67378]:_MT[238], arg this[67375]:range[64316](?) :
  range[64316](?)) param : _unknown[51] "inline" "method" "no doc"
  {
    (67396 return 1)
  }
  where {
    (67393 call &&(67381 call !(374251 call . this[67375] c"stridable"))(67391 call ==(67384 call . this[67375] c"boundedType") bounded[64205]))
  }
  function range[64316](?).isNaturallyAligned[67405](arg _mt[67410]:_MT[238], arg this[67407]:range[64316](?) :
  range[64316](?)) : _unknown[51] "inline" "method" "no doc"
  {
    (67434 return(67432 call ==(67428 call . this[67407] c"alignedLowAsInt")(374261 call . this[67407] c"_low")))
  }
  where {
    (67425 call &&(67413 call !(374256 call . this[67407] c"stridable"))(67423 call ==(67416 call . this[67407] c"boundedType") boundedLow[64207]))
  }
  function range[64316](?).isNaturallyAligned[67443](arg _mt[67448]:_MT[238], arg this[67445]:range[64316](?) :
  range[64316](?)) : _unknown[51] "inline" "method" "no doc"
  {
    (67476 return(67474 call &&(67465 call >(374270 call . this[67445] c"stride") 0)(67472 call ==(67468 call . this[67445] c"alignedLowAsInt")(374275 call . this[67445] c"_low"))))
  }
  where {
    (67461 call &&(374266 call . this[67445] c"stridable")(67459 call ==(67452 call . this[67445] c"boundedType") boundedLow[64207]))
  }
  function range[64316](?).isNaturallyAligned[67485](arg _mt[67490]:_MT[238], arg this[67487]:range[64316](?) :
  range[64316](?)) param : _unknown[51] "inline" "method" "no doc"
  {
    (67520 return 0)
  }
  where {
    (67517 call ||(67500 call ==(67493 call . this[67487] c"boundedType") boundedNone[64211])(67515 call &&(67503 call !(374280 call . this[67487] c"stridable"))(67513 call ==(67506 call . this[67487] c"boundedType") boundedHigh[64209])))
  }
  function range[64316](?).isNaturallyAligned[67529](arg _mt[67534]:_MT[238], arg this[67531]:range[64316](?) :
  range[64316](?)) : _unknown[51] "inline" "method" "no doc"
  {
    (67562 return(67560 call &&(67551 call <(374289 call . this[67531] c"stride") 0)(67558 call ==(67554 call . this[67531] c"alignedHighAsInt")(374294 call . this[67531] c"_high"))))
  }
  where {
    (67547 call &&(374285 call . this[67531] c"stridable")(67545 call ==(67538 call . this[67531] c"boundedType") boundedHigh[64209]))
  }
  function range[64316](?).isAmbiguous[67571](arg _mt[67576]:_MT[238], arg this[67573]:range[64316](?) :
  range[64316](?)) param : _unknown[51] "method"
  {
    (67582 return 0)
  }
  where {
    (67579 call !(374299 call . this[67573] c"stridable"))
  }
  function range[64316](?).isAmbiguous[67591](arg _mt[67596]:_MT[238], arg this[67593]:range[64316](?) :
  range[64316](?)) : _unknown[51] "method" "no doc"
  {
    (67616 return(67614 call &&(67600 call !(374308 call . this[67593] c"aligned"))(67612 call ||(67604 call >(374312 call . this[67593] c"stride") 1)(67610 call <(374316 call . this[67593] c"stride")(67608 call - 1)))))
  }
  where {
    (374304 call . this[67593] c"stridable")
  }
  function range[64316](?).contains[67629](arg _mt[67634]:_MT[238], arg this[67631]:range[64316](?) :
  range[64316](?), arg ind[67626] :
  (374321 call . this[67631] c"idxType")) : _unknown[51] "inline" "method"
  {
    if(67647 call _cond_test(67643 call(67639 call . this[67631] c"isAmbiguous")))
    {
      (67645 return 0)
    }
    const i[67657] "const"(67656 call chpl__idxToInt ind[67626])
    (67660 'end of statement')
    if(67677 call _cond_test(67663 call(374326 call . this[67631] c"hasHighBound")))
    {
      if(67671 call _cond_test(67666 call > i[67657](374332 call . this[67631] c"_high")))
      {
        (67669 return 0)
      }
    }
    if(67697 call _cond_test(67683 call(374336 call . this[67631] c"hasLowBound")))
    {
      if(67691 call _cond_test(67686 call < i[67657](374342 call . this[67631] c"_low")))
      {
        (67689 return 0)
      }
    }
    if(67731 call _cond_test(374347 call . this[67631] c"stridable"))
    {
      unknown s[67709](67707 call _cast(374356 call . this[67631] c"intIdxType")(67705 call abs(374352 call . this[67631] c"_stride")))
      (67712 'end of statement')
      if(67726 call _cond_test(67721 call !=(67719 call chpl__diffMod i[67657](374362 call . this[67631] c"_alignment") s[67709]) 0))
      {
        (67724 return 0)
      }
    }
    (67736 return 1)
  }
  function range[64316](?).contains[67750](arg _mt[67755]:_MT[238], arg this[67752]:range[64316](?) :
  range[64316](?), arg other[67747] :
  (67746 call range[64316](?) ?[260])) : _unknown[51] "inline" "method"
  {
    if(67774 call _cond_test(67769 call ||(67762 call(67758 call . this[67752] c"isAmbiguous"))(67768 call(67764 call . other[67747] c"isAmbiguous"))))
    {
      (67772 return 0)
    }
    if(67842 call _cond_test(374369 call . this[67752] c"stridable"))
    {
      if(67816 call _cond_test(67807 call ||(67792 call &&(67783 call >(374373 call . this[67752] c"stride") 0)(67790 call <(67786 call . other[67747] c"stride") 0))(67805 call &&(67796 call <(374377 call . this[67752] c"stride") 0)(67803 call >(67799 call . other[67747] c"stride") 0))))
      {
        (67814 return(67813 call _containsHelp this[67752] other[67747]))
      }
    }
    {
      if(67836 call _cond_test(67827 call <(67823 call . other[67747] c"stride") 0))
      {
        (67834 return(67833 call _containsHelp this[67752] other[67747]))
      }
    }
    (67853 return(67851 call == other[67747](67850 call this[67752] other[67747])))
  }
  function range[64316](?).member[67864](arg _mt[67869]:_MT[238], arg this[67866]:range[64316](?) :
  range[64316](?), arg ind[67861] :
  (374389 call . this[67866] c"idxType")) : _unknown[51] "inline" "method"
  {
    (67909 call compilerWarning(67906 call + "range.member is deprecated - " "please use range.contains instead"))
    (67921 return(67920 call(67915 call . this[67866] c"contains") ind[67861]))
  }
  function range[64316](?).member[67935](arg _mt[67940]:_MT[238], arg this[67937]:range[64316](?) :
  range[64316](?), arg other[67932] :
  (67931 call range[64316](?) ?[260])) : _unknown[51] "inline" "method"
  {
    (67948 call compilerWarning(67945 call + "range.member is deprecated - " "please use range.contains instead"))
    (67958 return(67957 call(67952 call . this[67937] c"contains") other[67932]))
  }
  function _containsHelp[67971](in arg arg1[67968] :
  (67967 call range[64316](?) ?[260]), in arg arg2[67977] :
  (67976 call range[64316](?) ?[260])) : _unknown[51] "inline" "private"
  {
    if(68010 call _cond_test(67981 call . arg2[67977] c"stridable"))
    {
      (67994 call =(67985 call . arg2[67977] c"_stride")(67992 call -(67989 call . arg2[67977] c"_stride")))
    }
    {
      (68007 call =(67998 call . arg1[67968] c"_stride")(68005 call -(68002 call . arg1[67968] c"_stride")))
    }
    (68024 return(68022 call == arg2[67977](68021 call arg1[67968] arg2[67977])))
  }
  function ==[68037](arg r1[68034] :
  (68033 call range[64316](?) ?[260]), arg r2[68043] :
  (68042 call range[64316](?) ?[260])) param : _unknown[51]
  {
    (68057 return 0)
  }
  where {
    (68054 call !=(68047 call . r1[68034] c"boundedType")(68051 call . r2[68043] c"boundedType"))
  }
  function ==[68072](arg r1[68069] :
  (68068 call range[64316](?) ?[260]), arg r2[68078] :
  (68077 call range[64316](?) ?[260])) : _unknown[51]
  {
    if(68109 call _cond_test(68104 call !=(68097 call(68093 call . r1[68069] c"isAmbiguous"))(68103 call(68099 call . r2[68078] c"isAmbiguous"))))
    {
      (68107 return 0)
    }
    if(68128 call _cond_test(68120 call(68116 call . r1[68069] c"isAmbiguous")))
    {
      (68126 return(68125 call ident r1[68069] r2[68078]))
    }
    if(68310 call _cond_test(68136 call isBoundedRange r1[68069]))
    {
      const len[68141] "const"(68138 call . r1[68069] c"size")
      const l2[68148] "const"(68145 call . r2[68078] c"size")
      (68151 'end of statement')
      if(68160 call _cond_test(68155 call != len[68141] l2[68148]))
      {
        (68158 return 0)
      }
      if(68172 call _cond_test(68167 call == len[68141] 0))
      {
        (68170 return 1)
      }
      if(68192 call _cond_test(68187 call !=(68180 call . r1[68069] c"first")(68184 call . r2[68078] c"first")))
      {
        (68190 return 0)
      }
      if(68204 call _cond_test(68199 call == len[68141] 1))
      {
        (68202 return 1)
      }
      if(68222 call _cond_test(68217 call !=(68210 call . r1[68069] c"stride")(68214 call . r2[68078] c"stride")))
      {
        (68220 return 0)
      }
      (68228 return 1)
    }
    {
      if(68243 call _cond_test(68238 call !=(68231 call . r1[68069] c"stride")(68235 call . r2[68078] c"stride")))
      {
        (68241 return 0)
      }
      if(68273 call _cond_test(68254 call(68250 call . r1[68069] c"hasLowBound")))
      {
        if(68268 call _cond_test(68263 call !=(68256 call . r1[68069] c"alignedLow")(68260 call . r2[68078] c"alignedLow")))
        {
          (68266 return 0)
        }
      }
      if(68302 call _cond_test(68283 call(68279 call . r1[68069] c"hasHighBound")))
      {
        if(68297 call _cond_test(68292 call !=(68285 call . r1[68069] c"alignedHigh")(68289 call . r2[68078] c"alignedHigh")))
        {
          (68295 return 0)
        }
      }
      (68308 return 1)
    }
  }
  where {
    (68090 call ==(68083 call . r1[68069] c"boundedType")(68087 call . r2[68078] c"boundedType"))
  }
  { scopeless type
    bool[10]
  }
  function !=[68327](arg r1[68324] :
  (68323 call range[64316](?) ?[260]), arg r2[68333] :
  (68332 call range[64316](?) ?[260])) : _unknown[51]
  {
    (68342 return(68340 call !(68338 call == r1[68324] r2[68333])))
  }
  function ident[68356](arg r1[68353] :
  (68352 call range[64316](?) ?[260]), arg r2[68362] :
  (68361 call range[64316](?) ?[260])) : _unknown[51]
  {
    if(68412 call _cond_test(68407 call !=(68400 call . r1[68353] c"_low")(68404 call . r2[68362] c"_low")))
    {
      (68410 return 0)
    }
    if(68431 call _cond_test(68426 call !=(68419 call . r1[68353] c"_high")(68423 call . r2[68362] c"_high")))
    {
      (68429 return 0)
    }
    if(68508 call _cond_test(68437 call . r1[68353] c"stridable"))
    {
      if(68503 call _cond_test(68441 call . r2[68362] c"stridable"))
      {
        if(68457 call _cond_test(68452 call !=(68445 call . r1[68353] c"_stride")(68449 call . r2[68362] c"_stride")))
        {
          (68455 return 0)
        }
        if(68476 call _cond_test(68471 call !=(68464 call . r1[68353] c"_alignment")(68468 call . r2[68362] c"_alignment")))
        {
          (68474 return 0)
        }
        if(68494 call _cond_test(68489 call !=(68482 call . r1[68353] c"_aligned")(68486 call . r2[68362] c"_aligned")))
        {
          (68492 return 0)
        }
      }
      {
        (68500 return 0)
      }
    }
    (68513 return 1)
  }
  where {
    (68397 call &&(68385 call &&(68373 call ==(68366 call . r1[68353] c"idxType")(68370 call . r2[68362] c"idxType"))(68383 call ==(68376 call . r1[68353] c"boundedType")(68380 call . r2[68362] c"boundedType")))(68395 call ==(68388 call . r1[68353] c"stridable")(68392 call . r2[68362] c"stridable")))
  }
  function ident[68527](arg r1[68524] :
  (68523 call range[64316](?) ?[260]), arg r2[68533] :
  (68532 call range[64316](?) ?[260])) param : _unknown[51] "no doc"
  {
    (68537 return 0)
  }
  function range[64316](?).safeCast[68552](arg _mt[68557]:_MT[238], arg this[68554]:range[64316](?) :
  range[64316](?), arg t[68549] :
  (68548 call range[64316](?) ?[260])) : _unknown[51] "method" "no doc"
  {
    unknown tmp[68560] t[68549]
    (68563 'end of statement')
    if(68628 call _cond_test(68573 call !=(68566 call . tmp[68560] c"boundedType")(68570 call . this[68554] c"boundedType")))
    {
      (68625 call compilerError "cannot cast range from "(68599 call _cast string[26](68595 call . this[68554] c"boundedType")) " to "(68623 call _cast string[26](68619 call . tmp[68560] c"boundedType")))
    }
    if(68722 call _cond_test(68633 call . tmp[68560] c"stridable"))
    {
      (68644 call =(68637 call . tmp[68560] c"_stride")(68641 call . this[68554] c"stride"))
      (68670 call =(68649 call . tmp[68560] c"_alignment")(68669 call(68659 call .(68658 call chpl__idxToInt(68654 call . this[68554] c"alignment")) c"safeCast")(68665 call . tmp[68560] c"intIdxType")))
      (68681 call =(68674 call . tmp[68560] c"_aligned")(68678 call . this[68554] c"aligned"))
    }
    {
      if(68718 call _cond_test(68689 call !=(68685 call . this[68554] c"stride") 1))
      {
        (68715 call safeCastCheckHalt module=[255] HaltWrappers[209998] "illegal safeCast from non-unit stride range to unstridable range")
        (357645 'referenced modules list' HaltWrappers[209998])
      }
    }
    (68744 call =(68728 call . tmp[68560] c"_low")(68743 call(68735 call .(68732 call . this[68554] c"_low") c"safeCast")(68739 call . tmp[68560] c"intIdxType")))
    (68764 call =(68748 call . tmp[68560] c"_high")(68763 call(68755 call .(68752 call . this[68554] c"_high") c"safeCast")(68759 call . tmp[68560] c"intIdxType")))
    (68768 return tmp[68560])
  }
  function _cast[68781](arg t[68778] :
  (68777 call range[64316](?) ?[260]), arg r[68787] :
  (68786 call range[64316](?) ?[260])) : _unknown[51] "no doc"
  {
    unknown tmp[68791] t[68778]
    (68794 'end of statement')
    if(68827 call _cond_test(68804 call !=(68797 call . tmp[68791] c"boundedType")(68801 call . r[68787] c"boundedType")))
    {
      (68824 call compilerError "cannot cast range from "(68814 call _cast string[26](68810 call . r[68787] c"boundedType")) " to "(68822 call _cast string[26](68818 call . tmp[68791] c"boundedType")))
    }
    if(68875 call _cond_test(68832 call . tmp[68791] c"stridable"))
    {
      (68843 call =(68836 call . tmp[68791] c"_stride")(68840 call . r[68787] c"_stride"))
      (68861 call =(68848 call . tmp[68791] c"_alignment")(68859 call _cast(68856 call . tmp[68791] c"intIdxType")(68852 call . r[68787] c"_alignment")))
      (68872 call =(68865 call . tmp[68791] c"_aligned")(68869 call . r[68787] c"_aligned"))
    }
    (68893 call =(68880 call . tmp[68791] c"_low")(68891 call _cast(68888 call . tmp[68791] c"intIdxType")(68884 call . r[68787] c"low")))
    (68910 call =(68897 call . tmp[68791] c"_high")(68908 call _cast(68905 call . tmp[68791] c"intIdxType")(68901 call . r[68787] c"high")))
    (68914 return tmp[68791])
  }
  function range[64316](?).boundsCheck[68933](arg _mt[68938]:_MT[238], arg this[68935]:range[64316](?) :
  range[64316](?), arg other[68930] :
  (68929 call range[64316](?) unknown e[68922] unknown b[68925] unknown s[68927])) : _unknown[51] "inline" "method"
  {
    if(68964 call _cond_test(68959 call ||(68952 call(68948 call . this[68935] c"isAmbiguous"))(68958 call(68954 call . other[68930] c"isAmbiguous"))))
    {
      (68962 return 0)
    }
    (68971 return 1)
  }
  where {
    (68945 call == b[68925] boundedNone[64211])
  }
  function range[64316](?).boundsCheck[68991](arg _mt[68996]:_MT[238], arg this[68993]:range[64316](?) :
  range[64316](?), arg other[68988] :
  (68987 call range[64316](?) unknown e[68980] unknown b[68983] unknown s[68985])) : _unknown[51] "inline" "method" "no doc"
  {
    if(69015 call _cond_test(69010 call ||(69003 call(68999 call . this[68993] c"isAmbiguous"))(69009 call(69005 call . other[68988] c"isAmbiguous"))))
    {
      (69013 return 0)
    }
    unknown boundedOther[69074](69021 'new'(69073 call range[64316](?)(374432 call . this[68993] c"idxType") bounded[64205](69034 call || s[68985](69031 call . this[68993] c"stridable"))(69047 IfExpr (69041 call(69037 call . other[68988] c"hasLowBound")) then
    { scopeless
      (69043 call . other[68988] c"low")
    } else
    { scopeless
      (374437 call . this[68993] c"low")
    } )(69061 IfExpr (69055 call(69051 call . other[68988] c"hasHighBound")) then
    { scopeless
      (69057 call . other[68988] c"high")
    } else
    { scopeless
      (374441 call . this[68993] c"high")
    } )(69065 call . other[68988] c"stride")(69069 call . other[68988] c"alignment") 1))
    (69077 'end of statement')
    (69091 return(69089 call ||(69083 call ==(69079 call . boundedOther[69074] c"size") 0)(69088 call(374445 call . this[68993] c"contains") boundedOther[69074])))
  }
  function range[64316](?).boundsCheck[69102](arg _mt[69107]:_MT[238], arg this[69104]:range[64316](?) :
  range[64316](?), arg other[69099] :
  (374451 call . this[69104] c"idxType")) : _unknown[51] "inline" "method"
  {
    (69113 return(69112 call(374455 call . this[69104] c"contains") other[69099]))
  }
  function range[64316](?).alignLow[69121](arg _mt[69126]:_MT[238], ref arg this[69123]:range[64316](?) :
  range[64316](?)) : _unknown[51] "method" "no doc"
  {
    if(69163 call _cond_test(69135 call && 1(69134 call(69130 call . this[69123] c"isAmbiguous"))))
    {
      (69161 call boundsCheckHalt module=[255] HaltWrappers[209998] "alignLow -- Cannot be applied to a range with ambiguous alignment.")
      (357690 'referenced modules list' HaltWrappers[209998])
    }
    if(69178 call _cond_test(374462 call . this[69123] c"stridable"))
    {
      (69175 call =(374467 call . this[69123] c"_low")(69172 call . this[69123] c"alignedLowAsInt"))
    }
    (69184 return this[69123])
  }
  function range[64316](?).alignHigh[69191](arg _mt[69196]:_MT[238], ref arg this[69193]:range[64316](?) :
  range[64316](?)) : _unknown[51] "method" "no doc"
  {
    if(69231 call _cond_test(69205 call && 1(69204 call(69200 call . this[69193] c"isAmbiguous"))))
    {
      (69229 call boundsCheckHalt module=[255] HaltWrappers[209998] "alignHigh -- Cannot be applied to a range with ambiguous alignment.")
      (357698 'referenced modules list' HaltWrappers[209998])
    }
    if(69246 call _cond_test(374474 call . this[69193] c"stridable"))
    {
      (69243 call =(374479 call . this[69193] c"_high")(69240 call . this[69193] c"alignedHighAsInt"))
    }
    (69252 return this[69193])
  }
  function range[64316](?).indexOrder[69263](arg _mt[69268]:_MT[238], arg this[69265]:range[64316](?) :
  range[64316](?), arg ind[69260] :
  (374485 call . this[69265] c"idxType")) : _unknown[51] "method"
  {
    if(69303 call _cond_test(69277 call && 1(69276 call(69272 call . this[69265] c"isAmbiguous"))))
    {
      (69301 call boundsCheckHalt module=[255] HaltWrappers[209998] "indexOrder -- Undefined on a range with ambiguous alignment.")
      (357706 'referenced modules list' HaltWrappers[209998])
    }
    if(69323 call _cond_test(69313 call !(69312 call(374490 call . this[69265] c"contains") ind[69260])))
    {
      (69321 return(69319 call _cast(374495 call . this[69265] c"intIdxType")(69316 call - 1)))
    }
    if(69393 call _cond_test(69329 call !(374500 call . this[69265] c"stridable")))
    {
      if(69346 call _cond_test(69336 call(69332 call . this[69265] c"hasLowBound")))
      {
        (69344 return(69342 call -(69340 call chpl__idxToInt ind[69260])(374506 call . this[69265] c"_low")))
      }
    }
    {
      if(69387 call _cond_test(69359 call(69355 call . this[69265] c"hasFirst")))
      {
        (69385 return(69383 call _cast(374524 call . this[69265] c"intIdxType")(69380 call /(69377 call -(69365 call _cast(374511 call . this[69265] c"strType")(69363 call chpl__idxToInt ind[69260]))(69375 call _cast(374515 call . this[69265] c"strType")(69373 call chpl__idxToInt(69369 call . this[69265] c"first"))))(374520 call . this[69265] c"_stride"))))
      }
    }
    (69403 return(69401 call _cast(374528 call . this[69265] c"intIdxType")(69398 call - 1)))
  }
  function range[64316](?).orderToIndex[69414](arg _mt[69419]:_MT[238], arg this[69416]:range[64316](?) :
  range[64316](?), arg ord[69411] :
  integral[199](?)) : _unknown[51] "method"
  {
    if(69605 call _cond_test 1)
    {
      if(69452 call _cond_test(69426 call !(69425 call(374539 call . this[69416] c"hasFirst"))))
      {
        (69450 call boundsCheckHalt module=[255] HaltWrappers[209998] "invoking orderToIndex on a range that has no first index")
        (357715 'referenced modules list' HaltWrappers[209998])
      }
      if(69485 call _cond_test(69460 call(374543 call . this[69416] c"isAmbiguous")))
      {
        (69483 call boundsCheckHalt module=[255] HaltWrappers[209998] "invoking orderToIndex on a range that is ambiguously aligned")
        (357721 'referenced modules list' HaltWrappers[209998])
      }
      if(69524 call _cond_test(69492 call < ord[69411] 0))
      {
        (69522 call boundsCheckHalt module=[255] HaltWrappers[209998](69519 call + "invoking orderToIndex on a negative integer: "(69517 call _cast string[26] ord[69411])))
        (357727 'referenced modules list' HaltWrappers[209998])
      }
      if(69600 call _cond_test(69540 call &&(69532 call isBoundedRange this[69416])(69538 call >= ord[69411](69535 call . this[69416] c"size"))))
      {
        (69598 call boundsCheckHalt module=[255] HaltWrappers[209998](69595 call +(69586 call +(69567 call + "invoking orderToIndex on an integer "(69565 call _cast string[26] ord[69411])) " that is larger than the range's number of indices ")(69593 call _cast string[26](69589 call . this[69416] c"size"))))
        (357734 'referenced modules list' HaltWrappers[209998])
      }
    }
    (69625 return(69624 call(374552 call . this[69416] c"chpl_intToIdx")(69622 call chpl__addRangeStrides(69613 call . this[69416] c"firstAsInt")(69618 call . this[69416] c"stride") ord[69411])))
  }
  { scopeless type
    (374534 call . this[69416] c"idxType")
  }
  function range[64316](?).translate[69637](arg _mt[69642]:_MT[238], arg this[69639]:range[64316](?) :
  range[64316](?), arg offset[69634] :
  integral[199](?)) : _unknown[51] "inline" "method"
  {
    (69648 return(69646 call + this[69639] offset[69634]))
  }
  function range[64316](?).translate[69658](arg _mt[69663]:_MT[238], arg this[69660]:range[64316](?) :
  range[64316](?), arg i[69656]:_any[178](?)) : _unknown[51] "inline" "method" "no doc" "no return value for void"
  {
    (69684 call compilerError "offsets must be of integral type")
  }
  function range[64316](?)._effAlmt[69692](arg _mt[69697]:_MT[238], arg this[69694]:range[64316](?) :
  range[64316](?)) : _unknown[51] "inline" "method" "no doc"
  {
    (69701 return(374565 call . this[69694] c"alignment"))
  }
  where {
    (374561 call . this[69694] c"stridable")
  }
  function range[64316](?)._effAlmt[69710](arg _mt[69715]:_MT[238], arg this[69712]:range[64316](?) :
  range[64316](?)) : _unknown[51] "method" "no doc"
  {
    (69724 return(69723 call(374574 call . this[69712] c"chpl_intToIdx") 0))
  }
  where {
    (69718 call !(374570 call . this[69712] c"stridable"))
  }
  function range[64316](?).interior[69737](arg _mt[69742]:_MT[238], arg this[69739]:range[64316](?) :
  range[64316](?), arg offset[69734] :
  integral[199](?)) : _unknown[51] "method" "no doc" "no return value for void"
  {
    (69770 call compilerError "interior is not supported on unbounded ranges")
  }
  where {
    (69749 call !=(374580 call . this[69739] c"boundedType") bounded[64205])
  }
  function range[64316](?).interior[69783](arg _mt[69788]:_MT[238], arg this[69785]:range[64316](?) :
  range[64316](?), arg offset[69780] :
  integral[199](?)) : _unknown[51] "method"
  {
    const i[69797] "const"(69796 call(69791 call . offset[69780] c"safeCast")(374585 call . this[69785] c"intIdxType"))
    (69800 'end of statement')
    if(69831 call _cond_test(69804 call < i[69797] 0))
    {
      (69829 return(69806 'new'(69828 call range[64316](?)(374592 call . this[69785] c"idxType")(374597 call . this[69785] c"boundedType")(374602 call . this[69785] c"stridable")(374606 call . this[69785] c"low")(69822 call(374610 call . this[69785] c"chpl_intToIdx")(69819 call -(69816 call -(374615 call . this[69785] c"_low") 1) i[69797]))(374620 call . this[69785] c"stride")(69826 call(374626 call . this[69785] c"_effAlmt"))(374630 call . this[69785] c"aligned"))))
    }
    if(69865 call _cond_test(69838 call > i[69797] 0))
    {
      (69863 return(69840 'new'(69862 call range[64316](?)(374637 call . this[69785] c"idxType")(374642 call . this[69785] c"boundedType")(374647 call . this[69785] c"stridable")(69855 call(374651 call . this[69785] c"chpl_intToIdx")(69852 call -(69849 call +(374656 call . this[69785] c"_high") 1) i[69797]))(374661 call . this[69785] c"high")(374665 call . this[69785] c"stride")(69860 call(374669 call . this[69785] c"_effAlmt"))(374673 call . this[69785] c"aligned"))))
    }
    (69884 return(69870 'new'(69883 call range[64316](?)(374679 call . this[69785] c"idxType")(374684 call . this[69785] c"boundedType")(374689 call . this[69785] c"stridable")(374693 call . this[69785] c"low")(374697 call . this[69785] c"high")(374701 call . this[69785] c"stride")(69881 call(374705 call . this[69785] c"_effAlmt"))(374709 call . this[69785] c"aligned"))))
  }
  function range[64316](?).exterior[69895](arg _mt[69900]:_MT[238], arg this[69897]:range[64316](?) :
  range[64316](?), arg offset[69892] :
  integral[199](?)) : _unknown[51] "method" "no doc" "no return value for void"
  {
    (69928 call compilerError "exterior is not supported on unbounded ranges")
  }
  where {
    (69907 call !=(374715 call . this[69897] c"boundedType") bounded[64205])
  }
  function range[64316](?).exterior[69941](arg _mt[69946]:_MT[238], arg this[69943]:range[64316](?) :
  range[64316](?), arg offset[69938] :
  integral[199](?)) : _unknown[51] "method"
  {
    const i[69955] "const"(69954 call(69949 call . offset[69938] c"safeCast")(374720 call . this[69943] c"intIdxType"))
    (69958 'end of statement')
    if(69992 call _cond_test(69962 call < i[69955] 0))
    {
      (69990 return(69964 'new'(69989 call range[64316](?)(374727 call . this[69943] c"idxType")(374732 call . this[69943] c"boundedType")(374737 call . this[69943] c"stridable")(69976 call(374741 call . this[69943] c"chpl_intToIdx")(69973 call +(374746 call . this[69943] c"_low") i[69955]))(69983 call(374751 call . this[69943] c"chpl_intToIdx")(69980 call -(374756 call . this[69943] c"_low") 1))(374760 call . this[69943] c"stride")(69987 call(374764 call . this[69943] c"_effAlmt"))(374768 call . this[69943] c"aligned"))))
    }
    if(70029 call _cond_test(69999 call > i[69955] 0))
    {
      (70027 return(70001 'new'(70026 call range[64316](?)(374775 call . this[69943] c"idxType")(374780 call . this[69943] c"boundedType")(374785 call . this[69943] c"stridable")(70013 call(374789 call . this[69943] c"chpl_intToIdx")(70010 call +(374794 call . this[69943] c"_high") 1))(70020 call(374798 call . this[69943] c"chpl_intToIdx")(70017 call +(374803 call . this[69943] c"_high") i[69955]))(374808 call . this[69943] c"stride")(70024 call(374812 call . this[69943] c"_effAlmt"))(374816 call . this[69943] c"aligned"))))
    }
    (70048 return(70034 'new'(70047 call range[64316](?)(374822 call . this[69943] c"idxType")(374827 call . this[69943] c"boundedType")(374832 call . this[69943] c"stridable")(374836 call . this[69943] c"low")(374840 call . this[69943] c"high")(374844 call . this[69943] c"stride")(70045 call(374848 call . this[69943] c"_effAlmt"))(374852 call . this[69943] c"aligned"))))
  }
  function range[64316](?).expand[70059](arg _mt[70064]:_MT[238], arg this[70061]:range[64316](?) :
  range[64316](?), arg offset[70056] :
  integral[199](?)) : _unknown[51] "method" "no doc" "no return value for void"
  {
    (70092 call compilerError "expand() is not supported on unbounded ranges")
  }
  where {
    (70071 call !=(374858 call . this[70061] c"boundedType") bounded[64205])
  }
  function range[64316](?).expand[70105](arg _mt[70110]:_MT[238], arg this[70107]:range[64316](?) :
  range[64316](?), arg offset[70102] :
  integral[199](?)) : _unknown[51] "method"
  {
    const i[70119] "const"(70118 call(70113 call . offset[70102] c"safeCast")(374863 call . this[70107] c"intIdxType"))
    (70122 'end of statement')
    (70148 return(70124 'new'(70147 call range[64316](?)(374869 call . this[70107] c"idxType")(374874 call . this[70107] c"boundedType")(374879 call . this[70107] c"stridable")(70136 call(374883 call . this[70107] c"chpl_intToIdx")(70133 call -(374888 call . this[70107] c"_low") i[70119]))(70143 call(374893 call . this[70107] c"chpl_intToIdx")(70140 call +(374898 call . this[70107] c"_high") i[70119]))(374903 call . this[70107] c"stride")(374907 call . this[70107] c"alignment")(374912 call . this[70107] c"_aligned"))))
  }
  function =[70163](ref arg r1[70160] :
  (70159 call range[64316](?)(stridable = unknown s1[70155])), arg r2[70171] :
  (70170 call range[64316](?)(stridable = unknown s2[70166]))) : _unknown[51] "assignop" "inline" "no return value for void"
  {
    if(70207 call _cond_test(70182 call !=(70175 call . r1[70160] c"boundedType")(70179 call . r2[70171] c"boundedType")))
    {
      (70205 call compilerError "type mismatch in assignment of ranges with different boundedType parameters")
    }
    if(70275 call _cond_test(70217 call &&(70214 call ! s1[70155]) s2[70166]))
    {
      (70238 call compilerError "type mismatch in assignment of ranges with different stridable parameters")
    }
    {
      if(70269 call _cond_test(70242 call && s1[70155] s2[70166]))
      {
        (70252 call =(70245 call . r1[70160] c"_stride")(70249 call . r2[70171] c"stride"))
      }
      {
        if(70264 call _cond_test s1[70155])
        {
          (70261 call =(70257 call . r1[70160] c"_stride") 1)
        }
      }
    }
    (70289 call =(70282 call . r1[70160] c"_low")(70286 call . r2[70171] c"_low"))
    (70300 call =(70293 call . r1[70160] c"_high")(70297 call . r2[70171] c"_high"))
    if(70330 call _cond_test s1[70155])
    {
      (70315 call =(70305 call . r1[70160] c"_alignment")(70314 call chpl__idxToInt(70310 call . r2[70171] c"alignment")))
      (70327 call =(70320 call . r1[70160] c"_aligned")(70324 call . r2[70171] c"aligned"))
    }
  }
  function +[70350](arg r[70347] :
  (70346 call range[64316](?) unknown e[70339] unknown b[70342] unknown s[70344]), arg offset[70353] :
  integral[199](?)) : _unknown[51] "inline"
  {
    const i[70363] "const"(70361 call _cast(70358 call . r[70347] c"intIdxType") offset[70353])
    (70366 'end of statement')
    unknown strType[70372] "type variable"(70371 call chpl__rangeStrideType e[70339])
    (70437 return(70375 'new'(70436 call range[64316](?) e[70339] b[70342] s[70344](70395 call(70384 call . r[70347] c"chpl_intToIdx")(70392 call +(70388 call . r[70347] c"_low") i[70363]))(70408 call(70397 call . r[70347] c"chpl_intToIdx")(70405 call +(70401 call . r[70347] c"_high") i[70363]))(70414 call _cast strType[70372](70410 call . r[70347] c"stride"))(70431 call(70417 call . r[70347] c"chpl_intToIdx")(70428 call +(70426 call chpl__idxToInt(70422 call . r[70347] c"alignment")) i[70363]))(70433 call . r[70347] c"aligned"))))
  }
  function +[70447](arg i[70444] :
  integral[199](?), arg r[70458] :
  (70457 call range[64316](?) unknown e[70450] unknown b[70453] unknown s[70455])) : _unknown[51] "inline"
  {
    (70465 return(70463 call + r[70458] i[70444]))
  }
  function -[70484](arg r[70481] :
  (70480 call range[64316](?) unknown e[70473] unknown b[70476] unknown s[70478]), arg i[70487] :
  integral[199](?)) : _unknown[51] "inline"
  {
    unknown strType[70494] "type variable"(70493 call chpl__rangeStrideType e[70473])
    (70558 return(70498 'new'(70557 call range[64316](?) e[70473] b[70476] s[70478](70516 call(70505 call . r[70481] c"chpl_intToIdx")(70513 call -(70509 call . r[70481] c"_low") i[70487]))(70529 call(70518 call . r[70481] c"chpl_intToIdx")(70526 call -(70522 call . r[70481] c"_high") i[70487]))(70535 call _cast strType[70494](70531 call . r[70481] c"stride"))(70552 call(70538 call . r[70481] c"chpl_intToIdx")(70549 call -(70547 call chpl__idxToInt(70543 call . r[70481] c"alignment")) i[70487]))(70554 call . r[70481] c"aligned"))))
  }
  function chpl_check_step_integral[70566](arg step[70564]:_any[178](?)) : _unknown[51] "inline" "no return value for void"
  {
    if(70601 call _cond_test(70573 call !(70572 call isIntegral(70570 'typeof' step[70564]))))
    {
      (70599 call compilerError "can't apply 'by' using step of a non-integral type "(70597 call _cast string[26](70595 'typeof' step[70564])))
    }
  }
  function chpl_need_to_check_step[70613](arg step[70611]:_any[178](?), arg strType[70615]:_any[178](?)) param : _unknown[51]
  {
    (70623 call compilerAssert(70621 call isInt strType[70615]))
    (70644 return(70642 call &&(70629 call !=(70627 'typeof' step[70611]) strType[70615])(70640 call >=(70635 call numBits(70633 'typeof' step[70611]))(70639 call numBits strType[70615]))))
  }
  function chpl_range_check_stride[70652](arg step[70650]:_any[178](?), arg idxType[70654]:_any[178](?)) : _unknown[51] "inline" "no return value for void"
  {
    (70659 call chpl_check_step_integral step[70650])
    unknown strType[70666] "type variable"(70665 call chpl__rangeStrideType idxType[70654])
    if(70727 call _cond_test(70678 call >(70673 call numBits(70671 'typeof' step[70650]))(70677 call numBits strType[70666])))
    {
      (70725 call compilerError "can't apply 'by' to a range with idxType "(70701 call _cast string[26] idxType[70654]) " using a step of type "(70723 call _cast string[26](70721 'typeof' step[70650])))
    }
    if(70822 call _cond_test 1)
    {
      if(70761 call _cond_test(70735 call == step[70650] 0))
      {
        (70759 call boundsCheckHalt module=[255] HaltWrappers[209998] "the step argument of the 'by' operator is zero")
        (357779 'referenced modules list' HaltWrappers[209998])
      }
      if(70817 call _cond_test(70783 call &&(70771 call chpl_need_to_check_step step[70650] strType[70666])(70781 call > step[70650](70779 call _cast(70778 'typeof' step[70650])(70776 call max strType[70666])))))
      {
        (70815 call boundsCheckHalt module=[255] HaltWrappers[209998](70812 call + "the step argument of the 'by' operator is too large and cannot be represented within the range's stride type "(70810 call _cast string[26] strType[70666])))
        (357785 'referenced modules list' HaltWrappers[209998])
      }
    }
  }
  function chpl_range_check_stride[70832](param arg step[70830]:_any[178](?), arg idxType[70834]:_any[178](?)) : _unknown[51] "inline" "no return value for void"
  {
    (70839 call chpl_check_step_integral step[70830])
    unknown strType[70846] "type variable"(70845 call chpl__rangeStrideType idxType[70834])
    if(70858 call _cond_test(70851 call == step[70830] 0))
    {
      (70856 call compilerError "the step argument of the 'by' operator is zero")
    }
    if(70892 call _cond_test(70879 call &&(70867 call chpl_need_to_check_step step[70830] strType[70846])(70877 call > step[70830](70875 call _cast(70874 'typeof' step[70830])(70872 call max strType[70846])))))
    {
      (70890 call compilerError(70887 call + "the step argument of the 'by' operator is too large and cannot be represented within the range's stride type "(70885 call _cast string[26] strType[70846])))
    }
  }
  function chpl_by_help[70913](arg r[70910] :
  (70909 call range[64316](?) unknown i[70902] unknown b[70905] unknown s[70907]), arg step[70915]:_any[178](?)) : _unknown[51]
  {
    const lw[70922] "const"(70919 call . r[70910] c"low") i[70902]
    const hh[70930] "const"(70927 call . r[70910] c"high") i[70902]
    const st[70952] "const"(70950 call *(70940 call . r[70910] c"stride")(70948 call _cast(70945 call . r[70910] c"strType") step[70915]))(70936 call . r[70910] c"strType")
    (70955 'end of statement')
    const tmp[71077] "const" "temp"(71074 IfExpr (70972 call(70968 call . r[70910] c"isAmbiguous")) then
    { scopeless(70996 IfExpr (70974 call . r[70910] c"stridable") then
      { scopeless
        (70983 call _build_tuple 0(70979 call . r[70910] c"alignment"))
      } else
      { scopeless
        (70994 call _build_tuple 0(70992 call(70987 call . r[70910] c"chpl_intToIdx") 0))
      } )
    } else
    { scopeless(71071 IfExpr (71009 call &&(71004 call(71000 call . r[70910] c"hasLowBound"))(71007 call > st[70952] 0)) then
      { scopeless
        (71017 call _build_tuple 1(71013 call . r[70910] c"alignedLow"))
      } else
      { scopeless(71068 IfExpr (71029 call &&(71024 call(71020 call . r[70910] c"hasHighBound"))(71027 call < st[70952] 0)) then
        { scopeless
          (71037 call _build_tuple 1(71033 call . r[70910] c"alignedHigh"))
        } else
        { scopeless(71065 IfExpr (71040 call . r[70910] c"stridable") then
          { scopeless
            (71052 call _build_tuple(71044 call . r[70910] c"aligned")(71048 call . r[70910] c"alignment"))
          } else
          { scopeless
            (71063 call _build_tuple 0(71061 call(71056 call . r[70910] c"chpl_intToIdx") 0))
          } )
        } )
      } )
    } )(70965 call _build_tuple bool[10] i[70902])
    (71084 call _check_tuple_var_decl tmp[71077] 2)
    const ald[70957] "const"(71078 call tmp[71077] 0)
    const alt[70959] "const"(71081 call tmp[71077] 1)
    (71089 'end of statement')
    (71102 return(71090 'new'(71101 call range[64316](?) i[70902] b[70905] 1 lw[70922] hh[70930] st[70952] alt[70959] ald[70957])))
  }
  function chpl_by[71110](arg r[71108]:_any[178](?), arg step[71112]:_any[178](?)) : _unknown[51] "inline" "no doc"
  {
    if(71141 call _cond_test(71118 call !(71117 call isRange r[71108])))
    {
      (71139 call compilerError "the first argument of the 'by' operator is not a range")
    }
    (71154 call chpl_range_check_stride step[71112](71151 call . r[71108] c"idxType"))
    (71161 return(71160 call chpl_by_help r[71108] step[71112]))
  }
  function chpl_by[71174](arg r[71171] :
  (71170 call range[64316](?) ?[260]), param arg step[71176]:_any[178](?)) : _unknown[51] "inline" "no doc"
  {
    (71185 call chpl_range_check_stride step[71176](71182 call . r[71171] c"idxType"))
    (71199 return(71198 call chpl_by_help r[71171](71196 call _cast(71193 call . r[71171] c"strType") step[71176])))
  }
  function chpl_align[71217](arg r[71214] :
  (71213 call range[64316](?) unknown i[71206] unknown b[71209] unknown s[71211]), arg algn[71220] :
  i[71206]) : _unknown[51] "inline" "no doc"
  {
    (71256 return(71223 'new'(71255 call range[64316](?) i[71206] b[71209] 1(71238 call(71230 call . r[71214] c"chpl_intToIdx")(71234 call . r[71214] c"_low"))(71248 call(71240 call . r[71214] c"chpl_intToIdx")(71244 call . r[71214] c"_high"))(71250 call . r[71214] c"stride") algn[71220] 1)))
  }
  function chpl_align[71275](arg r[71272] :
  (71271 call range[64316](?) unknown i[71264] unknown b[71267] unknown s[71269]), arg algn[71277]:_any[178](?)) : _unknown[51] "inline" "no doc"
  {
    (71324 call compilerError "can't align a range with idxType "(71300 call _cast string[26] i[71264]) " using a value of type "(71322 call _cast string[26](71320 'typeof' algn[71277])))
    (71328 return r[71272])
  }
  function range[64316](?).offset[71339](arg _mt[71344]:_MT[238], arg this[71341]:range[64316](?) :
  range[64316](?), in arg offset[71336] :
  integral[199](?)) : _unknown[51] "method"
  {
    unknown offs[71353](71352 call(71347 call . offset[71336] c"safeCast")(375015 call . this[71341] c"intIdxType"))
    (71356 'end of statement')
    if(71388 call _cond_test(71359 call !(375020 call . this[71341] c"stridable")))
    {
      (71380 call compilerWarning "invoking 'offset' on an unstrided range has no effect.")
      (71385 call = offs[71353] 0)
    }
    if(71424 call _cond_test(71398 call && 1(71396 call !(71395 call(375026 call . this[71341] c"hasFirst")))))
    {
      (71422 call boundsCheckHalt module=[255] HaltWrappers[209998] "invoking 'offset' on a range without the first index")
      (357817 'referenced modules list' HaltWrappers[209998])
    }
    (71450 return(71429 'new'(71449 call range[64316](?)(375032 call . this[71341] c"idxType")(375037 call . this[71341] c"boundedType")(375042 call . this[71341] c"stridable")(375046 call . this[71341] c"low")(375050 call . this[71341] c"high")(375054 call . this[71341] c"stride")(71447 call(375058 call . this[71341] c"chpl_intToIdx")(71444 call +(71440 call . this[71341] c"firstAsInt") offs[71353])) 1)))
  }
  function range[64316](?).this[71464](arg _mt[71469]:_MT[238], const arg this[71466]:range[64316](?) :
  range[64316](?), arg other[71461] :
  (71460 call range[64316](?) ?[260])) : _unknown[51] "method" "no doc"
  {
    unknown ambig[71472] 0
    (71475 'end of statement')
    if(71580 call _cond_test(71489 call ||(71482 call(71478 call . this[71466] c"isAmbiguous"))(71488 call(71484 call . other[71461] c"isAmbiguous"))))
    {
      unknown st1[71498](71497 call abs(71493 call . this[71466] c"stride"))
      (71501 'end of statement')
      unknown st2[71510](71509 call abs(71505 call . other[71461] c"stride"))
      (71513 'end of statement')
      unknown tmp[71524] "temp"(71523 call chpl__extendedEuclid st1[71498] st2[71510])
      (71531 call _check_tuple_var_decl tmp[71524] 2)
      unknown g[71514](71525 call tmp[71524] 0)
      unknown x[71516](71528 call tmp[71524] 1)
      (71536 'end of statement')
      if(71570 call _cond_test(71542 call && 1(71540 call > g[71514] 1)))
      {
        (71568 call boundsCheckHalt module=[255] HaltWrappers[209998] "Cannot slice ranges with ambiguous alignments unless their strides are relatively prime.")
        (357828 'referenced modules list' HaltWrappers[209998])
      }
      (71577 call = ambig[71472] 1)
    }
    function computeBoundedType[71588](arg r1[71586]:_any[178](?), arg r2[71590]:_any[178](?)) param : _unknown[51]
    {
      unknown low[71606] "param"(71604 call ||(71597 call(71593 call . r1[71586] c"hasLowBound"))(71603 call(71599 call . r2[71590] c"hasLowBound")))
      (71609 'end of statement')
      unknown high[71625] "param"(71623 call ||(71616 call(71612 call . r1[71586] c"hasHighBound"))(71622 call(71618 call . r2[71590] c"hasHighBound")))
      (71628 'end of statement')
      if(71671 call _cond_test(71631 call && low[71606] high[71625]))
      {
        (71637 return bounded[64205])
      }
      {
        if(71665 call _cond_test low[71606])
        {
          (71644 return boundedLow[64207])
        }
        {
          if(71659 call _cond_test high[71625])
          {
            (71651 return boundedHigh[64209])
          }
          {
            (71657 return boundedNone[64211])
          }
        }
      }
    }
    unknown lo1[71693](71690 IfExpr (71681 call(375073 call . this[71466] c"hasLowBound")) then
    { scopeless
      (71683 call . this[71466] c"_low")
    } else
    { scopeless
      (71687 call . other[71461] c"_low")
    } )
    (71696 'end of statement')
    unknown hi1[71711](71708 IfExpr (71699 call(375077 call . this[71466] c"hasHighBound")) then
    { scopeless
      (71701 call . this[71466] c"_high")
    } else
    { scopeless
      (71705 call . other[71461] c"_high")
    } )
    (71714 'end of statement')
    unknown st1[71722](71721 call abs(71717 call . this[71466] c"stride"))
    (71725 'end of statement')
    unknown lo2[71743](71740 IfExpr (71731 call(71727 call . other[71461] c"hasLowBound")) then
    { scopeless
      (71733 call . other[71461] c"_low")
    } else
    { scopeless
      (71737 call . this[71466] c"_low")
    } )
    (71746 'end of statement')
    unknown hi2[71764](71761 IfExpr (71752 call(71748 call . other[71461] c"hasHighBound")) then
    { scopeless
      (71754 call . other[71461] c"_high")
    } else
    { scopeless
      (71758 call . this[71466] c"_high")
    } )
    (71767 'end of statement')
    unknown st2[71775](71774 call abs(71770 call . other[71461] c"stride"))
    (71778 'end of statement')
    if(71798 call _cond_test(71782 call isUintType(375081 call . this[71466] c"intIdxType")))
    {
      if(71792 call _cond_test(71785 call < lo1[71693] 0))
      {
        (71789 call = lo1[71693] 0)
      }
    }
    unknown newStride[71807](71804 call . this[71466] c"stride")(375087 call . this[71466] c"strType")
    (71810 'end of statement')
    unknown lcm[71819](71818 call abs(71814 call . this[71466] c"stride"))(375091 call . this[71466] c"strType")
    (71822 'end of statement')
    unknown tmp[71840] "temp"(71838 call _build_tuple lcm[71819](71835 call _cast(375100 call . this[71466] c"strType") 0))(71830 call * 2(375095 call . this[71466] c"strType"))
    (71847 call _check_tuple_var_decl tmp[71840] 2)
    unknown g[71823](71841 call tmp[71840] 0)
    unknown x[71825](71844 call tmp[71840] 1)
    (71852 'end of statement')
    if(71955 call _cond_test(71875 call &&(71861 call !=(71854 call . this[71466] c"stride")(71858 call . other[71461] c"stride"))(71873 call !=(71864 call . this[71466] c"stride")(71871 call -(71868 call . other[71461] c"stride")))))
    {
      const tmp[71887] "const" "temp"(71886 call chpl__extendedEuclid st1[71722] st2[71775])
      (71894 call _check_tuple_var_decl tmp[71887] 2)
      const tg[71877] "const"(71888 call tmp[71887] 0)
      const tx[71879] "const"(71891 call tmp[71887] 1)
      (71899 'end of statement')
      (71923 call =(71904 call _build_tuple g[71823] x[71825])(71921 call _build_tuple(71912 call(71907 call . tg[71877] c"safeCast")(375108 call . this[71466] c"strType"))(71919 call(71914 call . tx[71879] c"safeCast")(375112 call . this[71466] c"strType"))))
      (71934 call = lcm[71819](71932 call *(71929 call / st1[71722] g[71823]) st2[71775]))
      (71952 call = newStride[71807](71949 IfExpr (71943 call >(71939 call . this[71466] c"stride") 0) then
      { scopeless
        lcm[71819]
      } else
      { scopeless
        (71947 call - lcm[71819])
      } ))
    }
    unknown emptyIntersection[71960] bool[10]
    (71963 'end of statement')
    function min[71970](arg x[71967] :
    int(64)[13], arg y[71973] :
    uint(64)[115]) : _unknown[51]
    {
      if(71987 call _cond_test(71981 call > y[71973](71980 call max int(64)[13])))
      {
        (71984 return x[71967])
      }
      (72000 return(71999 call min x[71967](71997 call _cast int(64)[13] y[71973])))
    }
    function min[72010](arg x[72007] :
    uint(64)[115], arg y[72013] :
    int(64)[13]) : _unknown[51]
    {
      if(72029 call _cond_test(72018 call < y[72013] 0))
      {
        (72022 call = emptyIntersection[71960] 1)
        (72027 return x[72007])
      }
      (72042 return(72041 call min x[72007](72039 call _cast uint(64)[115] y[72013])))
    }
    function max[72052](arg x[72049] :
    int(64)[13], arg y[72055] :
    uint(64)[115]) : _unknown[51]
    {
      if(72074 call _cond_test(72063 call > y[72055](72062 call max int(64)[13])))
      {
        (72067 call = emptyIntersection[71960] 1)
        (72072 return x[72049])
      }
      (72087 return(72086 call max x[72049](72084 call _cast int(64)[13] y[72055])))
    }
    function max[72097](arg x[72094] :
    uint(64)[115], arg y[72100] :
    int(64)[13]) : _unknown[51]
    {
      if(72111 call _cond_test(72105 call < y[72100] 0))
      {
        (72108 return x[72094])
      }
      (72124 return(72123 call max x[72094](72121 call _cast uint(64)[115] y[72100])))
    }
    (72130 call = emptyIntersection[71960] 0)
    unknown newlo[72141](72139 call _cast(375144 call . this[71466] c"intIdxType")(72137 call max lo1[71693] lo2[71743]))
    (72144 'end of statement')
    unknown newhi[72153](72151 call _cast(375150 call . this[71466] c"intIdxType")(72149 call min hi1[71711] hi2[71764]))
    (72156 'end of statement')
    if(72169 call _cond_test emptyIntersection[71960])
    {
      (72160 call = newlo[72141] 1)
      (72166 call = newhi[72153] 0)
    }
    unknown result[72221](72173 'new'(72220 call range[64316](?)(375159 call . this[71466] c"idxType")(72181 call computeBoundedType this[71466] other[71461])(72190 call |(72183 call . this[71466] c"stridable")(72187 call . other[71461] c"stridable"))(72195 call(375165 call . this[71466] c"chpl_intToIdx") newlo[72141])(72199 call(375170 call . this[71466] c"chpl_intToIdx") newhi[72153]) newStride[71807](72204 call(375176 call . this[71466] c"chpl_intToIdx") 0)(72218 call &&(72206 call ! ambig[71472])(72216 call ||(72209 call . this[71466] c"aligned")(72213 call . other[71461] c"aligned")))))
    (72224 'end of statement')
    if(72430 call _cond_test(72226 call . result[72221] c"stridable"))
    {
      unknown al1[72245](72243 call _cast int(64)[13](72240 call %(72235 call chpl__idxToInt(72231 call . this[71466] c"alignment"))(72238 call _cast(375182 call . this[71466] c"intIdxType") st1[71722])))
      (72248 'end of statement')
      unknown al2[72269](72267 call _cast int(64)[13](72264 call %(72256 call chpl__idxToInt(72252 call . other[71461] c"alignment"))(72262 call _cast(72259 call . other[71461] c"intIdxType") st2[71775])))
      (72272 'end of statement')
      if(72426 call _cond_test(72281 call !=(72278 call %(72275 call - al2[72269] al1[72245]) g[71823]) 0))
      {
        if(72318 call _cond_test(72290 call && 1(72288 call !(72287 call isBoundedRange result[72221]))))
        {
          (72316 call boundsCheckHalt module=[255] HaltWrappers[209998] "could not represent range slice - it needs to be empty, but the slice type is not bounded")
          (357871 'referenced modules list' HaltWrappers[209998])
        }
        (72332 call =(72325 call . result[72221] c"_low")(72330 call _cast(375192 call . this[71466] c"intIdxType") 1))
        (72343 call =(72336 call . result[72221] c"_high")(72341 call _cast(375196 call . this[71466] c"intIdxType") 0))
        (72368 call =(72347 call . result[72221] c"_alignment")(72365 IfExpr (72355 call >(72351 call . this[71466] c"stride") 0) then
        { scopeless
          (72359 call _cast(375200 call . this[71466] c"intIdxType") 1)
        } else
        { scopeless
          (72363 call _cast(375204 call . this[71466] c"intIdxType") 0)
        } ))
      }
      {
        unknown offset[72378](72376 call *(72373 call - al2[72269] al1[72245]) x[71825])
        (72381 'end of statement')
        if(72392 call _cond_test(72385 call < offset[72378] 0))
        {
          (72389 call += offset[72378] lcm[71819])
        }
        (72423 call =(72398 call . result[72221] c"_alignment")(72421 call +(72403 call _cast(375215 call . this[71466] c"intIdxType") al1[72245])(72419 call /(72413 call *(72407 call _cast(375220 call . this[71466] c"intIdxType") offset[72378])(72411 call _cast(375225 call . this[71466] c"intIdxType") st1[71722]))(72417 call _cast(375230 call . this[71466] c"intIdxType") g[71823]))))
      }
    }
    (72435 return result[72221])
  }
  function chpl_count_help[72448](arg r[72445] :
  (72444 call range[64316](?) ?[260]), arg i[72450]:_any[178](?)) : _unknown[51] "no return value for void"
  {
    (72483 call compilerError "count operator is not defined for unbounded ranges")
  }
  where {
    (72460 call ==(72453 call . r[72445] c"boundedType") boundedNone[64211])
  }
  function chpl_count_help[72493](arg r[72491]:_any[178](?), arg count[72496] :
  integral[199](?)) : _unknown[51]
  {
    if(72531 call _cond_test(72506 call && 1(72505 call(72501 call . r[72491] c"isAmbiguous"))))
    {
      (72529 call boundsCheckHalt "count -- Cannot count off elements from a range which is ambiguously aligned.")
    }
    unknown resultType[72541] "type variable"(72538 call . r[72491] c"intIdxType")
    unknown strType[72548] "type variable"(72547 call chpl__rangeStrideType resultType[72541])
    function absSameType[72555](arg str[72553]:_any[178](?)) : _unknown[51]
    {
      if(72586 call _cond_test(72562 call <(72558 call . r[72491] c"stride") 0))
      {
        (72573 return(72571 call _cast resultType[72541](72568 call -(72565 call . r[72491] c"stride"))))
      }
      {
        (72583 return(72581 call _cast resultType[72541](72577 call . r[72491] c"stride")))
      }
    }
    if(72795 call _cond_test(72595 call == count[72496] 0))
    {
      if(72789 call _cond_test(72602 call(72598 call . r[72491] c"hasLowBound")))
      {
        (72677 return(72603 'new'(72676 call range[64316](?)(idxType =(72606 call . r[72491] c"idxType"))(boundedType = bounded[64205])(stridable =(72617 call . r[72491] c"stridable"))(_low =(72631 call chpl__intToIdx(72623 call . r[72491] c"idxType")(72628 call . r[72491] c"_low")))(_high =(72652 call chpl__intToIdx(72635 call . r[72491] c"idxType")(72650 call -(72640 call . r[72491] c"_low")(72649 call absSameType(72645 call . r[72491] c"stride")))))(_stride =(72655 call . r[72491] c"stride"))(_alignment =(72669 call chpl__intToIdx(72661 call . r[72491] c"idxType")(72666 call . r[72491] c"_alignment")))(_aligned =(72672 call . r[72491] c"aligned")))))
      }
      {
        if(72785 call _cond_test(72685 call(72681 call . r[72491] c"hasHighBound")))
        {
          (72760 return(72686 'new'(72759 call range[64316](?)(idxType =(72689 call . r[72491] c"idxType"))(boundedType = bounded[64205])(stridable =(72700 call . r[72491] c"stridable"))(_low =(72723 call chpl__intToIdx(72706 call . r[72491] c"idxType")(72721 call +(72711 call . r[72491] c"_high")(72720 call absSameType(72716 call . r[72491] c"stride")))))(_high =(72735 call chpl__intToIdx(72727 call . r[72491] c"idxType")(72732 call . r[72491] c"_high")))(_stride =(72738 call . r[72491] c"stride"))(_alignment =(72752 call chpl__intToIdx(72744 call . r[72491] c"idxType")(72749 call . r[72491] c"_alignment")))(_aligned =(72755 call . r[72491] c"aligned")))))
        }
        {
          (72782 call halt "Internal error: Unexpected case in chpl_count_help")
        }
      }
    }
    if(72837 call _cond_test(72814 call &&(72808 call && 1(72806 call !(72805 call(72801 call . r[72491] c"hasFirst"))))(72812 call > count[72496] 0)))
    {
      (72835 call boundsCheckHalt "With a positive count, the range must have a first index.")
    }
    if(72882 call _cond_test(72859 call &&(72853 call && 1(72851 call !(72850 call(72846 call . r[72491] c"hasLast"))))(72857 call < count[72496] 0)))
    {
      (72880 call boundsCheckHalt "With a negative count, the range must have a last index.")
    }
    if(72981 call _cond_test(72929 call &&(72898 call && 1(72896 call ==(72889 call . r[72491] c"boundedType") bounded[64205]))(72927 call >(72915 call _cast(72914 call uint(64)[115] 64)(72910 call abs(72907 call _cast(72906 call chpl__maxIntTypeSameSign(72904 'typeof' count[72496])) count[72496])))(72925 call _cast(72924 call uint(64)[115] 64)(72918 call . r[72491] c"size")))))
    {
      (72978 call boundsCheckHalt(72975 call +(72956 call + "bounded range is too small to access "(72954 call _cast string[26](72952 call abs count[72496]))) " elements"))
    }
    function chpl__computeTypeForCountMath[72989](arg t1[72987]:_any[178](?), arg t2[72991]:_any[178](?)) type : _unknown[51]
    {
      if(73049 call _cond_test(72995 call == t1[72987] t2[72991]))
      {
        (73001 return(73000 call chpl__idxTypeToIntIdxType t1[72987]))
      }
      {
        if(73045 call _cond_test(73018 call ||(73009 call ==(73007 call numBits t1[72987]) 64)(73016 call ==(73014 call numBits t2[72991]) 64)))
        {
          (73024 return(73023 call int(64)[13] 64))
        }
        {
          unknown x1[73028] t1[72987]
          (73031 'end of statement')
          unknown x2[73034] t2[72991]
          (73037 'end of statement')
          (73043 return(73042 'typeof'(73040 call + x1[73028] x2[73034])))
        }
      }
    }
    unknown computeType[73063] "type variable"(73062 call chpl__computeTypeForCountMath resultType[72541](73061 'typeof' count[72496]))
    unknown signedComputeType[73070] "type variable"(73069 call chpl__signedType computeType[73063])
    unknown diff[73086](73084 call *(73075 call _cast signedComputeType[73070] count[72496])(73082 call _cast signedComputeType[73070](73078 call . r[72491] c"stride")))
    (73089 'end of statement')
    unknown lo[73120](73117 IfExpr (73093 call > diff[73086] 0) then
    { scopeless
      (73096 call . r[72491] c"_low")
    } else
    { scopeless
      (73116 call chpl__add(73105 call _cast computeType[73063](73101 call . r[72491] c"_high"))(73113 call _cast computeType[73063](73110 call + diff[73086] 1)) resultType[72541])
    } ) resultType[72541]
    (73123 'end of statement')
    unknown hi[73154](73151 IfExpr (73127 call < diff[73086] 0) then
    { scopeless
      (73130 call . r[72491] c"_high")
    } else
    { scopeless
      (73150 call chpl__add(73139 call _cast computeType[73063](73135 call . r[72491] c"_low"))(73147 call -(73144 call _cast computeType[73063] diff[73086]) 1) resultType[72541])
    } ) resultType[72541]
    (73157 'end of statement')
    if(73219 call _cond_test(73159 call . r[72491] c"stridable"))
    {
      if(73185 call _cond_test(73175 call &&(73167 call(73163 call . r[72491] c"hasLowBound"))(73173 call < lo[73120](73170 call . r[72491] c"_low"))))
      {
        (73182 call = lo[73120](73179 call . r[72491] c"_low"))
      }
      if(73214 call _cond_test(73204 call &&(73196 call(73192 call . r[72491] c"hasHighBound"))(73202 call > hi[73154](73199 call . r[72491] c"_high"))))
      {
        (73211 call = hi[73154](73208 call . r[72491] c"_high"))
      }
    }
    (73300 return(73223 'new'(73299 call range[64316](?)(idxType =(73226 call . r[72491] c"idxType"))(boundedType = bounded[64205])(stridable =(73237 call . r[72491] c"stridable"))(_low =(73247 call(73242 call . r[72491] c"chpl_intToIdx") lo[73120]))(_high =(73255 call(73250 call . r[72491] c"chpl_intToIdx") hi[73154]))(_stride =(73269 IfExpr (73258 call . r[72491] c"stridable") then
    { scopeless
      (73266 call _cast strType[72548](73262 call . r[72491] c"stride"))
    } else
    { scopeless
      none[57]
    } ))(_alignment =(73282 IfExpr (73274 call . r[72491] c"stridable") then
    { scopeless
      (73278 call . r[72491] c"alignment")
    } else
    { scopeless
      none[57]
    } ))(_aligned =(73295 IfExpr (73287 call . r[72491] c"stridable") then
    { scopeless
      (73291 call . r[72491] c"aligned")
    } else
    { scopeless
      none[57]
    } )))))
  }
  function #[73314](arg r[73311] :
  (73310 call range[64316](?) unknown i[73307]), arg count[73320] :
  (73319 call chpl__rangeStrideType i[73307])) : _unknown[51]
  {
    (73328 return(73327 call chpl_count_help r[73311] count[73320]))
  }
  function #[73343](arg r[73340] :
  (73339 call range[64316](?) unknown i[73336]), arg count[73349] :
  (73348 call chpl__rangeUnsignedType i[73336])) : _unknown[51]
  {
    (73357 return(73356 call chpl_count_help r[73340] count[73349]))
  }
  function #[73372](arg r[73369] :
  (73368 call range[64316](?) unknown i[73365]), arg count[73374]:_any[178](?)) : _unknown[51]
  {
    (73421 call compilerError "can't apply '#' to a range with idxType "(73397 call _cast string[26] i[73365]) " using a count of type "(73419 call _cast string[26](73417 'typeof' count[73374])))
    (73425 return r[73369])
  }
  function chpl_checkIfRangeIterWillOverflow[73433](arg idxType[73431]:_any[178](?), arg low[73435]:_any[178](?), arg high[73437]:_any[178](?), arg stride[73439]:_any[178](?), arg first[73442] =
  low[73435], arg last[73446] =
  high[73437], arg shouldHalt[73450] =
  1) : _unknown[51]
  {
    if(73461 call _cond_test(73455 call > low[73435] high[73437]))
    {
      (73458 return 0)
    }
    unknown willOverFlow[73467] 0
    (73470 'end of statement')
    if(73654 call _cond_test(73474 call isIntType idxType[73431]))
    {
      if(73541 call _cond_test(73483 call &&(73477 call > last[73446] 0)(73481 call > stride[73439] 0)))
      {
        if(73501 call _cond_test(73493 call > stride[73439](73491 call -(73489 call max idxType[73431]) last[73446])))
        {
          (73497 call = willOverFlow[73467] 1)
        }
      }
      {
        if(73537 call _cond_test(73514 call &&(73508 call < last[73446] 0)(73512 call < stride[73439] 0)))
        {
          if(73532 call _cond_test(73524 call < stride[73439](73522 call -(73520 call min idxType[73431]) last[73446])))
          {
            (73528 call = willOverFlow[73467] 1)
          }
        }
      }
    }
    {
      if(73650 call _cond_test(73550 call isUintType idxType[73431]))
      {
        if(73605 call _cond_test(73553 call > stride[73439] 0))
        {
          if(73571 call _cond_test(73563 call <(73560 call + last[73446](73558 call _cast idxType[73431] stride[73439])) last[73446]))
          {
            (73567 call = willOverFlow[73467] 1)
          }
        }
        {
          if(73601 call _cond_test(73578 call < stride[73439] 0))
          {
            if(73596 call _cond_test(73588 call >(73585 call + last[73446](73583 call _cast idxType[73431] stride[73439])) last[73446]))
            {
              (73592 call = willOverFlow[73467] 1)
            }
          }
        }
      }
      {
        (73647 call compilerError "Iterator overflow checking is only supported " "for integral types")
      }
    }
    if(73688 call _cond_test(73661 call && willOverFlow[73467] shouldHalt[73450]))
    {
      (73685 call boundsCheckHalt module=[255] HaltWrappers[209998] "Iteration over a bounded range may be incorrect due to overflow.")
      (357943 'referenced modules list' HaltWrappers[209998])
    }
    (73693 return willOverFlow[73467])
  }
  function range[64316](?).checkIfIterWillOverflow[73704](arg _mt[73709]:_MT[238], arg this[73706]:range[64316](?) :
  range[64316](?), arg shouldHalt[73701] =
  1) : _unknown[51] "method" "no doc"
  {
    (73739 return(73738 call chpl_checkIfRangeIterWillOverflow(73713 call . this[73706] c"intIdxType")(73718 call . this[73706] c"_low")(73722 call . this[73706] c"_high")(73726 call . this[73706] c"stride")(73730 call . this[73706] c"firstAsInt")(73734 call . this[73706] c"lastAsInt") shouldHalt[73701]))
  }
  function chpl_direct_range_iter[73754](arg low[73751] :
  (73750 call int(64)[13] unknown w[73747]), arg high[73760] :
  (73759 call int(64)[13] w[73747]), arg stride[73767] :
  (73766 call int(64)[13] w[73747])) : _unknown[51] "iterator fn" "no return value for void"
  {
    const r[73777] "const"(73775 call chpl_by(73772 call chpl_build_bounded_range low[73751] high[73760]) stride[73767])
    (73780 'end of statement')
    {
      unknown _indexOfInterest[73787] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[73788] "expr temp" "temp"
      (73797 'move' _iterator[73788](73795 call _getIterator r[73777]))
      Defer
      {
        {
          (73813 call _freeIterator _iterator[73788])
        }
      }
      { scopeless type
        (73802 'move' _indexOfInterest[73787](73799 call iteratorIndex _iterator[73788]))
      }
      ForLoop[73789]
      {
        unknown i[73806] "index var" "insert auto destroy"
        (73808 'move' i[73806] _indexOfInterest[73787])
        (73785 yield i[73806])
        label _continueLabel[73792]
        _indexOfInterest[73787]
        _iterator[73788]
      }
      label _breakLabel[73793]
    }
  }
  function chpl_direct_range_iter[73832](arg low[73829] :
  (73828 call uint(64)[115] unknown w[73825]), arg high[73838] :
  (73837 call uint(64)[115] w[73825]), arg stride[73845] :
  (73844 call int(64)[13] w[73825])) : _unknown[51] "iterator fn" "no return value for void"
  {
    const r[73855] "const"(73853 call chpl_by(73850 call chpl_build_bounded_range low[73829] high[73838]) stride[73845])
    (73858 'end of statement')
    {
      unknown _indexOfInterest[73865] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[73866] "expr temp" "temp"
      (73875 'move' _iterator[73866](73873 call _getIterator r[73855]))
      Defer
      {
        {
          (73891 call _freeIterator _iterator[73866])
        }
      }
      { scopeless type
        (73880 'move' _indexOfInterest[73865](73877 call iteratorIndex _iterator[73866]))
      }
      ForLoop[73867]
      {
        unknown i[73884] "index var" "insert auto destroy"
        (73886 'move' i[73884] _indexOfInterest[73865])
        (73863 yield i[73884])
        label _continueLabel[73870]
        _indexOfInterest[73865]
        _iterator[73866]
      }
      label _breakLabel[73871]
    }
  }
  function chpl_direct_range_iter[73906](arg low[73903] :
  enum[187](?), arg high[73909] :
  enum[187](?), arg stride[73913] :
  integral[199](?)) : _unknown[51] "iterator fn" "no return value for void"
  {
    const r[73923] "const"(73921 call chpl_by(73918 call chpl_build_bounded_range low[73903] high[73909]) stride[73913])
    (73926 'end of statement')
    {
      unknown _indexOfInterest[73933] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[73934] "expr temp" "temp"
      (73943 'move' _iterator[73934](73941 call _getIterator r[73923]))
      Defer
      {
        {
          (73959 call _freeIterator _iterator[73934])
        }
      }
      { scopeless type
        (73948 'move' _indexOfInterest[73933](73945 call iteratorIndex _iterator[73934]))
      }
      ForLoop[73935]
      {
        unknown i[73952] "index var" "insert auto destroy"
        (73954 'move' i[73952] _indexOfInterest[73933])
        (73931 yield i[73952])
        label _continueLabel[73938]
        _indexOfInterest[73933]
        _iterator[73934]
      }
      label _breakLabel[73939]
    }
  }
  function chpl_direct_range_iter[73974](arg low[73971] :
  bool[10], arg high[73977] :
  bool[10], arg stride[73981] :
  integral[199](?)) : _unknown[51] "iterator fn" "no return value for void"
  {
    const r[73991] "const"(73989 call chpl_by(73986 call chpl_build_bounded_range low[73971] high[73977]) stride[73981])
    (73994 'end of statement')
    {
      unknown _indexOfInterest[74001] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74002] "expr temp" "temp"
      (74011 'move' _iterator[74002](74009 call _getIterator r[73991]))
      Defer
      {
        {
          (74027 call _freeIterator _iterator[74002])
        }
      }
      { scopeless type
        (74016 'move' _indexOfInterest[74001](74013 call iteratorIndex _iterator[74002]))
      }
      ForLoop[74003]
      {
        unknown i[74020] "index var" "insert auto destroy"
        (74022 'move' i[74020] _indexOfInterest[74001])
        (73999 yield i[74020])
        label _continueLabel[74006]
        _indexOfInterest[74001]
        _iterator[74002]
      }
      label _breakLabel[74007]
    }
  }
  function chpl_direct_range_iter[74046](arg low[74043] :
  (74042 call int(64)[13] unknown w[74039]), arg high[74052] :
  (74051 call int(64)[13] w[74039]), param arg stride[74059] :
  (74058 call int(64)[13] w[74039])) : _unknown[51] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[74072] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74073] "expr temp" "temp"
      (74082 'move' _iterator[74073](74080 call _getIterator(74068 call chpl_direct_param_stride_range_iter low[74043] high[74052] stride[74059])))
      Defer
      {
        {
          (74099 call _freeIterator _iterator[74073])
        }
      }
      { scopeless type
        (74088 'move' _indexOfInterest[74072](74085 call iteratorIndex _iterator[74073]))
      }
      ForLoop[74074]
      {
        unknown i[74092] "index var" "insert auto destroy"
        (74094 'move' i[74092] _indexOfInterest[74072])
        (74070 yield i[74092])
        label _continueLabel[74077]
        _indexOfInterest[74072]
        _iterator[74073]
      }
      label _breakLabel[74078]
    }
  }
  function chpl_direct_range_iter[74119](arg low[74116] :
  (74115 call uint(64)[115] unknown w[74112]), arg high[74125] :
  (74124 call uint(64)[115] w[74112]), param arg stride[74132] :
  (74131 call int(64)[13] w[74112])) : _unknown[51] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[74145] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74146] "expr temp" "temp"
      (74155 'move' _iterator[74146](74153 call _getIterator(74141 call chpl_direct_param_stride_range_iter low[74116] high[74125] stride[74132])))
      Defer
      {
        {
          (74172 call _freeIterator _iterator[74146])
        }
      }
      { scopeless type
        (74161 'move' _indexOfInterest[74145](74158 call iteratorIndex _iterator[74146]))
      }
      ForLoop[74147]
      {
        unknown i[74165] "index var" "insert auto destroy"
        (74167 'move' i[74165] _indexOfInterest[74145])
        (74143 yield i[74165])
        label _continueLabel[74150]
        _indexOfInterest[74145]
        _iterator[74146]
      }
      label _breakLabel[74151]
    }
  }
  function chpl_direct_range_iter[74188](arg low[74185] :
  enum[187](?), arg high[74191] :
  enum[187](?), param arg stride[74195] :
  integral[199](?)) : _unknown[51] "iterator fn" "no return value for void"
  {
    if(74299 call _cond_test(74200 call == stride[74195] 1))
    {
      const r[74206] "const"(74204 call chpl_build_bounded_range low[74185] high[74191])
      (74209 'end of statement')
      {
        unknown _indexOfInterest[74216] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[74217] "expr temp" "temp"
        (74226 'move' _iterator[74217](74224 call _getIterator r[74206]))
        Defer
        {
          {
            (74242 call _freeIterator _iterator[74217])
          }
        }
        { scopeless type
          (74231 'move' _indexOfInterest[74216](74228 call iteratorIndex _iterator[74217]))
        }
        ForLoop[74218]
        {
          unknown i[74235] "index var" "insert auto destroy"
          (74237 'move' i[74235] _indexOfInterest[74216])
          (74214 yield i[74235])
          label _continueLabel[74221]
          _indexOfInterest[74216]
          _iterator[74217]
        }
        label _breakLabel[74222]
      }
    }
    {
      const r[74256] "const"(74254 call chpl_by(74251 call chpl_build_bounded_range low[74185] high[74191]) stride[74195])
      (74259 'end of statement')
      {
        unknown _indexOfInterest[74266] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[74267] "expr temp" "temp"
        (74276 'move' _iterator[74267](74274 call _getIterator r[74256]))
        Defer
        {
          {
            (74292 call _freeIterator _iterator[74267])
          }
        }
        { scopeless type
          (74281 'move' _indexOfInterest[74266](74278 call iteratorIndex _iterator[74267]))
        }
        ForLoop[74268]
        {
          unknown i[74285] "index var" "insert auto destroy"
          (74287 'move' i[74285] _indexOfInterest[74266])
          (74264 yield i[74285])
          label _continueLabel[74271]
          _indexOfInterest[74266]
          _iterator[74267]
        }
        label _breakLabel[74272]
      }
    }
  }
  function chpl_direct_range_iter[74312](arg low[74309] :
  bool[10], arg high[74315] :
  bool[10], param arg stride[74319] :
  integral[199](?)) : _unknown[51] "iterator fn" "no return value for void"
  {
    if(74423 call _cond_test(74324 call == stride[74319] 1))
    {
      const r[74330] "const"(74328 call chpl_build_bounded_range low[74309] high[74315])
      (74333 'end of statement')
      {
        unknown _indexOfInterest[74340] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[74341] "expr temp" "temp"
        (74350 'move' _iterator[74341](74348 call _getIterator r[74330]))
        Defer
        {
          {
            (74366 call _freeIterator _iterator[74341])
          }
        }
        { scopeless type
          (74355 'move' _indexOfInterest[74340](74352 call iteratorIndex _iterator[74341]))
        }
        ForLoop[74342]
        {
          unknown i[74359] "index var" "insert auto destroy"
          (74361 'move' i[74359] _indexOfInterest[74340])
          (74338 yield i[74359])
          label _continueLabel[74345]
          _indexOfInterest[74340]
          _iterator[74341]
        }
        label _breakLabel[74346]
      }
    }
    {
      const r[74380] "const"(74378 call chpl_by(74375 call chpl_build_bounded_range low[74309] high[74315]) stride[74319])
      (74383 'end of statement')
      {
        unknown _indexOfInterest[74390] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[74391] "expr temp" "temp"
        (74400 'move' _iterator[74391](74398 call _getIterator r[74380]))
        Defer
        {
          {
            (74416 call _freeIterator _iterator[74391])
          }
        }
        { scopeless type
          (74405 'move' _indexOfInterest[74390](74402 call iteratorIndex _iterator[74391]))
        }
        ForLoop[74392]
        {
          unknown i[74409] "index var" "insert auto destroy"
          (74411 'move' i[74409] _indexOfInterest[74390])
          (74388 yield i[74409])
          label _continueLabel[74395]
          _indexOfInterest[74390]
          _iterator[74391]
        }
        label _breakLabel[74396]
      }
    }
  }
  function chpl_direct_range_iter[74440](arg low[74437] :
  (74436 call int(64)[13] unknown w[74433]), arg high[74446] :
  (74445 call int(64)[13] w[74433]), arg stride[74453] :
  (74452 call uint(64)[115] w[74433])) : _unknown[51] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[74466] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74467] "expr temp" "temp"
      (74476 'move' _iterator[74467](74474 call _getIterator(74462 call chpl_direct_pos_stride_range_iter low[74437] high[74446] stride[74453])))
      Defer
      {
        {
          (74493 call _freeIterator _iterator[74467])
        }
      }
      { scopeless type
        (74482 'move' _indexOfInterest[74466](74479 call iteratorIndex _iterator[74467]))
      }
      ForLoop[74468]
      {
        unknown i[74486] "index var" "insert auto destroy"
        (74488 'move' i[74486] _indexOfInterest[74466])
        (74464 yield i[74486])
        label _continueLabel[74471]
        _indexOfInterest[74466]
        _iterator[74467]
      }
      label _breakLabel[74472]
    }
  }
  function chpl_direct_range_iter[74513](arg low[74510] :
  (74509 call uint(64)[115] unknown w[74506]), arg high[74519] :
  (74518 call uint(64)[115] w[74506]), arg stride[74526] :
  (74525 call uint(64)[115] w[74506])) : _unknown[51] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[74539] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74540] "expr temp" "temp"
      (74549 'move' _iterator[74540](74547 call _getIterator(74535 call chpl_direct_pos_stride_range_iter low[74510] high[74519] stride[74526])))
      Defer
      {
        {
          (74566 call _freeIterator _iterator[74540])
        }
      }
      { scopeless type
        (74555 'move' _indexOfInterest[74539](74552 call iteratorIndex _iterator[74540]))
      }
      ForLoop[74541]
      {
        unknown i[74559] "index var" "insert auto destroy"
        (74561 'move' i[74559] _indexOfInterest[74539])
        (74537 yield i[74559])
        label _continueLabel[74544]
        _indexOfInterest[74539]
        _iterator[74540]
      }
      label _breakLabel[74545]
    }
  }
  function chpl_direct_range_iter[74586](arg low[74583] :
  (74582 call int(64)[13] unknown w[74579]), arg high[74592] :
  (74591 call int(64)[13] w[74579]), arg stride[74595]:_any[178](?)) : _unknown[51] "iterator fn" "no return value for void"
  {
    (74613 call compilerError "can't apply 'by' to a range with idxType "(74605 call _cast string[26](74603 call int(64)[13] w[74579])) " using a step of type "(74611 call _cast string[26](74609 'typeof' stride[74595])))
  }
  function chpl_direct_range_iter[74628](arg low[74625] :
  (74624 call uint(64)[115] unknown w[74621]), arg high[74634] :
  (74633 call uint(64)[115] w[74621]), arg stride[74637]:_any[178](?)) : _unknown[51] "iterator fn" "no return value for void"
  {
    (74655 call compilerError "can't apply 'by' to a range with idxType "(74647 call _cast string[26](74645 call uint(64)[115] w[74621])) " using a step of type "(74653 call _cast string[26](74651 'typeof' stride[74637])))
  }
  function chpl_direct_range_iter[74664](arg low[74662]:_any[178](?), arg high[74666]:_any[178](?), arg stride[74668]:_any[178](?)) : _unknown[51] "iterator fn" "no return value for void"
  {
    (74673 call compilerError "Bounds of 'low..high' must be integers of compatible types.")
  }
  function chpl_direct_counted_range_iter[74688](arg low[74685] :
  (74684 call int(64)[13] unknown w[74681]), arg count[74694] :
  (74693 call int(64)[13] w[74681])) : _unknown[51] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[74706] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74707] "expr temp" "temp"
      (74716 'move' _iterator[74707](74714 call _getIterator(74702 call chpl_direct_counted_range_iter_helper low[74685] count[74694])))
      Defer
      {
        {
          (74733 call _freeIterator _iterator[74707])
        }
      }
      { scopeless type
        (74722 'move' _indexOfInterest[74706](74719 call iteratorIndex _iterator[74707]))
      }
      ForLoop[74708]
      {
        unknown i[74726] "index var" "insert auto destroy"
        (74728 'move' i[74726] _indexOfInterest[74706])
        (74704 yield i[74726])
        label _continueLabel[74711]
        _indexOfInterest[74706]
        _iterator[74707]
      }
      label _breakLabel[74712]
    }
  }
  function chpl_direct_counted_range_iter[74753](arg low[74750] :
  (74749 call int(64)[13] unknown w[74746]), arg count[74759] :
  (74758 call uint(64)[115] w[74746])) : _unknown[51] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[74771] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74772] "expr temp" "temp"
      (74781 'move' _iterator[74772](74779 call _getIterator(74767 call chpl_direct_counted_range_iter_helper low[74750] count[74759])))
      Defer
      {
        {
          (74798 call _freeIterator _iterator[74772])
        }
      }
      { scopeless type
        (74787 'move' _indexOfInterest[74771](74784 call iteratorIndex _iterator[74772]))
      }
      ForLoop[74773]
      {
        unknown i[74791] "index var" "insert auto destroy"
        (74793 'move' i[74791] _indexOfInterest[74771])
        (74769 yield i[74791])
        label _continueLabel[74776]
        _indexOfInterest[74771]
        _iterator[74772]
      }
      label _breakLabel[74777]
    }
  }
  function chpl_direct_counted_range_iter[74818](arg low[74815] :
  (74814 call uint(64)[115] unknown w[74811]), arg count[74824] :
  (74823 call int(64)[13] w[74811])) : _unknown[51] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[74836] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74837] "expr temp" "temp"
      (74846 'move' _iterator[74837](74844 call _getIterator(74832 call chpl_direct_counted_range_iter_helper low[74815] count[74824])))
      Defer
      {
        {
          (74863 call _freeIterator _iterator[74837])
        }
      }
      { scopeless type
        (74852 'move' _indexOfInterest[74836](74849 call iteratorIndex _iterator[74837]))
      }
      ForLoop[74838]
      {
        unknown i[74856] "index var" "insert auto destroy"
        (74858 'move' i[74856] _indexOfInterest[74836])
        (74834 yield i[74856])
        label _continueLabel[74841]
        _indexOfInterest[74836]
        _iterator[74837]
      }
      label _breakLabel[74842]
    }
  }
  function chpl_direct_counted_range_iter[74883](arg low[74880] :
  (74879 call uint(64)[115] unknown w[74876]), arg count[74889] :
  (74888 call uint(64)[115] w[74876])) : _unknown[51] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[74901] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74902] "expr temp" "temp"
      (74911 'move' _iterator[74902](74909 call _getIterator(74897 call chpl_direct_counted_range_iter_helper low[74880] count[74889])))
      Defer
      {
        {
          (74928 call _freeIterator _iterator[74902])
        }
      }
      { scopeless type
        (74917 'move' _indexOfInterest[74901](74914 call iteratorIndex _iterator[74902]))
      }
      ForLoop[74903]
      {
        unknown i[74921] "index var" "insert auto destroy"
        (74923 'move' i[74921] _indexOfInterest[74901])
        (74899 yield i[74921])
        label _continueLabel[74906]
        _indexOfInterest[74901]
        _iterator[74902]
      }
      label _breakLabel[74907]
    }
  }
  function chpl_direct_counted_range_iter[74944](arg low[74941] :
  enum[187](?), arg count[74951] :
  (74950 call int(64)[13] unknown w[74947])) : _unknown[51] "iterator fn" "no return value for void"
  {
    const r[74957] "const"(74955 call chpl_build_low_bounded_range low[74941])
    (74960 'end of statement')
    {
      unknown _indexOfInterest[74970] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74971] "expr temp" "temp"
      (74980 'move' _iterator[74971](74978 call _getIterator(74965 call # r[74957] count[74951])))
      Defer
      {
        {
          (74998 call _freeIterator _iterator[74971])
        }
      }
      { scopeless type
        (74987 'move' _indexOfInterest[74970](74984 call iteratorIndex _iterator[74971]))
      }
      ForLoop[74972]
      {
        unknown i[74991] "index var" "insert auto destroy"
        (74993 'move' i[74991] _indexOfInterest[74970])
        (74968 yield i[74991])
        label _continueLabel[74975]
        _indexOfInterest[74970]
        _iterator[74971]
      }
      label _breakLabel[74976]
    }
  }
  function chpl_direct_counted_range_iter[75013](arg low[75010] :
  enum[187](?), arg count[75020] :
  (75019 call uint(64)[115] unknown w[75016])) : _unknown[51] "iterator fn" "no return value for void"
  {
    const r[75026] "const"(75024 call chpl_build_low_bounded_range low[75010])
    (75029 'end of statement')
    {
      unknown _indexOfInterest[75039] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[75040] "expr temp" "temp"
      (75049 'move' _iterator[75040](75047 call _getIterator(75034 call # r[75026] count[75020])))
      Defer
      {
        {
          (75067 call _freeIterator _iterator[75040])
        }
      }
      { scopeless type
        (75056 'move' _indexOfInterest[75039](75053 call iteratorIndex _iterator[75040]))
      }
      ForLoop[75041]
      {
        unknown i[75060] "index var" "insert auto destroy"
        (75062 'move' i[75060] _indexOfInterest[75039])
        (75037 yield i[75060])
        label _continueLabel[75044]
        _indexOfInterest[75039]
        _iterator[75040]
      }
      label _breakLabel[75045]
    }
  }
  function chpl_direct_counted_range_iter[75082](arg low[75079] :
  bool[10], arg count[75089] :
  (75088 call int(64)[13] unknown w[75085])) : _unknown[51] "iterator fn" "no return value for void"
  {
    const r[75095] "const"(75093 call chpl_build_low_bounded_range low[75079])
    (75098 'end of statement')
    {
      unknown _indexOfInterest[75108] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[75109] "expr temp" "temp"
      (75118 'move' _iterator[75109](75116 call _getIterator(75103 call # r[75095] count[75089])))
      Defer
      {
        {
          (75136 call _freeIterator _iterator[75109])
        }
      }
      { scopeless type
        (75125 'move' _indexOfInterest[75108](75122 call iteratorIndex _iterator[75109]))
      }
      ForLoop[75110]
      {
        unknown i[75129] "index var" "insert auto destroy"
        (75131 'move' i[75129] _indexOfInterest[75108])
        (75106 yield i[75129])
        label _continueLabel[75113]
        _indexOfInterest[75108]
        _iterator[75109]
      }
      label _breakLabel[75114]
    }
  }
  function chpl_direct_counted_range_iter[75151](arg low[75148] :
  bool[10], arg count[75158] :
  (75157 call uint(64)[115] unknown w[75154])) : _unknown[51] "iterator fn" "no return value for void"
  {
    const r[75164] "const"(75162 call chpl_build_low_bounded_range low[75148])
    (75167 'end of statement')
    {
      unknown _indexOfInterest[75177] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[75178] "expr temp" "temp"
      (75187 'move' _iterator[75178](75185 call _getIterator(75172 call # r[75164] count[75158])))
      Defer
      {
        {
          (75205 call _freeIterator _iterator[75178])
        }
      }
      { scopeless type
        (75194 'move' _indexOfInterest[75177](75191 call iteratorIndex _iterator[75178]))
      }
      ForLoop[75179]
      {
        unknown i[75198] "index var" "insert auto destroy"
        (75200 'move' i[75198] _indexOfInterest[75177])
        (75175 yield i[75198])
        label _continueLabel[75182]
        _indexOfInterest[75177]
        _iterator[75178]
      }
      label _breakLabel[75183]
    }
  }
  function chpl_direct_counted_range_iter[75220](arg low[75217] :
  integral[199](?), arg count[75222]:_any[178](?)) : _unknown[51] "iterator fn" "no return value for void"
  {
    (75238 call compilerError "can't apply '#' to a range with idxType "(75230 call _cast string[26](75228 'typeof' low[75217])) " using a count of type "(75236 call _cast string[26](75234 'typeof' count[75222])))
  }
  function chpl_direct_counted_range_iter[75247](arg low[75245]:_any[178](?), arg count[75249]:_any[178](?)) : _unknown[51] "iterator fn" "no return value for void"
  {
    (75254 call compilerError "Bound of 'low..' must be an integer")
  }
  function chpl_direct_counted_range_iter_helper[75263](arg low[75261]:_any[178](?), arg count[75265]:_any[178](?)) : _unknown[51] "iterator fn" "no return value for void"
  {
    if(75289 call _cond_test(75279 call &&(75273 call && 1(75272 call isIntType(75270 'typeof' count[75265])))(75277 call < count[75265] 0)))
    {
      (75287 call boundsCheckHalt module=[255] HaltWrappers[209998] "With a negative count, the range must have a last index.")
      (357955 'referenced modules list' HaltWrappers[209998])
    }
    const tmp[75337] "const" "temp"(75334 IfExpr (75302 call == count[75265] 0) then
    { scopeless
      (75317 call _build_tuple low[75261](75314 call _cast(75313 'typeof' low[75261])(75310 call -(75307 call _cast uint(64)[115] low[75261]) 1)))
    } else
    { scopeless
      (75332 call _build_tuple low[75261](75329 call + low[75261](75327 call -(75324 call _cast(75323 'typeof' low[75261]) count[75265]) 1)))
    } )
    (75344 call _check_tuple_var_decl tmp[75337] 2)
    const start[75295] "const"(75338 call tmp[75337] 0)
    const end[75297] "const"(75341 call tmp[75337] 1)
    (75349 'end of statement')
    {
      unknown _indexOfInterest[75360] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[75361] "expr temp" "temp"
      (75370 'move' _iterator[75361](75368 call _getIterator(75356 call chpl_direct_param_stride_range_iter start[75295] end[75297] 1)))
      Defer
      {
        {
          (75387 call _freeIterator _iterator[75361])
        }
      }
      { scopeless type
        (75376 'move' _indexOfInterest[75360](75373 call iteratorIndex _iterator[75361]))
      }
      ForLoop[75362]
      {
        unknown i[75380] "index var" "insert auto destroy"
        (75382 'move' i[75380] _indexOfInterest[75360])
        (75358 yield i[75380])
        label _continueLabel[75365]
        _indexOfInterest[75360]
        _iterator[75361]
      }
      label _breakLabel[75366]
    }
  }
  function chpl_direct_pos_stride_range_iter[75403](arg low[75400] :
  unknown t[75398], arg high[75405]:_any[178](?), arg stride[75407]:_any[178](?)) : _unknown[51] "iterator fn" "no return value for void"
  {
    if(75551 call _cond_test useOptimizedRangeIterators[64200])
    {
      (75414 call chpl_range_check_stride stride[75407] t[75398])
      if(75426 call _cond_test 1)
      {
        (75424 call chpl_checkIfRangeIterWillOverflow t[75398] low[75400] high[75405] stride[75407])
      }
      unknown i[75432] t[75398]
      (75435 'end of statement')
      CForLoop[75478]
      {
        {
          (75474 yield i[75432])
        }
        label _continueLabel[75494]
        {
          (75479 '=' i[75432] low[75400])
        }
        {
          (75482 '<=' i[75432] high[75405])
        }
        {
          (75485 '+=' i[75432](75488 call _cast t[75398] stride[75407]))
        }
      }
      label _breakLabel[75495]
    }
    {
      {
        unknown _indexOfInterest[75516] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[75517] "expr temp" "temp"
        (75526 'move' _iterator[75517](75524 call _getIterator(75512 call(75508 call .(75504 call chpl_by(75501 call chpl_build_bounded_range low[75400] high[75405]) stride[75407]) c"generalIterator"))))
        Defer
        {
          {
            (75543 call _freeIterator _iterator[75517])
          }
        }
        { scopeless type
          (75532 'move' _indexOfInterest[75516](75529 call iteratorIndex _iterator[75517]))
        }
        ForLoop[75518]
        {
          unknown i[75536] "index var" "insert auto destroy"
          (75538 'move' i[75536] _indexOfInterest[75516])
          (75514 yield i[75536])
          label _continueLabel[75521]
          _indexOfInterest[75516]
          _iterator[75517]
        }
        label _breakLabel[75522]
      }
    }
  }
  function chpl_direct_param_stride_range_iter[75565](arg low[75562] :
  unknown t[75560], arg high[75567]:_any[178](?), param arg stride[75569]:_any[178](?)) : _unknown[51] "iterator fn" "no return value for void"
  {
    if(75776 call _cond_test useOptimizedRangeIterators[64200])
    {
      (75576 call chpl_range_check_stride stride[75569] t[75560])
      unknown i[75580] t[75560]
      (75583 'end of statement')
      if(75720 call _cond_test(75586 call > stride[75569] 0))
      {
        if(75597 call _cond_test 1)
        {
          (75595 call chpl_checkIfRangeIterWillOverflow t[75560] low[75562] high[75567] stride[75569])
        }
        CForLoop[75629]
        {
          {
            (75625 yield i[75580])
          }
          label _continueLabel[75645]
          {
            (75630 '=' i[75580] low[75562])
          }
          {
            (75633 '<=' i[75580] high[75567])
          }
          {
            (75636 '+=' i[75580](75639 call _cast t[75560] stride[75569]))
          }
        }
        label _breakLabel[75646]
      }
      {
        if(75716 call _cond_test(75651 call < stride[75569] 0))
        {
          if(75664 call _cond_test 1)
          {
            (75662 call chpl_checkIfRangeIterWillOverflow t[75560] low[75562] high[75567] stride[75569] high[75567] low[75562])
          }
          CForLoop[75696]
          {
            {
              (75692 yield i[75580])
            }
            label _continueLabel[75712]
            {
              (75697 '=' i[75580] high[75567])
            }
            {
              (75700 '>=' i[75580] low[75562])
            }
            {
              (75703 '+=' i[75580](75706 call _cast t[75560] stride[75569]))
            }
          }
          label _breakLabel[75713]
        }
      }
    }
    {
      {
        unknown _indexOfInterest[75741] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[75742] "expr temp" "temp"
        (75751 'move' _iterator[75742](75749 call _getIterator(75737 call(75733 call .(75731 call chpl_by(75728 call chpl_build_bounded_range low[75562] high[75567]) stride[75569]) c"generalIterator"))))
        Defer
        {
          {
            (75768 call _freeIterator _iterator[75742])
          }
        }
        { scopeless type
          (75757 'move' _indexOfInterest[75741](75754 call iteratorIndex _iterator[75742]))
        }
        ForLoop[75743]
        {
          unknown i[75761] "index var" "insert auto destroy"
          (75763 'move' i[75761] _indexOfInterest[75741])
          (75739 yield i[75761])
          label _continueLabel[75746]
          _indexOfInterest[75741]
          _iterator[75742]
        }
        label _breakLabel[75747]
      }
    }
  }
  function range[64316](?).these[75786](arg _mt[75791]:_MT[238], arg this[75788]:range[64316](?) :
  range[64316](?)) : _unknown[51] "iterator fn" "method" "no doc" "no return value for void"
  {
    if(75828 call _cond_test(75805 call ==(375525 call . this[75788] c"boundedType") boundedNone[64211]))
    {
      (75826 call compilerError "iteration over a range with no bounds")
    }
    if(75908 call _cond_test 1)
    {
      if(75867 call _cond_test(75841 call !(75840 call(75836 call . this[75788] c"hasFirst"))))
      {
        (75865 call boundsCheckHalt module=[255] HaltWrappers[209998] "iteration over range that has no first index")
        (357964 'referenced modules list' HaltWrappers[209998])
      }
      if(75903 call _cond_test(75878 call(75874 call . this[75788] c"isAmbiguous")))
      {
        (75901 call boundsCheckHalt module=[255] HaltWrappers[209998] "these -- Attempt to iterate over a range with ambiguous alignment.")
        (357971 'referenced modules list' HaltWrappers[209998])
      }
    }
    unknown i[75913](375530 call . this[75788] c"intIdxType")
    (75916 'end of statement')
    const start[75924] "const"(75923 call chpl__idxToInt(75919 call . this[75788] c"first"))
    (75927 'end of statement')
    CForLoop[75953]
    {
      {
        (75949 yield(75948 call(375534 call . this[75788] c"chpl_intToIdx") i[75913]))
      }
      label _continueLabel[75967]
      {
        (75954 '=' i[75913] start[75924])
      }
      {
        1
      }
      {
        (75958 '+=' i[75913](75961 call _cast(375542 call . this[75788] c"intIdxType")(375546 call . this[75788] c"stride")))
      }
    }
    label _breakLabel[75968]
  }
  where {
    (75798 call !=(375520 call . this[75788] c"boundedType") bounded[64205])
  }
  function range[64316](?).these[75977](arg _mt[75982]:_MT[238], arg this[75979]:range[64316](?) :
  range[64316](?)) : _unknown[51] "iterator fn" "method" "no doc" "no return value for void"
  {
    if(76164 call _cond_test useOptimizedRangeIterators[64200])
    {
      if(76023 call _cond_test 1)
      {
        (76001 call(375564 call . this[75979] c"checkIfIterWillOverflow"))
        if(76018 call _cond_test(76009 call(76005 call . this[75979] c"isAmbiguous")))
        {
          (76016 call boundsCheckHalt module=[255] HaltWrappers[209998] "these -- Attempt to iterate over a range with ambiguous alignment.")
          (357980 'referenced modules list' HaltWrappers[209998])
        }
      }
      unknown i[76029](375568 call . this[75979] c"intIdxType")
      (76032 'end of statement')
      const start[76037] "const"(76034 call . this[75979] c"firstAsInt")
      (76040 'end of statement')
      const end[76066] "const"(76063 IfExpr (76050 call >(76043 call . this[75979] c"low")(76047 call . this[75979] c"high")) then
      { scopeless
        start[76037]
      } else
      { scopeless
        (76061 call +(76054 call . this[75979] c"lastAsInt")(76059 call _cast(375581 call . this[75979] c"intIdxType")(375577 call . this[75979] c"stride")))
      } )(375572 call . this[75979] c"intIdxType")
      (76069 'end of statement')
      CForLoop[76099]
      {
        {
          (76095 yield(76094 call(375585 call . this[75979] c"chpl_intToIdx") i[76029]))
        }
        label _continueLabel[76115]
        {
          (76100 '=' i[76029] start[76037])
        }
        {
          (76103 '!=' i[76029] end[76066])
        }
        {
          (76106 '+=' i[76029](76109 call _cast(375595 call . this[75979] c"intIdxType")(375599 call . this[75979] c"stride")))
        }
      }
      label _breakLabel[76116]
    }
    {
      {
        unknown _indexOfInterest[76129] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[76130] "expr temp" "temp"
        (76139 'move' _iterator[76130](76137 call _getIterator(76125 call(76121 call . this[75979] c"generalIterator"))))
        Defer
        {
          {
            (76156 call _freeIterator _iterator[76130])
          }
        }
        { scopeless type
          (76145 'move' _indexOfInterest[76129](76142 call iteratorIndex _iterator[76130]))
        }
        ForLoop[76131]
        {
          unknown i[76149] "index var" "insert auto destroy"
          (76151 'move' i[76149] _indexOfInterest[76129])
          (76127 yield i[76149])
          label _continueLabel[76134]
          _indexOfInterest[76129]
          _iterator[76130]
        }
        label _breakLabel[76135]
      }
    }
  }
  where {
    (75995 call &&(75989 call ==(375551 call . this[75979] c"boundedType") bounded[64205])(75993 call ==(375556 call . this[75979] c"stridable") 1))
  }
  function range[64316](?).these[76175](arg _mt[76180]:_MT[238], arg this[76177]:range[64316](?) :
  range[64316](?)) : _unknown[51] "iterator fn" "method" "no doc" "no return value for void"
  {
    if(76322 call _cond_test useOptimizedRangeIterators[64200])
    {
      if(76201 call _cond_test 1)
      {
        (76199 call(375616 call . this[76177] c"checkIfIterWillOverflow"))
      }
      unknown i[76208](375620 call . this[76177] c"intIdxType")
      (76211 'end of statement')
      const start[76216] "const"(76213 call . this[76177] c"_low")
      (76219 'end of statement')
      const end[76224] "const"(76221 call . this[76177] c"_high")
      (76227 'end of statement')
      CForLoop[76257]
      {
        {
          (76253 yield(76252 call(375624 call . this[76177] c"chpl_intToIdx") i[76208]))
        }
        label _continueLabel[76273]
        {
          (76258 '=' i[76208] start[76216])
        }
        {
          (76261 '<=' i[76208] end[76224])
        }
        {
          (76264 '+=' i[76208](76267 call _cast(375634 call . this[76177] c"intIdxType")(375638 call . this[76177] c"stride")))
        }
      }
      label _breakLabel[76274]
    }
    {
      {
        unknown _indexOfInterest[76287] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[76288] "expr temp" "temp"
        (76297 'move' _iterator[76288](76295 call _getIterator(76283 call(76279 call . this[76177] c"generalIterator"))))
        Defer
        {
          {
            (76314 call _freeIterator _iterator[76288])
          }
        }
        { scopeless type
          (76303 'move' _indexOfInterest[76287](76300 call iteratorIndex _iterator[76288]))
        }
        ForLoop[76289]
        {
          unknown i[76307] "index var" "insert auto destroy"
          (76309 'move' i[76307] _indexOfInterest[76287])
          (76285 yield i[76307])
          label _continueLabel[76292]
          _indexOfInterest[76287]
          _iterator[76288]
        }
        label _breakLabel[76293]
      }
    }
  }
  where {
    (76193 call &&(76187 call ==(375605 call . this[76177] c"boundedType") bounded[64205])(76191 call ==(375610 call . this[76177] c"stridable") 0))
  }
  function range[64316](?).generalIterator[76333](arg _mt[76338]:_MT[238], arg this[76335]:range[64316](?) :
  range[64316](?)) : _unknown[51] "iterator fn" "method" "no doc" "no return value for void"
  {
    if(76357 call _cond_test(76347 call && 1(76346 call(76342 call . this[76335] c"isAmbiguous"))))
    {
      (76355 call boundsCheckHalt module=[255] HaltWrappers[209998] "these -- Attempt to iterate over a range with ambiguous alignment.")
      (357996 'referenced modules list' HaltWrappers[209998])
    }
    unknown i[76364](375644 call . this[76335] c"intIdxType")
    (76367 'end of statement')
    const start[76372] "const"(76369 call . this[76335] c"first")
    (76375 'end of statement')
    const end[76396] "const"(76393 IfExpr (76384 call >(76377 call . this[76335] c"low")(76381 call . this[76335] c"high")) then
    { scopeless
      start[76372]
    } else
    { scopeless
      (76390 call . this[76335] c"last")
    } )
    (76399 'end of statement')
    CForLoop[76438]
    {
      {
        (76422 yield i[76364])
        if(76432 call _cond_test(76427 call == i[76364] end[76396]))
        {
          break _breakLabel[76455] _breakLabel[76455]
        }
      }
      label _continueLabel[76454]
      {
        (76439 '=' i[76364] start[76372])
      }
      {
        (76442 '>='(375654 call . this[76335] c"high")(375658 call . this[76335] c"low"))
      }
      {
        (76445 '+=' i[76364](76448 call _cast(375663 call . this[76335] c"intIdxType")(375667 call . this[76335] c"stride")))
      }
    }
    label _breakLabel[76455]
  }
  function range[64316](?).these[76467](arg _mt[76472]:_MT[238], arg this[76469]:range[64316](?) :
  range[64316](?), param arg tag[76464] :
  iterKind[453]) : _unknown[51] "iterator fn" "method" "no doc" "no return value for void"
  {
    if(76514 call _cond_test(76490 call !(76489 call isBoundedRange this[76469])))
    {
      (76511 call compilerError "parallel iteration is not supported over unbounded ranges")
    }
    if(76537 call _cond_test(76526 call && 1(76525 call(76521 call . this[76469] c"isAmbiguous"))))
    {
      (76534 call boundsCheckHalt module=[255] HaltWrappers[209998] "these -- Attempt to iterate over a range with ambiguous alignment.")
      (358008 'referenced modules list' HaltWrappers[209998])
    }
    if(76564 call _cond_test debugChapelRange[64195])
    {
      (76561 call chpl_debug_writeln "*** In range standalone iterator:")
    }
    const len[76572] "const"(76569 call . this[76469] c"size")
    (76575 'end of statement')
    const numChunks[76603] "const"(76600 IfExpr (76594 'task_get_serial') then
    { scopeless
      1
    } else
    { scopeless
      (76599 call _computeNumChunks len[76572])
    } )
    (76606 'end of statement')
    if(76649 call _cond_test debugChapelRange[64195])
    {
      (76646 call chpl_debug_writeln "*** RI: length=" len[76572] " numChunks=" numChunks[76603])
    }
    if(77304 call _cond_test(76655 call <= numChunks[76603] 1))
    {
      {
        unknown _indexOfInterest[76663] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[76664] "expr temp" "temp"
        (76673 'move' _iterator[76664](76671 call _getIterator this[76469]))
        Defer
        {
          {
            (76689 call _freeIterator _iterator[76664])
          }
        }
        { scopeless type
          (76678 'move' _indexOfInterest[76663](76675 call iteratorIndex _iterator[76664]))
        }
        ForLoop[76665]
        {
          unknown i[76682] "index var" "insert auto destroy"
          (76684 'move' i[76682] _indexOfInterest[76663])
          {
            (76660 yield i[76682])
          }
          label _continueLabel[76668]
          _indexOfInterest[76663]
          _iterator[76664]
        }
        label _breakLabel[76669]
      }
    }
    {
      {
        unknown tmpIter[76939] "expr temp" "maybe ref" "no copy" "temp"
        (76942 'move' tmpIter[76939](76702 call #(76699 call chpl_build_low_bounded_range 0) numChunks[76603]))
        unknown isRngDomArr[77284] "maybe param" "temp"
        (77299 'move' isRngDomArr[77284](77297 call ||(77286 call isBoundedRange tmpIter[76939])(77295 call ||(77289 call isDomain tmpIter[76939])(77292 call isArray tmpIter[76939]))))
        if isRngDomArr[77284]
        {
          const _coforallCount[77151] "const" "end count" "temp"
          (77220 'move' _coforallCount[77151](77217 call _endCountAlloc 1))
          unknown numTasks[77152] "temp"
          (77204 'move' numTasks[77152](77200 call . tmpIter[76939] c"size"))
          (77195 call _upEndCount _coforallCount[77151] 1 numTasks[77152])
          (77192 call chpl_resetTaskSpawn numTasks[77152])
          unknown _indexOfInterest[77159] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[77160] "expr temp" "temp"
          (77169 'move' _iterator[77160](77167 call _getIterator tmpIter[76939]))
          Defer
          {
            {
              (77185 call _freeIterator _iterator[77160])
            }
          }
          { scopeless type
            (77174 'move' _indexOfInterest[77159](77171 call iteratorIndex _iterator[77160]))
          }
          ForLoop[77161]
          {
            unknown chunk[77178] "coforall index var" "index var" "insert auto destroy"
            (77180 'move' chunk[77178] _indexOfInterest[77159])
            {
              {
                if(76946 call _cond_test(375743 call . this[76469] c"stridable"))
                {
                  const tmp[76950] "const" "temp"(76952 call _computeBlock len[76572] numChunks[76603] chunk[77178](76957 call - len[76572] 1))
                  (76962 call _check_tuple_var_decl tmp[76950] 2)
                  const lo[76965] "const"(76967 call tmp[76950] 0)
                  const hi[76970] "const"(76972 call tmp[76950] 1)
                  (76975 'end of statement')
                  const mylen[76977] "const"(76979 call - hi[76970](76982 call - lo[76965] 1))
                  (76986 'end of statement')
                  unknown low[76988](76990 call(375753 call . this[76469] c"orderToIndex") lo[76965])
                  (76993 'end of statement')
                  unknown high[76995](76997 call(375758 call . this[76469] c"chpl_intToIdx")(76999 call +(77001 call _cast(375762 call . this[76469] c"strType")(77004 call chpl__idxToInt low[76988]))(77007 call *(375767 call . this[76469] c"stride")(77010 call _cast(375771 call . this[76469] c"strType")(77013 call - mylen[76977] 1)))))
                  (77017 'end of statement')
                  if(77019 call _cond_test(77021 call <(375776 call . this[76469] c"stride") 0))
                  {
                    (77027 call <=> low[76988] high[76995])
                  }
                  {
                    unknown _indexOfInterest[77032] "an _indexOfInterest or chpl__followIdx variable" "temp"
                    unknown _iterator[77034] "expr temp" "temp"
                    (77036 'move' _iterator[77034](77039 call _getIterator(77041 call chpl_direct_range_iter low[76988] high[76995](375784 call . this[76469] c"stride"))))
                    Defer
                    {
                      {
                        (77047 call _freeIterator _iterator[77034])
                      }
                    }
                    { scopeless type
                      (77051 'move' _indexOfInterest[77032](77054 call iteratorIndex _iterator[77034]))
                    }
                    ForLoop[77056]
                    {
                      unknown i[77059] "index var" "insert auto destroy"
                      (77061 'move' i[77059] _indexOfInterest[77032])
                      {
                        (77065 yield i[77059])
                      }
                      label _continueLabel[77067]
                      _indexOfInterest[77032]
                      _iterator[77034]
                    }
                    label _breakLabel[77069]
                  }
                }
                {
                  const tmp[77073] "const" "temp"(77075 call _computeBlock len[76572] numChunks[76603] chunk[77178](77080 call . this[76469] c"_high")(77084 call . this[76469] c"_low")(77088 call . this[76469] c"_low"))
                  (77093 call _check_tuple_var_decl tmp[77073] 2)
                  const lo[77096] "const"(77098 call tmp[77073] 0)
                  const hi[77101] "const"(77103 call tmp[77073] 1)
                  (77106 'end of statement')
                  {
                    unknown _indexOfInterest[77108] "an _indexOfInterest or chpl__followIdx variable" "temp"
                    unknown _iterator[77110] "expr temp" "temp"
                    (77112 'move' _iterator[77110](77115 call _getIterator(77117 call chpl_direct_range_iter lo[77096] hi[77101] 1)))
                    Defer
                    {
                      {
                        (77123 call _freeIterator _iterator[77110])
                      }
                    }
                    { scopeless type
                      (77127 'move' _indexOfInterest[77108](77130 call iteratorIndex _iterator[77110]))
                    }
                    ForLoop[77132]
                    {
                      unknown i[77135] "index var" "insert auto destroy"
                      (77137 'move' i[77135] _indexOfInterest[77108])
                      {
                        (77141 yield(77143 call(375794 call . this[76469] c"chpl_intToIdx") i[77135]))
                      }
                      label _continueLabel[77145]
                      _indexOfInterest[77108]
                      _iterator[77110]
                    }
                    label _breakLabel[77147]
                  }
                }
              }
              (77154 call _downEndCount _coforallCount[77151] nil[44])
              (77153 'coforall loop')
            }
            label _continueLabel[77164]
            _indexOfInterest[77159]
            _iterator[77160]
          }
          label _breakLabel[77165]
          Defer
          {
            {
              (77207 call _endCountFree _coforallCount[77151])
            }
          }
          (77212 call _waitEndCount _coforallCount[77151] 1 numTasks[77152])
        }
        {
          const _coforallCount[77224] "const" "end count" "temp"
          (77281 'move' _coforallCount[77224](77278 call _endCountAlloc 1))
          unknown _indexOfInterest[77232] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[77233] "expr temp" "temp"
          (77242 'move' _iterator[77233](77240 call _getIterator tmpIter[76939]))
          Defer
          {
            {
              (77258 call _freeIterator _iterator[77233])
            }
          }
          { scopeless type
            (77247 'move' _indexOfInterest[77232](77244 call iteratorIndex _iterator[77233]))
          }
          ForLoop[77234]
          {
            unknown chunk[77251] "coforall index var" "index var" "insert auto destroy"
            (77253 'move' chunk[77251] _indexOfInterest[77232])
            (77265 call _upEndCount _coforallCount[77224] 1)
            {
              {
                if(76934 call _cond_test(375686 call . this[76469] c"stridable"))
                {
                  const tmp[76720] "const" "temp"(76719 call _computeBlock len[76572] numChunks[76603] chunk[77251](76717 call - len[76572] 1))
                  (76727 call _check_tuple_var_decl tmp[76720] 2)
                  const lo[76705] "const"(76721 call tmp[76720] 0)
                  const hi[76707] "const"(76724 call tmp[76720] 1)
                  (76732 'end of statement')
                  const mylen[76741] "const"(76739 call - hi[76707](76737 call - lo[76705] 1))
                  (76744 'end of statement')
                  unknown low[76749](76748 call(375696 call . this[76469] c"orderToIndex") lo[76705])
                  (76752 'end of statement')
                  unknown high[76775](76774 call(375701 call . this[76469] c"chpl_intToIdx")(76771 call +(76759 call _cast(375706 call . this[76469] c"strType")(76757 call chpl__idxToInt low[76749]))(76769 call *(375710 call . this[76469] c"stride")(76767 call _cast(375715 call . this[76469] c"strType")(76764 call - mylen[76741] 1)))))
                  (76778 'end of statement')
                  if(76788 call _cond_test(76781 call <(375719 call . this[76469] c"stride") 0))
                  {
                    (76785 call <=> low[76749] high[76775])
                  }
                  {
                    unknown _indexOfInterest[76805] "an _indexOfInterest or chpl__followIdx variable" "temp"
                    unknown _iterator[76806] "expr temp" "temp"
                    (76815 'move' _iterator[76806](76813 call _getIterator(76824 call chpl_direct_range_iter low[76749] high[76775](375726 call . this[76469] c"stride"))))
                    Defer
                    {
                      {
                        (76840 call _freeIterator _iterator[76806])
                      }
                    }
                    { scopeless type
                      (76829 'move' _indexOfInterest[76805](76826 call iteratorIndex _iterator[76806]))
                    }
                    ForLoop[76807]
                    {
                      unknown i[76833] "index var" "insert auto destroy"
                      (76835 'move' i[76833] _indexOfInterest[76805])
                      {
                        (76802 yield i[76833])
                      }
                      label _continueLabel[76810]
                      _indexOfInterest[76805]
                      _iterator[76806]
                    }
                    label _breakLabel[76811]
                  }
                }
                {
                  const tmp[76870] "const" "temp"(76869 call _computeBlock len[76572] numChunks[76603] chunk[77251](76858 call . this[76469] c"_high")(76862 call . this[76469] c"_low")(76866 call . this[76469] c"_low"))
                  (76877 call _check_tuple_var_decl tmp[76870] 2)
                  const lo[76847] "const"(76871 call tmp[76870] 0)
                  const hi[76849] "const"(76874 call tmp[76870] 1)
                  (76882 'end of statement')
                  {
                    unknown _indexOfInterest[76896] "an _indexOfInterest or chpl__followIdx variable" "temp"
                    unknown _iterator[76897] "expr temp" "temp"
                    (76906 'move' _iterator[76897](76904 call _getIterator(76911 call chpl_direct_range_iter lo[76847] hi[76849] 1)))
                    Defer
                    {
                      {
                        (76927 call _freeIterator _iterator[76897])
                      }
                    }
                    { scopeless type
                      (76916 'move' _indexOfInterest[76896](76913 call iteratorIndex _iterator[76897]))
                    }
                    ForLoop[76898]
                    {
                      unknown i[76920] "index var" "insert auto destroy"
                      (76922 'move' i[76920] _indexOfInterest[76896])
                      {
                        (76893 yield(76892 call(375735 call . this[76469] c"chpl_intToIdx") i[76920]))
                      }
                      label _continueLabel[76901]
                      _indexOfInterest[76896]
                      _iterator[76897]
                    }
                    label _breakLabel[76902]
                  }
                }
              }
              (77227 call _downEndCount _coforallCount[77224] nil[44])
              (77226 'coforall loop')
            }
            label _continueLabel[77237]
            _indexOfInterest[77232]
            _iterator[77233]
          }
          label _breakLabel[77238]
          Defer
          {
            {
              (77269 call _endCountFree _coforallCount[77224])
            }
          }
          (77274 call _waitEndCount _coforallCount[77224] 1)
        }
      }
    }
  }
  where {
    (76484 call &&(76479 call == tag[76464] standalone[451])(76482 call ! localeModelHasSublocales[187403]))
  }
  function range[64316](?).these[77318](arg _mt[77323]:_MT[238], arg this[77320]:range[64316](?) :
  range[64316](?), param arg tag[77315] :
  iterKind[453]) : _unknown[51] "iterator fn" "method" "no doc" "no return value for void"
  {
    if(77343 call _cond_test(77336 call !(77335 call isBoundedRange this[77320])))
    {
      (77341 call compilerError "parallel iteration is not supported over unbounded ranges")
    }
    if(77366 call _cond_test(77356 call && 1(77355 call(77351 call . this[77320] c"isAmbiguous"))))
    {
      (77364 call boundsCheckHalt module=[255] HaltWrappers[209998] "these -- Attempt to iterate over a range with ambiguous alignment.")
      (358023 'referenced modules list' HaltWrappers[209998])
    }
    if(77393 call _cond_test debugChapelRange[64195])
    {
      (77391 call chpl_debug_writeln "*** In range leader:")
    }
    const numSublocs[77406] "const"(77405 call(77401 call .(358028 call here[90435]) c"getChildCount"))
    (77409 'end of statement')
    if(79135 call _cond_test(77415 call && localeModelHasSublocales[187403](77413 call != numSublocs[77406] 0)))
    {
      const len[77421] "const"(77418 call . this[77320] c"size")
      (77424 'end of statement')
      const tasksPerLocale[77427] "const" dataParTasksPerLocale[93281]
      (77430 'end of statement')
      const ignoreRunning[77432] "const" dataParIgnoreRunningTasks[93287]
      (77435 'end of statement')
      const minIndicesPerTask[77437] "const" dataParMinGranularity[93293]
      (77440 'end of statement')
      unknown dptpl[77453](77450 IfExpr (77443 call == tasksPerLocale[77427] 0) then
      { scopeless
        (77446 call .(358031 call here[90435]) c"maxTaskPar")
      } else
      { scopeless
        tasksPerLocale[77427]
      } )
      (77456 'end of statement')
      if(77495 call _cond_test(77458 call ! ignoreRunning[77432]))
      {
        const otherTasks[77471] "const"(77469 call -(77467 call(77463 call .(358033 call here[90435]) c"runningTasks")) 1)
        (77474 'end of statement')
        (77492 call = dptpl[77453](77489 IfExpr (77479 call < otherTasks[77471] dptpl[77453]) then
        { scopeless
          (77486 call _cast int(64)[13](77483 call - dptpl[77453] otherTasks[77471]))
        } else
        { scopeless
          1
        } ))
      }
      const numSublocTasks[77504] "const"(77503 call min numSublocs[77406] dptpl[77453])
      (77507 'end of statement')
      const numChunks[77523] "const"(77520 IfExpr (77510 'task_get_serial') then
      { scopeless
        1
      } else
      { scopeless
        (77519 call _computeNumChunks numSublocTasks[77504](ignoreRunning = 1) minIndicesPerTask[77437] len[77421])
      } )
      (77526 'end of statement')
      if(77643 call _cond_test debugDataParNuma[93407])
      {
        (77640 call chpl_debug_writeln "### numSublocs = " numSublocs[77406] "\n" "### numTasksPerSubloc = " numSublocTasks[77504] "\n" "### ignoreRunning = " ignoreRunning[77432] "\n" "### minIndicesPerTask = " minIndicesPerTask[77437] "\n" "### numChunks = " numChunks[77523])
      }
      if(78748 call _cond_test(77649 call == numChunks[77523] 1))
      {
        (77660 yield(77658 call _build_tuple(77656 call chpl_build_bounded_range 0(77654 call - len[77421] 1))))
      }
      {
        {
          unknown tmpIter[78207] "expr temp" "maybe ref" "no copy" "temp"
          (78210 'move' tmpIter[78207](77668 call #(77665 call chpl_build_low_bounded_range 0) numChunks[77523]))
          unknown isRngDomArr[78728] "maybe param" "temp"
          (78743 'move' isRngDomArr[78728](78741 call ||(78730 call isBoundedRange tmpIter[78207])(78739 call ||(78733 call isDomain tmpIter[78207])(78736 call isArray tmpIter[78207]))))
          if isRngDomArr[78728]
          {
            const _coforallCount[78600] "const" "end count" "temp"
            (78665 'move' _coforallCount[78600](78662 call _endCountAlloc 0))
            unknown numTasks[78601] "temp"
            (78649 'move' numTasks[78601](78645 call . tmpIter[78207] c"size"))
            (78640 call _upEndCount _coforallCount[78600] 0 numTasks[78601])
            unknown _indexOfInterest[78607] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
            unknown _iterator[78608] "expr temp" "temp"
            (78617 'move' _iterator[78608](78615 call _getIterator tmpIter[78207]))
            Defer
            {
              {
                (78633 call _freeIterator _iterator[78608])
              }
            }
            { scopeless type
              (78622 'move' _indexOfInterest[78607](78619 call iteratorIndex _iterator[78608]))
            }
            ForLoop[78609]
            {
              unknown chunk[78626] "coforall index var" "index var" "insert auto destroy"
              (78628 'move' chunk[78626] _indexOfInterest[78607])
              const tmp[78213] "const" "temp"
              (78215 'move' tmp[78213](78217 'deref'(78218 '_wide_get_locale'(78223 call(78220 call .(358038 call here[90435]) c"getChild") chunk[78626]))))
              {
                {
                  if(78231 call _cond_test debugDataParNuma[93407])
                  {
                    if(78235 call _cond_test(78237 call != chunk[78626](78240 call chpl_getSubloc)))
                    {
                      (78244 call chpl_debug_writeln "*** ERROR: ON WRONG SUBLOC (should be " chunk[78626] ", on "(78249 call chpl_getSubloc) ") ***")
                    }
                  }
                  const tmp[78254] "const" "temp"(78256 call _computeBlock len[77421] numChunks[77523] chunk[78626](78261 call - len[77421] 1))
                  (78266 call _check_tuple_var_decl tmp[78254] 2)
                  const lo[78269] "const"(78271 call tmp[78254] 0)
                  const hi[78274] "const"(78276 call tmp[78254] 1)
                  (78279 'end of statement')
                  const locRange[78281] "const"(78283 call chpl_build_bounded_range lo[78269] hi[78274])
                  (78287 'end of statement')
                  const locLen[78289] "const"(78291 call . locRange[78281] c"size")
                  (78295 'end of statement')
                  const numSublocTasks[78297] "const"(78318 IfExpr (78299 call < chunk[78626](78302 call % dptpl[77453] numChunks[77523])) then
                  { scopeless
                    (78307 call +(78309 call / dptpl[77453] numChunks[77523]) 1)
                  } else
                  { scopeless
                    (78315 call / dptpl[77453] numChunks[77523])
                  } )
                  (78320 'end of statement')
                  const numTasks[78322] "const"(78324 call _computeNumChunks numSublocTasks[78297](ignoreRunning = 1) minIndicesPerTask[77437] locLen[78289])
                  (78331 'end of statement')
                  {
                    unknown tmpIter[78333] "expr temp" "maybe ref" "no copy" "temp"
                    (78335 'move' tmpIter[78333](78338 call #(78340 call chpl_build_low_bounded_range 0) numTasks[78322]))
                    unknown isRngDomArr[78343] "maybe param" "temp"
                    (78345 'move' isRngDomArr[78343](78348 call ||(78350 call isBoundedRange tmpIter[78333])(78353 call ||(78355 call isDomain tmpIter[78333])(78358 call isArray tmpIter[78333]))))
                    if isRngDomArr[78343]
                    {
                      const _coforallCount[78362] "const" "end count" "temp"
                      (78364 'move' _coforallCount[78362](78367 call _endCountAlloc 1))
                      unknown numTasks[78369] "temp"
                      (78371 'move' numTasks[78369](78374 call . tmpIter[78333] c"size"))
                      (78378 call _upEndCount _coforallCount[78362] 1 numTasks[78369])
                      (78383 call chpl_resetTaskSpawn numTasks[78369])
                      unknown _indexOfInterest[78385] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
                      unknown _iterator[78387] "expr temp" "temp"
                      (78389 'move' _iterator[78387](78392 call _getIterator tmpIter[78333]))
                      Defer
                      {
                        {
                          (78396 call _freeIterator _iterator[78387])
                        }
                      }
                      { scopeless type
                        (78400 'move' _indexOfInterest[78385](78403 call iteratorIndex _iterator[78387]))
                      }
                      ForLoop[78405]
                      {
                        unknown core[78408] "coforall index var" "index var" "insert auto destroy"
                        (78410 'move' core[78408] _indexOfInterest[78385])
                        {
                          {
                            const tmp[78417] "const" "temp"(78419 call _computeBlock locLen[78289] numTasks[78322] core[78408] hi[78274] lo[78269] lo[78269])
                            (78428 call _check_tuple_var_decl tmp[78417] 2)
                            const low[78431] "const"(78433 call tmp[78417] 0)
                            const high[78436] "const"(78438 call tmp[78417] 1)
                            (78441 'end of statement')
                            if(78443 call _cond_test debugDataParNuma[93407])
                            {
                              (78447 call chpl_debug_writeln "### chunk = " chunk[78626] "  core = " core[78408] "  " "locRange = " locRange[78281] "  coreRange = "(78457 call chpl_build_bounded_range low[78431] high[78436]))
                            }
                            (78461 yield(78463 call _build_tuple(78465 call chpl_build_bounded_range low[78431] high[78436])))
                          }
                          (78469 call _downEndCount _coforallCount[78362] nil[44])
                          (78414 'coforall loop')
                        }
                        label _continueLabel[78472]
                        _indexOfInterest[78385]
                        _iterator[78387]
                      }
                      label _breakLabel[78474]
                      Defer
                      {
                        {
                          (78478 call _endCountFree _coforallCount[78362])
                        }
                      }
                      (78482 call _waitEndCount _coforallCount[78362] 1 numTasks[78369])
                    }
                    {
                      const _coforallCount[78487] "const" "end count" "temp"
                      (78489 'move' _coforallCount[78487](78492 call _endCountAlloc 1))
                      unknown _indexOfInterest[78494] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
                      unknown _iterator[78496] "expr temp" "temp"
                      (78498 'move' _iterator[78496](78501 call _getIterator tmpIter[78333]))
                      Defer
                      {
                        {
                          (78505 call _freeIterator _iterator[78496])
                        }
                      }
                      { scopeless type
                        (78509 'move' _indexOfInterest[78494](78512 call iteratorIndex _iterator[78496]))
                      }
                      ForLoop[78514]
                      {
                        unknown core[78517] "coforall index var" "index var" "insert auto destroy"
                        (78519 'move' core[78517] _indexOfInterest[78494])
                        (78523 call _upEndCount _coforallCount[78487] 1)
                        {
                          {
                            const tmp[78530] "const" "temp"(78532 call _computeBlock locLen[78289] numTasks[78322] core[78517] hi[78274] lo[78269] lo[78269])
                            (78541 call _check_tuple_var_decl tmp[78530] 2)
                            const low[78544] "const"(78546 call tmp[78530] 0)
                            const high[78549] "const"(78551 call tmp[78530] 1)
                            (78554 'end of statement')
                            if(78556 call _cond_test debugDataParNuma[93407])
                            {
                              (78560 call chpl_debug_writeln "### chunk = " chunk[78626] "  core = " core[78517] "  " "locRange = " locRange[78281] "  coreRange = "(78570 call chpl_build_bounded_range low[78544] high[78549]))
                            }
                            (78574 yield(78576 call _build_tuple(78578 call chpl_build_bounded_range low[78544] high[78549])))
                          }
                          (78582 call _downEndCount _coforallCount[78487] nil[44])
                          (78527 'coforall loop')
                        }
                        label _continueLabel[78585]
                        _indexOfInterest[78494]
                        _iterator[78496]
                      }
                      label _breakLabel[78587]
                      Defer
                      {
                        {
                          (78591 call _endCountFree _coforallCount[78487])
                        }
                      }
                      (78595 call _waitEndCount _coforallCount[78487] 1)
                    }
                  }
                }
                (78602 call _downEndCount _coforallCount[78600] nil[44])
                (78226 'coforall on block' 1 tmp[78213])
              }
              label _continueLabel[78612]
              _indexOfInterest[78607]
              _iterator[78608]
            }
            label _breakLabel[78613]
            Defer
            {
              {
                (78652 call _endCountFree _coforallCount[78600])
              }
            }
            (78657 call _waitEndCount _coforallCount[78600] 0 numTasks[78601])
          }
          {
            const _coforallCount[78669] "const" "end count" "temp"
            (78725 'move' _coforallCount[78669](78722 call _endCountAlloc 0))
            unknown _indexOfInterest[78676] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
            unknown _iterator[78677] "expr temp" "temp"
            (78686 'move' _iterator[78677](78684 call _getIterator tmpIter[78207]))
            Defer
            {
              {
                (78702 call _freeIterator _iterator[78677])
              }
            }
            { scopeless type
              (78691 'move' _indexOfInterest[78676](78688 call iteratorIndex _iterator[78677]))
            }
            ForLoop[78678]
            {
              unknown chunk[78695] "coforall index var" "index var" "insert auto destroy"
              (78697 'move' chunk[78695] _indexOfInterest[78676])
              (78709 call _upEndCount _coforallCount[78669] 0)
              const tmp[78196] "const" "temp"
              (78198 'move' tmp[78196](78194 'deref'(78193 '_wide_get_locale'(77678 call(77673 call .(358035 call here[90435]) c"getChild") chunk[78695]))))
              {
                {
                  if(77751 call _cond_test debugDataParNuma[93407])
                  {
                    if(77745 call _cond_test(77684 call != chunk[78695](77683 call chpl_getSubloc)))
                    {
                      (77743 call chpl_debug_writeln "*** ERROR: ON WRONG SUBLOC (should be " chunk[78695] ", on "(77725 call chpl_getSubloc) ") ***")
                    }
                  }
                  const tmp[77771] "const" "temp"(77770 call _computeBlock len[77421] numChunks[77523] chunk[78695](77768 call - len[77421] 1))
                  (77778 call _check_tuple_var_decl tmp[77771] 2)
                  const lo[77756] "const"(77772 call tmp[77771] 0)
                  const hi[77758] "const"(77775 call tmp[77771] 1)
                  (77783 'end of statement')
                  const locRange[77788] "const"(77786 call chpl_build_bounded_range lo[77756] hi[77758])
                  (77791 'end of statement')
                  const locLen[77796] "const"(77793 call . locRange[77788] c"size")
                  (77799 'end of statement')
                  const numSublocTasks[77821] "const"(77818 IfExpr (77805 call < chunk[78695](77803 call % dptpl[77453] numChunks[77523])) then
                  { scopeless
                    (77812 call +(77809 call / dptpl[77453] numChunks[77523]) 1)
                  } else
                  { scopeless
                    (77816 call / dptpl[77453] numChunks[77523])
                  } )
                  (77824 'end of statement')
                  const numTasks[77833] "const"(77832 call _computeNumChunks numSublocTasks[77821](ignoreRunning = 1) minIndicesPerTask[77437] locLen[77796])
                  (77836 'end of statement')
                  {
                    unknown tmpIter[77982] "expr temp" "maybe ref" "no copy" "temp"
                    (77985 'move' tmpIter[77982](77842 call #(77839 call chpl_build_low_bounded_range 0) numTasks[77833]))
                    unknown isRngDomArr[78174] "maybe param" "temp"
                    (78189 'move' isRngDomArr[78174](78187 call ||(78176 call isBoundedRange tmpIter[77982])(78185 call ||(78179 call isDomain tmpIter[77982])(78182 call isArray tmpIter[77982]))))
                    if isRngDomArr[78174]
                    {
                      const _coforallCount[78041] "const" "end count" "temp"
                      (78110 'move' _coforallCount[78041](78107 call _endCountAlloc 1))
                      unknown numTasks[78042] "temp"
                      (78094 'move' numTasks[78042](78090 call . tmpIter[77982] c"size"))
                      (78085 call _upEndCount _coforallCount[78041] 1 numTasks[78042])
                      (78082 call chpl_resetTaskSpawn numTasks[78042])
                      unknown _indexOfInterest[78049] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
                      unknown _iterator[78050] "expr temp" "temp"
                      (78059 'move' _iterator[78050](78057 call _getIterator tmpIter[77982]))
                      Defer
                      {
                        {
                          (78075 call _freeIterator _iterator[78050])
                        }
                      }
                      { scopeless type
                        (78064 'move' _indexOfInterest[78049](78061 call iteratorIndex _iterator[78050]))
                      }
                      ForLoop[78051]
                      {
                        unknown core[78068] "coforall index var" "index var" "insert auto destroy"
                        (78070 'move' core[78068] _indexOfInterest[78049])
                        {
                          {
                            const tmp[77989] "const" "temp"(77991 call _computeBlock locLen[77796] numTasks[77833] core[78068] hi[77758] lo[77756] lo[77756])
                            (78000 call _check_tuple_var_decl tmp[77989] 2)
                            const low[78003] "const"(78005 call tmp[77989] 0)
                            const high[78008] "const"(78010 call tmp[77989] 1)
                            (78013 'end of statement')
                            if(78015 call _cond_test debugDataParNuma[93407])
                            {
                              (78019 call chpl_debug_writeln "### chunk = " chunk[78695] "  core = " core[78068] "  " "locRange = " locRange[77788] "  coreRange = "(78029 call chpl_build_bounded_range low[78003] high[78008]))
                            }
                            (78033 yield(78035 call _build_tuple(78037 call chpl_build_bounded_range low[78003] high[78008])))
                          }
                          (78044 call _downEndCount _coforallCount[78041] nil[44])
                          (78043 'coforall loop')
                        }
                        label _continueLabel[78054]
                        _indexOfInterest[78049]
                        _iterator[78050]
                      }
                      label _breakLabel[78055]
                      Defer
                      {
                        {
                          (78097 call _endCountFree _coforallCount[78041])
                        }
                      }
                      (78102 call _waitEndCount _coforallCount[78041] 1 numTasks[78042])
                    }
                    {
                      const _coforallCount[78114] "const" "end count" "temp"
                      (78171 'move' _coforallCount[78114](78168 call _endCountAlloc 1))
                      unknown _indexOfInterest[78122] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
                      unknown _iterator[78123] "expr temp" "temp"
                      (78132 'move' _iterator[78123](78130 call _getIterator tmpIter[77982]))
                      Defer
                      {
                        {
                          (78148 call _freeIterator _iterator[78123])
                        }
                      }
                      { scopeless type
                        (78137 'move' _indexOfInterest[78122](78134 call iteratorIndex _iterator[78123]))
                      }
                      ForLoop[78124]
                      {
                        unknown core[78141] "coforall index var" "index var" "insert auto destroy"
                        (78143 'move' core[78141] _indexOfInterest[78122])
                        (78155 call _upEndCount _coforallCount[78114] 1)
                        {
                          {
                            const tmp[77858] "const" "temp"(77857 call _computeBlock locLen[77796] numTasks[77833] core[78141] hi[77758] lo[77756] lo[77756])
                            (77865 call _check_tuple_var_decl tmp[77858] 2)
                            const low[77844] "const"(77859 call tmp[77858] 0)
                            const high[77846] "const"(77862 call tmp[77858] 1)
                            (77870 'end of statement')
                            if(77970 call _cond_test debugDataParNuma[93407])
                            {
                              (77967 call chpl_debug_writeln "### chunk = " chunk[78695] "  core = " core[78141] "  " "locRange = " locRange[77788] "  coreRange = "(77965 call chpl_build_bounded_range low[77844] high[77846]))
                            }
                            (77980 yield(77978 call _build_tuple(77976 call chpl_build_bounded_range low[77844] high[77846])))
                          }
                          (78117 call _downEndCount _coforallCount[78114] nil[44])
                          (78116 'coforall loop')
                        }
                        label _continueLabel[78127]
                        _indexOfInterest[78122]
                        _iterator[78123]
                      }
                      label _breakLabel[78128]
                      Defer
                      {
                        {
                          (78159 call _endCountFree _coforallCount[78114])
                        }
                      }
                      (78164 call _waitEndCount _coforallCount[78114] 1)
                    }
                  }
                }
                (78671 call _downEndCount _coforallCount[78669] nil[44])
                (78201 'coforall on block' 1 tmp[78196])
              }
              label _continueLabel[78681]
              _indexOfInterest[78676]
              _iterator[78677]
            }
            label _breakLabel[78682]
            Defer
            {
              {
                (78713 call _endCountFree _coforallCount[78669])
              }
            }
            (78718 call _waitEndCount _coforallCount[78669] 0)
          }
        }
      }
    }
    {
      unknown v[78756](78753 call . this[77320] c"size")
      (78759 'end of statement')
      const numChunks[78772] "const"(78769 IfExpr (78763 'task_get_serial') then
      { scopeless
        1
      } else
      { scopeless
        (78768 call _computeNumChunks v[78756])
      } )
      (78775 'end of statement')
      if(78825 call _cond_test debugChapelRange[64195])
      {
        (78783 call chpl_debug_writeln "*** RI: length=" v[78756] " numChunks=" numChunks[78772])
        (78823 call chpl_debug_writeln "*** RI: Using " numChunks[78772] " chunk(s)")
      }
      if(79130 call _cond_test(78831 call == numChunks[78772] 1))
      {
        (78842 yield(78840 call _build_tuple(78838 call chpl_build_bounded_range 0(78836 call - v[78756] 1))))
      }
      {
        {
          unknown tmpIter[78921] "expr temp" "maybe ref" "no copy" "temp"
          (78924 'move' tmpIter[78921](78849 call #(78846 call chpl_build_low_bounded_range 0) numChunks[78772]))
          unknown isRngDomArr[79110] "maybe param" "temp"
          (79125 'move' isRngDomArr[79110](79123 call ||(79112 call isBoundedRange tmpIter[78921])(79121 call ||(79115 call isDomain tmpIter[78921])(79118 call isArray tmpIter[78921]))))
          if isRngDomArr[79110]
          {
            const _coforallCount[78977] "const" "end count" "temp"
            (79046 'move' _coforallCount[78977](79043 call _endCountAlloc 1))
            unknown numTasks[78978] "temp"
            (79030 'move' numTasks[78978](79026 call . tmpIter[78921] c"size"))
            (79021 call _upEndCount _coforallCount[78977] 1 numTasks[78978])
            (79018 call chpl_resetTaskSpawn numTasks[78978])
            unknown _indexOfInterest[78985] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
            unknown _iterator[78986] "expr temp" "temp"
            (78995 'move' _iterator[78986](78993 call _getIterator tmpIter[78921]))
            Defer
            {
              {
                (79011 call _freeIterator _iterator[78986])
              }
            }
            { scopeless type
              (79000 'move' _indexOfInterest[78985](78997 call iteratorIndex _iterator[78986]))
            }
            ForLoop[78987]
            {
              unknown chunk[79004] "coforall index var" "index var" "insert auto destroy"
              (79006 'move' chunk[79004] _indexOfInterest[78985])
              {
                {
                  const tmp[78928] "const" "temp"(78930 call _computeBlock v[78756] numChunks[78772] chunk[79004](78935 call - v[78756] 1))
                  (78940 call _check_tuple_var_decl tmp[78928] 2)
                  const lo[78943] "const"(78945 call tmp[78928] 0)
                  const hi[78948] "const"(78950 call tmp[78928] 1)
                  (78953 'end of statement')
                  if(78955 call _cond_test debugChapelRange[64195])
                  {
                    (78960 call chpl_debug_writeln "*** RI: tuple = "(78963 call _build_tuple(78965 call chpl_build_bounded_range lo[78943] hi[78948])))
                  }
                  (78969 yield(78971 call _build_tuple(78973 call chpl_build_bounded_range lo[78943] hi[78948])))
                }
                (78980 call _downEndCount _coforallCount[78977] nil[44])
                (78979 'coforall loop')
              }
              label _continueLabel[78990]
              _indexOfInterest[78985]
              _iterator[78986]
            }
            label _breakLabel[78991]
            Defer
            {
              {
                (79033 call _endCountFree _coforallCount[78977])
              }
            }
            (79038 call _waitEndCount _coforallCount[78977] 1 numTasks[78978])
          }
          {
            const _coforallCount[79050] "const" "end count" "temp"
            (79107 'move' _coforallCount[79050](79104 call _endCountAlloc 1))
            unknown _indexOfInterest[79058] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
            unknown _iterator[79059] "expr temp" "temp"
            (79068 'move' _iterator[79059](79066 call _getIterator tmpIter[78921]))
            Defer
            {
              {
                (79084 call _freeIterator _iterator[79059])
              }
            }
            { scopeless type
              (79073 'move' _indexOfInterest[79058](79070 call iteratorIndex _iterator[79059]))
            }
            ForLoop[79060]
            {
              unknown chunk[79077] "coforall index var" "index var" "insert auto destroy"
              (79079 'move' chunk[79077] _indexOfInterest[79058])
              (79091 call _upEndCount _coforallCount[79050] 1)
              {
                {
                  const tmp[78866] "const" "temp"(78865 call _computeBlock v[78756] numChunks[78772] chunk[79077](78863 call - v[78756] 1))
                  (78873 call _check_tuple_var_decl tmp[78866] 2)
                  const lo[78851] "const"(78867 call tmp[78866] 0)
                  const hi[78853] "const"(78870 call tmp[78866] 1)
                  (78878 'end of statement')
                  if(78908 call _cond_test debugChapelRange[64195])
                  {
                    (78906 call chpl_debug_writeln "*** RI: tuple = "(78904 call _build_tuple(78902 call chpl_build_bounded_range lo[78851] hi[78853])))
                  }
                  (78919 yield(78917 call _build_tuple(78915 call chpl_build_bounded_range lo[78851] hi[78853])))
                }
                (79053 call _downEndCount _coforallCount[79050] nil[44])
                (79052 'coforall loop')
              }
              label _continueLabel[79063]
              _indexOfInterest[79058]
              _iterator[79059]
            }
            label _breakLabel[79064]
            Defer
            {
              {
                (79095 call _endCountFree _coforallCount[79050])
              }
            }
            (79100 call _waitEndCount _coforallCount[79050] 1)
          }
        }
      }
    }
  }
  where {
    (77330 call == tag[77315] leader[447])
  }
  function range[64316](?).these[79149](arg _mt[79156]:_MT[238], arg this[79153]:range[64316](?) :
  range[64316](?), param arg tag[79146] :
  iterKind[453], arg followThis[79151]:_any[178](?)) : _unknown[51] "iterator fn" "method" "no doc" "no return value for void"
  {
    if(79182 call _cond_test(79172 call && 1(79171 call(79167 call . this[79153] c"isAmbiguous"))))
    {
      (79180 call boundsCheckHalt module=[255] HaltWrappers[209998] "these -- Attempt to iterate over a range with ambiguous alignment.")
      (358045 'referenced modules list' HaltWrappers[209998])
    }
    if(79200 call _cond_test(79193 call ==(375959 call . this[79153] c"boundedType") boundedNone[64211]))
    {
      (79198 call compilerError "iteration over a range with no bounds")
    }
    if(79238 call _cond_test(79215 call &&(79206 call !(375964 call . this[79153] c"stridable"))(79213 call ==(375969 call . this[79153] c"boundedType") boundedHigh[64209])))
    {
      (79236 call compilerError "iteration over a range with no first index")
    }
    if(79271 call _cond_test(79248 call !=(79244 call . followThis[79151] c"size") 1))
    {
      (79269 call compilerError "iteration over a range with multi-dimensional iterator")
    }
    if(79299 call _cond_test debugChapelRange[64195])
    {
      (79297 call chpl_debug_writeln "In range follower code: Following " followThis[79151])
    }
    unknown myFollowThis[79308](79307 call followThis[79151] 0)
    (79311 'end of statement')
    if(79335 call _cond_test debugChapelRange[64195])
    {
      (79333 call chpl_debug_writeln "Range = " myFollowThis[79308])
    }
    if(79409 call _cond_test(79349 call && 1(79347 call !(79346 call(79342 call . this[79153] c"hasFirst")))))
    {
      if(79404 call _cond_test(79356 call(79352 call . this[79153] c"isEmpty")))
      {
        if(79389 call _cond_test(79363 call !(79362 call(79358 call . myFollowThis[79308] c"isEmpty"))))
        {
          (79387 call boundsCheckHalt module=[255] HaltWrappers[209998] "size mismatch in zippered iteration")
          (358057 'referenced modules list' HaltWrappers[209998])
        }
      }
      {
        (79401 call boundsCheckHalt module=[255] HaltWrappers[209998] "iteration over a range with no first index")
        (358063 'referenced modules list' HaltWrappers[209998])
      }
    }
    if(79472 call _cond_test(79422 call && 1(79420 call !(79419 call(79415 call . myFollowThis[79308] c"hasFirst")))))
    {
      if(79466 call _cond_test(79440 call !(79438 call &&(79430 call !(79429 call(79425 call . myFollowThis[79308] c"isAmbiguous")))(79437 call(79433 call . myFollowThis[79308] c"isEmpty")))))
      {
        (79464 call boundsCheckHalt module=[255] HaltWrappers[209998] "zippered iteration over a range with no first index")
        (358072 'referenced modules list' HaltWrappers[209998])
      }
    }
    if(80144 call _cond_test(79494 call ||(79486 call &&(79479 call isBoundedRange myFollowThis[79308])(79484 call !(79481 call . myFollowThis[79308] c"stridable")))(79493 call(79489 call . myFollowThis[79308] c"hasLast"))))
    {
      const flwlen[79500] "const"(79497 call . myFollowThis[79308] c"size")
      (79503 'end of statement')
      if(79583 call _cond_test(79512 call && 1(79511 call(79507 call . this[79153] c"hasLast"))))
      {
        if(79577 call _cond_test(79517 call isBoundedRange this[79153]))
        {
          if(79549 call _cond_test(79523 call <(79519 call . this[79153] c"size") flwlen[79500]))
          {
            (79547 call boundsCheckHalt module=[255] HaltWrappers[209998] "zippered iteration over a range with too few indices")
            (358083 'referenced modules list' HaltWrappers[209998])
          }
        }
        {
          (79575 call assert 0 "hasFirst && hasLast do not imply isBoundedRange")
        }
      }
      if(79933 call _cond_test(79595 call ||(79588 call . this[79153] c"stridable")(79592 call . myFollowThis[79308] c"stridable")))
      {
        unknown r[79616](79614 call chpl_by(79605 call chpl_build_bounded_range(79600 call(375984 call . this[79153] c"chpl_intToIdx") 1)(79604 call(375988 call . this[79153] c"chpl_intToIdx") 0))(79612 call _cast(79611 call chpl__rangeStrideType(375992 call . this[79153] c"intIdxType")) 1))
        (79619 'end of statement')
        if(79725 call _cond_test(79623 call != flwlen[79500] 0))
        {
          const stride[79635] "const"(79633 call *(79626 call . this[79153] c"stride")(79630 call . myFollowThis[79308] c"stride"))
          (79638 'end of statement')
          unknown low[79650](79649 call(79641 call . this[79153] c"orderToIndex")(79645 call . myFollowThis[79308] c"first"))
          (79653 'end of statement')
          unknown high[79676](79675 call(375997 call . this[79153] c"chpl_intToIdx")(79672 call +(79660 call _cast(376002 call . this[79153] c"strType")(79658 call chpl__idxToInt low[79650]))(79670 call * stride[79635](79668 call _cast(376008 call . this[79153] c"strType")(79665 call - flwlen[79500] 1)))))
          (79679 'end of statement')
          (79695 call assert(79692 call == high[79676](79691 call(79683 call . this[79153] c"orderToIndex")(79687 call . myFollowThis[79308] c"last"))))
          if(79706 call _cond_test(79699 call < stride[79635] 0))
          {
            (79703 call <=> low[79650] high[79676])
          }
          (79722 call = r[79616](79720 call chpl_by(79714 call chpl_build_bounded_range low[79650] high[79676])(79718 call _cast(376020 call . this[79153] c"strType") stride[79635])))
        }
        if(79752 call _cond_test debugChapelRange[64195])
        {
          (79750 call chpl_debug_writeln "Expanded range = " r[79616])
        }
        {
          unknown _indexOfInterest[79762] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[79763] "expr temp" "temp"
          (79772 'move' _iterator[79763](79770 call _getIterator r[79616]))
          Defer
          {
            {
              (79788 call _freeIterator _iterator[79763])
            }
          }
          { scopeless type
            (79777 'move' _indexOfInterest[79762](79774 call iteratorIndex _iterator[79763]))
          }
          ForLoop[79764]
          {
            unknown i[79781] "index var" "insert auto destroy"
            (79783 'move' i[79781] _indexOfInterest[79762])
            (79760 yield i[79781])
            label _continueLabel[79767]
            _indexOfInterest[79762]
            _iterator[79763]
          }
          label _breakLabel[79768]
        }
      }
      {
        unknown r[79807](79805 call chpl_build_bounded_range(79799 call chpl__intToIdx(376029 call . this[79153] c"idxType") 1)(79804 call chpl__intToIdx(376034 call . this[79153] c"idxType") 0))
        (79810 'end of statement')
        if(79879 call _cond_test(79814 call != flwlen[79500] 0))
        {
          const low[79826] "const"(79825 call(79817 call . this[79153] c"orderToIndex")(79821 call . myFollowThis[79308] c"first"))
          (79829 'end of statement')
          const high[79850] "const"(79849 call(376039 call . this[79153] c"chpl_intToIdx")(79846 call +(79837 call _cast(376044 call . this[79153] c"strType")(79835 call chpl__idxToInt low[79826]))(79844 call _cast(376049 call . this[79153] c"strType")(79841 call - flwlen[79500] 1))))
          (79853 'end of statement')
          (79869 call assert(79866 call == high[79850](79865 call(79857 call . this[79153] c"orderToIndex")(79861 call . myFollowThis[79308] c"last"))))
          (79876 call = r[79807](79874 call chpl_build_bounded_range low[79826] high[79850]))
        }
        if(79890 call _cond_test debugChapelRange[64195])
        {
          (79888 call chpl_debug_writeln "Expanded range = " r[79807])
        }
        {
          unknown _indexOfInterest[79900] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[79901] "expr temp" "temp"
          (79910 'move' _iterator[79901](79908 call _getIterator r[79807]))
          Defer
          {
            {
              (79926 call _freeIterator _iterator[79901])
            }
          }
          { scopeless type
            (79915 'move' _indexOfInterest[79900](79912 call iteratorIndex _iterator[79901]))
          }
          ForLoop[79902]
          {
            unknown i[79919] "index var" "insert auto destroy"
            (79921 'move' i[79919] _indexOfInterest[79900])
            (79898 yield i[79919])
            label _continueLabel[79905]
            _indexOfInterest[79900]
            _iterator[79901]
          }
          label _breakLabel[79906]
        }
      }
    }
    {
      if(79974 call _cond_test(79944 call && 1(79943 call(79939 call . this[79153] c"hasLast"))))
      {
        (79972 call zipLengthHalt module=[255] HaltWrappers[209998] "zippered iteration where a bounded range follows an unbounded iterator")
        (358102 'referenced modules list' HaltWrappers[209998])
      }
      const first[79990] "const"(79989 call(79981 call . this[79153] c"orderToIndex")(79985 call . myFollowThis[79308] c"first"))
      (79993 'end of statement')
      const stride[80004] "const"(80002 call *(79995 call . this[79153] c"stride")(79999 call . myFollowThis[79308] c"stride"))
      (80007 'end of statement')
      if(80140 call _cond_test(80010 call > stride[80004] 0))
      {
        const r[80021] "const"(80019 call chpl_by(80013 call chpl_build_low_bounded_range first[79990])(80017 call _cast(376065 call . this[79153] c"strType") stride[80004]))
        (80024 'end of statement')
        if(80033 call _cond_test debugChapelRange[64195])
        {
          (80031 call chpl_debug_writeln "Expanded range = " r[80021])
        }
        {
          unknown _indexOfInterest[80043] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[80044] "expr temp" "temp"
          (80053 'move' _iterator[80044](80051 call _getIterator r[80021]))
          Defer
          {
            {
              (80069 call _freeIterator _iterator[80044])
            }
          }
          { scopeless type
            (80058 'move' _indexOfInterest[80043](80055 call iteratorIndex _iterator[80044]))
          }
          ForLoop[80045]
          {
            unknown i[80062] "index var" "insert auto destroy"
            (80064 'move' i[80062] _indexOfInterest[80043])
            (80041 yield i[80062])
            label _continueLabel[80048]
            _indexOfInterest[80043]
            _iterator[80044]
          }
          label _breakLabel[80049]
        }
      }
      {
        const r[80085] "const"(80083 call chpl_by(80077 call chpl_build_high_bounded_range first[79990])(80081 call _cast(376075 call . this[79153] c"strType") stride[80004]))
        (80088 'end of statement')
        if(80097 call _cond_test debugChapelRange[64195])
        {
          (80095 call chpl_debug_writeln "Expanded range = " r[80085])
        }
        {
          unknown _indexOfInterest[80107] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[80108] "expr temp" "temp"
          (80117 'move' _iterator[80108](80115 call _getIterator r[80085]))
          Defer
          {
            {
              (80133 call _freeIterator _iterator[80108])
            }
          }
          { scopeless type
            (80122 'move' _indexOfInterest[80107](80119 call iteratorIndex _iterator[80108]))
          }
          ForLoop[80109]
          {
            unknown i[80126] "index var" "insert auto destroy"
            (80128 'move' i[80126] _indexOfInterest[80107])
            (80105 yield i[80126])
            label _continueLabel[80112]
            _indexOfInterest[80107]
            _iterator[80108]
          }
          label _breakLabel[80113]
        }
      }
    }
  }
  where {
    (79163 call == tag[79146] follower[449])
  }
  function _cast[80157](arg t[80154] :
  string[26], arg x[80163] :
  (80162 call range[64316](?) ?[260])) : _unknown[51]
  {
    unknown ret[80167] string[26]
    (80170 'end of statement')
    if(80189 call _cond_test(80177 call(80173 call . x[80163] c"hasLowBound")))
    {
      (80186 call += ret[80167](80184 call _cast string[26](80180 call . x[80163] c"low")))
    }
    (80212 call += ret[80167] "..")
    if(80232 call _cond_test(80220 call(80216 call . x[80163] c"hasHighBound")))
    {
      (80229 call += ret[80167](80227 call _cast string[26](80223 call . x[80163] c"high")))
    }
    if(80258 call _cond_test(80242 call !=(80238 call . x[80163] c"stride") 1))
    {
      (80255 call += ret[80167](80253 call + " by "(80251 call _cast string[26](80247 call . x[80163] c"stride"))))
    }
    unknown alignCheckRange[80264] x[80163]
    (80267 'end of statement')
    (80275 call(80271 call . alignCheckRange[80264] c"normalizeAlignment"))
    if(80327 call _cond_test(80285 call !(80284 call(80280 call . alignCheckRange[80264] c"isNaturallyAligned"))))
    {
      (80324 call += ret[80167](80322 call + " align "(80320 call _cast string[26](80318 call chpl__mod(80312 call chpl__idxToInt(80308 call . x[80163] c"alignment"))(80315 call . x[80163] c"stride")))))
    }
    (80333 return ret[80167])
  }
  function range[64316](?).normalizeAlignment[80340](arg _mt[80345]:_MT[238], ref arg this[80342]:range[64316](?) :
  range[64316](?)) : _unknown[51] "method" "no doc" "no return value for void"
  {
    if(80403 call _cond_test(80351 call &&(376092 call . this[80342] c"stridable")(80349 call !(376096 call . this[80342] c"aligned"))))
    {
      (80399 call =(376101 call . this[80342] c"_alignment")(80396 IfExpr (80357 call isBoundedRange this[80342]) then
      { scopeless(80364 IfExpr (80360 call >(376106 call . this[80342] c"stride") 0) then
        { scopeless
          (376111 call . this[80342] c"_low")
        } else
        { scopeless
          (376116 call . this[80342] c"_high")
        } )
      } else
      { scopeless(80393 IfExpr (80375 call ==(80368 call . this[80342] c"boundedType") boundedLow[64207]) then
        { scopeless
          (376121 call . this[80342] c"_low")
        } else
        { scopeless(80390 IfExpr (80386 call ==(80379 call . this[80342] c"boundedType") boundedHigh[64209]) then
          { scopeless
            (376126 call . this[80342] c"_high")
          } else
          { scopeless
            0
          } )
        } )
      } ))
    }
  }
  function range[64316](?).chpl__unTranslate[80417](arg _mt[80422]:_MT[238], arg this[80419]:range[64316](?) :
  range[64316](?), arg i[80414] :
  (376130 call . this[80419] c"intIdxType")) : _unknown[51] "inline" "method" "no doc"
  {
    (80428 return(80426 call - this[80419] i[80414]))
  }
  function range[64316](?).chpl__unTranslate[80438](arg _mt[80443]:_MT[238], arg this[80440]:range[64316](?) :
  range[64316](?), arg i[80436]:_any[178](?)) : _unknown[51] "inline" "method" "no doc"
  {
    if(80465 call _cond_test(80449 call isIntType(80447 'typeof' i[80436])))
    {
      (80454 return(80452 call - this[80440] i[80436]))
    }
    {
      (80463 return(80461 call + this[80440](80460 call abs i[80436])))
    }
  }
  function chpl__hasAlignment[80483](arg r[80480] :
  (80479 call range[64316](?) ?[260])) : _unknown[51]
  {
    if(80503 call _cond_test(80498 call &&(80490 call(80486 call . r[80480] c"hasLowBound"))(80496 call >=(80492 call . r[80480] c"stride") 2)))
    {
      (80501 return 1)
    }
    if(80529 call _cond_test(80524 call &&(80514 call(80510 call . r[80480] c"hasHighBound"))(80522 call <=(80516 call . r[80480] c"stride")(80520 call - 2))))
    {
      (80527 return 1)
    }
    (80535 return 0)
  }
  function chpl__mod[80545](arg dividend[80542] :
  integral[199](?), arg modulus[80548] :
  integral[199](?)) : _unknown[51]
  {
    const m[80562] "const"(80561 call(80555 call .(80554 call abs modulus[80548]) c"safeCast")(80559 'typeof' dividend[80542]))
    (80565 'end of statement')
    unknown tmp[80571](80569 call % dividend[80542] m[80562])
    (80574 'end of statement')
    if(80593 call _cond_test(80578 call isInt dividend[80542]))
    {
      if(80588 call _cond_test(80581 call < tmp[80571] 0))
      {
        (80585 call += tmp[80571] m[80562])
      }
    }
    (80599 return tmp[80571])
  }
  function chpl__diffMod[80609](arg minuend[80606] :
  integral[199](?), arg subtrahend[80612] :
  integral[199](?), arg modulus[80616] :
  integral[199](?)) : _unknown[51]
  {
    const m[80638] "const"(80637 call(80631 call .(80630 call abs modulus[80616]) c"safeCast")(80635 'typeof' minuend[80606]))
    (80641 'end of statement')
    unknown minMod[80648](80647 call chpl__mod minuend[80606] m[80638])
    (80651 'end of statement')
    unknown subMod[80657](80656 call chpl__mod subtrahend[80612] m[80638])
    (80660 'end of statement')
    (80679 return(80676 IfExpr (80663 call < minMod[80648] subMod[80657]) then
    { scopeless
      (80670 call - m[80638](80668 call - subMod[80657] minMod[80648]))
    } else
    { scopeless
      (80674 call - minMod[80648] subMod[80657])
    } ))
  }
  where {
    (80625 call ==(80622 'typeof' minuend[80606])(80624 'typeof' subtrahend[80612]))
  }
  { scopeless type
    (80620 'typeof' minuend[80606])
  }
  function chpl__diffMod[80691](arg minuend[80688] :
  integral[199](?), arg subtrahend[80694] :
  integral[199](?), arg modulus[80698] :
  integral[199](?)) : _unknown[51] "no return value for void"
  {
    (80720 call compilerError "chpl__diffMod -- Operand types must match.")
  }
  function chpl__add[80732](arg a[80729] :
  unknown t[80727], arg b[80735] :
  t[80727], arg resultType[80738]:_any[178](?)) : _unknown[51]
  {
    if(80767 call _cond_test(80744 call !(80743 call isIntegralType t[80727])))
    {
      (80765 call compilerError "Values must be of integral type.")
    }
    if(80801 call _cond_test(80793 call &&(80781 call &&(80775 call > a[80729] 0)(80779 call > b[80735] 0))(80791 call > b[80735](80789 call -(80787 call max t[80727]) a[80729]))))
    {
      (80799 return(80798 call max resultType[80738]))
    }
    if(80834 call _cond_test(80826 call &&(80814 call &&(80808 call < a[80729] 0)(80812 call < b[80735] 0))(80824 call < b[80735](80822 call -(80820 call min t[80727]) a[80729]))))
    {
      (80832 return(80831 call min resultType[80738]))
    }
    if(80919 call _cond_test(80842 call isUintType resultType[80738]))
    {
      if(80913 call _cond_test(80905 call ||(80872 call &&(80851 call &&(80845 call < a[80729] 0)(80849 call > b[80735] 0))(80870 call ||(80858 call == a[80729](80857 call min t[80727]))(80868 call >(80863 call abs a[80729])(80867 call abs b[80735]))))(80903 call &&(80882 call &&(80876 call > a[80729] 0)(80880 call < b[80735] 0))(80901 call ||(80889 call == b[80735](80888 call min t[80727]))(80899 call >(80894 call abs b[80735])(80898 call abs a[80729]))))))
      {
        (80911 return(80909 call _cast resultType[80738] 0))
      }
    }
    (80930 return(80928 call _cast resultType[80738](80925 call + a[80729] b[80735])))
  }
  function chpl__addRangeStrides[80938](arg start[80936]:_any[178](?), arg stride[80940]:_any[178](?), arg count[80942]:_any[178](?)) : _unknown[51]
  {
    function convert[80950](arg a[80948]:_any[178](?), arg b[80952]:_any[178](?)) param : _unknown[51]
    {
      (80992 return(80990 call ||(80970 call &&(80960 call ==(80955 'typeof' a[80948])(80959 call int(64)[13] 64))(80968 call ==(80963 'typeof' b[80952])(80967 call uint(64)[115] 64)))(80988 call &&(80978 call ==(80973 'typeof' a[80948])(80977 call uint(64)[115] 64))(80986 call ==(80981 'typeof' b[80952])(80985 call int(64)[13] 64)))))
    }
    function mul[81002](arg a[81000]:_any[178](?), arg b[81004]:_any[178](?)) : _unknown[51]
    {
      (81034 return(81031 IfExpr (81010 call convert a[81000] b[81004]) then
      { scopeless
        (81025 call *(81016 call _cast(81015 call int(64)[13] 64) a[81000])(81023 call _cast(81022 call int(64)[13] 64) b[81004]))
      } else
      { scopeless
        (81029 call * a[81000] b[81004])
      } ))
    }
    function add[81043](arg a[81041]:_any[178](?), arg b[81045]:_any[178](?)) : _unknown[51]
    {
      (81075 return(81072 IfExpr (81051 call convert a[81041] b[81045]) then
      { scopeless
        (81066 call +(81057 call _cast(81056 call int(64)[13] 64) a[81041])(81064 call _cast(81063 call int(64)[13] 64) b[81045]))
      } else
      { scopeless
        (81070 call + a[81041] b[81045])
      } ))
    }
    (81093 return(81091 call _cast(81090 'typeof' start[80936])(81088 call add start[80936](81087 call mul stride[80940] count[80942]))))
  }
  { scopeless type
    (80945 'typeof' start[80936])
  }
  function chpl__extendedEuclidHelper[81102](arg u[81100]:_any[178](?), arg v[81104]:_any[178](?)) : _unknown[51]
  {
    unknown zero[81109] 0(81107 'typeof' u[81100])
    (81112 'end of statement')
    unknown one[81117] 1(81115 'typeof' u[81100])
    (81120 'end of statement')
    unknown U[81127](81125 call _build_tuple one[81117] zero[81109] u[81100])
    (81130 'end of statement')
    unknown V[81137](81135 call _build_tuple zero[81109] one[81117] v[81104])
    (81140 'end of statement')
    {
      unknown tmp[81189] "temp"
      (81217 'move' tmp[81189](81210 call _cond_test(81212 call !=(81214 call V[81137] 2) 0)))
      WhileDo[81194]
      {
        {
          unknown oldU[81149] U[81127]
          (81152 'end of statement')
          unknown q[81164](81162 call /(81157 call U[81127] 2)(81161 call V[81137] 2))
          (81167 'end of statement')
          (81170 call = U[81127] V[81137])
          (81186 call = V[81137](81184 call - oldU[81149](81182 call * V[81137](81180 call _build_tuple q[81164] q[81164] q[81164]))))
        }
        label _continueLabel[81192]
        (81205 'move' tmp[81189](81198 call _cond_test(81200 call !=(81202 call V[81137] 2) 0)))
        tmp[81189]
      }
      label _breakLabel[81193]
    }
    (81231 return(81229 call _build_tuple(81223 call U[81127] 2)(81227 call U[81127] 0)))
  }
  function chpl__extendedEuclid[81244](arg u[81241] :
  (81240 call int(64)[13] 32), arg v[81250] :
  (81249 call int(64)[13] 32)) : _unknown[51] "inline"
  {
    (81258 return(81257 call chpl__extendedEuclidHelper u[81241] v[81250]))
  }
  function chpl__extendedEuclid[81272](arg u[81269] :
  (81268 call int(64)[13] 64), arg v[81278] :
  (81277 call int(64)[13] 64)) : _unknown[51] "inline"
  {
    (81286 return(81285 call chpl__extendedEuclidHelper u[81269] v[81278]))
  }
  function chpl__rangeIdxTypeError[81295](arg idxType[81293]:_any[178](?)) : _unknown[51] "private" "no return value for void"
  {
    (81337 call compilerError "ranges don't support '"(81318 call _cast string[26] idxType[81293]) "' as their idxType")
  }
  function chpl__rangeStrideType[81346](arg idxType[81344]:_any[178](?)) type : _unknown[51] "private"
  {
    if(81383 call _cond_test(81351 call isIntegralType idxType[81344]))
    {
      (81356 return(81355 call chpl__signedType idxType[81344]))
    }
    {
      if(81379 call _cond_test(81367 call ||(81362 call isEnumType idxType[81344])(81366 call isBoolType idxType[81344])))
      {
        (81370 return int(64)[13])
      }
      {
        (81376 call chpl__rangeIdxTypeError idxType[81344])
      }
    }
  }
  function chpl__rangeUnsignedType[81395](arg idxType[81393]:_any[178](?)) type : _unknown[51] "private"
  {
    if(81432 call _cond_test(81400 call isIntegralType idxType[81393]))
    {
      (81405 return(81404 call chpl__unsignedType idxType[81393]))
    }
    {
      if(81428 call _cond_test(81416 call ||(81411 call isEnumType idxType[81393])(81415 call isBoolType idxType[81393])))
      {
        (81419 return uint(64)[115])
      }
      {
        (81425 call chpl__rangeIdxTypeError idxType[81393])
      }
    }
  }
  function chpl__idxTypeToIntIdxType[81444](arg idxType[81442]:_any[178](?)) type : _unknown[51] "no doc"
  {
    if(81503 call _cond_test(81449 call isBoolType idxType[81442]))
    {
      (81451 return int(64)[13])
    }
    {
      if(81499 call _cond_test(81457 call isEnumType idxType[81442]))
      {
        if(81486 call _cond_test(81463 call <(81459 call . idxType[81442] c"size") 2))
        {
          (81484 call compilerError "ranges are not currently supported for enums with fewer than two values")
        }
        (81493 return int(64)[13])
      }
      {
        (81496 return idxType[81442])
      }
    }
  }
  function range[64316](?).chpl_intToIdx[81516](arg _mt[81521]:_MT[238], arg this[81518]:range[64316](?) :
  range[64316](?), arg i[81514]:_any[178](?)) : _unknown[51] "inline" "method" "no doc"
  {
    (81531 return(81530 call chpl__intToIdx(81525 call . this[81518] c"idxType") i[81514]))
  }
  function chpl__intToIdx[81542](arg idxType[81539] :
  integral[199](?), arg i[81545] :
  integral[199](?)) : _unknown[51] "inline"
  {
    if(81562 call _cond_test(81551 call ==(81549 'typeof' i[81545]) idxType[81539]))
    {
      (81554 return i[81545])
    }
    {
      (81560 return(81558 call _cast idxType[81539] i[81545]))
    }
  }
  function chpl__intToIdx[81577](arg idxType[81574] :
  integral[199](?), param arg i[81580] :
  integral[199](?)) : _unknown[51] "inline"
  {
    if(81597 call _cond_test(81586 call ==(81584 'typeof' i[81580]) idxType[81574]))
    {
      (81589 return i[81580])
    }
    {
      (81595 return(81593 call _cast idxType[81574] i[81580]))
    }
  }
  function chpl__intToIdx[81612](arg idxType[81609] :
  enum[187](?), arg i[81615] :
  integral[199](?)) : _unknown[51] "inline"
  {
    (81623 return(81622 call chpl__orderToEnum i[81615] idxType[81609]))
  }
  function chpl__intToIdx[81632](arg idxType[81630]:_any[178](?), arg i[81635] :
  integral[199](?)) : _unknown[51] "inline"
  {
    (81646 return(81644 call _cast bool[10] i[81635]))
  }
  where {
    (81641 call isBoolType idxType[81630])
  }
  function chpl__intToIdx[81656](arg idxType[81654]:_any[178](?), param arg i[81659] :
  integral[199](?)) param : _unknown[51] "inline"
  {
    (81670 return(81668 call _cast bool[10] i[81659]))
  }
  where {
    (81665 call isBoolType idxType[81654])
  }
  function chpl__intToIdx[81680](arg idxType[81678]:_any[178](?), arg i[81683] :
  nothing[7]) : _unknown[51] "inline"
  {
    (81687 return none[57])
  }
  function chpl__idxToInt[81698](arg i[81695] :
  integral[199](?)) : _unknown[51] "inline"
  {
    (81701 return i[81695])
  }
  function chpl__idxToInt[81712](param arg i[81709] :
  integral[199](?)) param : _unknown[51] "inline"
  {
    (81715 return i[81709])
  }
  function chpl__idxToInt[81726](arg i[81723] :
  enum[187](?)) : _unknown[51] "inline"
  {
    (81732 return(81731 call chpl__enumToOrder i[81723]))
  }
  function chpl__idxToInt[81743](arg i[81740] :
  bool[10]) : _unknown[51] "inline"
  {
    (81749 return(81747 call _cast int(64)[13] i[81740]))
  }
  function chpl__idxToInt[81760](param arg i[81757] :
  bool[10]) param : _unknown[51] "inline"
  {
    (81766 return(81764 call _cast int(64)[13] i[81757]))
  }
  (355049 'used modules list'(64184 'use' ChapelBase[307])(64186 'use' SysBasic[223516])(64187 'use' HaltWrappers[209998])(64191 'use' Math[215858])(64193 'use' DSIUtil[230888]))
}