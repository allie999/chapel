AST dump for ChapelRange after pass flattenClasses.
Module use list: ChapelBase SysBasic HaltWrappers Math DSIUtil 

{
  unknown debugChapelRange[64198] "config" "no doc" "param" 0
  (64201 'end of statement')
  unknown useOptimizedRangeIterators[64203] "config" "no doc" "param" 1
  (64206 'end of statement')
  type BoundedRangeType[64216] def bounded[64208]:BoundedRangeType[64216] def boundedLow[64210]:BoundedRangeType[64216] def boundedHigh[64212]:BoundedRangeType[64216] def boundedNone[64214]:BoundedRangeType[64216]
  {
  }
  function range[64319](?).strType[64297](arg _mt[64323]:_MT[238], arg this[64321]:range[64319](?)) type : _unknown[51] "method" "primary method" "no parens"
  {
    (64303 return(64302 call chpl__rangeStrideType(373798 call . this[64321] c"idxType")))
  }
  function range[64319](?).chpl__promotionType[64310](arg _mt[64327]:_MT[238], arg this[64325]:range[64319](?)) type : _unknown[51] "method" "primary method"
  {
    (64313 return(373803 call . this[64325] c"idxType"))
  }
  type range[64319](?) unknown idxType[64223] "type variable" int(64)[13] unknown boundedType[64233] "param" bounded[64208] BoundedRangeType[64216] unknown stridable[64239] "param" 0 bool[10] unknown _low[64247](64246 call chpl__idxTypeToIntIdxType idxType[64223]) unknown _high[64255](64254 call chpl__idxTypeToIntIdxType idxType[64223]) unknown _stride[64268](64265 IfExpr  stridable[64239] then
  { scopeless
    (64263 call chpl__rangeStrideType idxType[64223])
  } else
  { scopeless
    nothing[7]
  } ) unknown _alignment[64281](64278 IfExpr  stridable[64239] then
  { scopeless
    (64276 call chpl__idxTypeToIntIdxType idxType[64223])
  } else
  { scopeless
    nothing[7]
  } ) unknown _aligned[64291](64288 IfExpr  stridable[64239] then
  { scopeless
    bool[10]
  } else
  { scopeless
    nothing[7]
  } )
  function range[64319](?).intIdxType[64333](arg _mt[64338]:_MT[238], arg this[64335]:range[64319](?) :
  range[64319](?)) type : _unknown[51] "method" "no parens"
  {
    (64344 return(64343 call chpl__idxTypeToIntIdxType(373808 call . this[64335] c"idxType")))
  }
  function range[64319](?).init[64356](arg _mt[64421]:_MT[238], arg this[64418]:range[64319](?) :
  range[64319](?), arg idxType[64353]:_any[178](?) =
  int(64)[13], param arg boundedType[64363] :
  BoundedRangeType[64216] =
  bounded[64208], param arg stridable[64369] :
  bool[10] =
  0, arg _low[64379] :
  idxType[64353] =
  (64378 call chpl__intToIdx idxType[64353] 1), arg _high[64389] :
  idxType[64353] =
  (64388 call chpl__intToIdx idxType[64353] 0), arg _stride[64398] :
  (64396 call chpl__rangeStrideType idxType[64353]) =
  1, arg _alignment[64408] :
  idxType[64353] =
  (64407 call chpl__intToIdx idxType[64353] 0), arg _aligned[64414] :
  bool[10] =
  0) : _unknown[51] "method" "no doc" "no return value for void"
  {
    (64428 call =(64424 call . this[64418] c"idxType") idxType[64353])
    (64439 call =(64435 call . this[64418] c"boundedType") boundedType[64363])
    (64447 call =(64443 call . this[64418] c"stridable") stridable[64369])
    (64460 call =(64453 call . this[64418] c"_low")(64459 call chpl__idxToInt _low[64379]))
    (64473 call =(64466 call . this[64418] c"_high")(64472 call chpl__idxToInt _high[64389]))
    (64481 call(64477 call . this[64418] c"complete"))
    if(64518 call _cond_test stridable[64369])
    {
      (64491 call =(64487 call . this[64418] c"_stride") _stride[64398])
      (64505 call =(64498 call . this[64418] c"_alignment")(64504 call chpl__idxToInt _alignment[64408]))
      (64515 call =(64511 call . this[64418] c"_aligned") _aligned[64414])
    }
    if(64536 call _cond_test(64526 call &&(64523 call ! stridable[64369]) 1))
    {
      (64534 call assert(64531 call == _stride[64398] 1))
    }
  }
  function _isAnyNothing[64549](arg args[64546]:_any[178](?) ...) param : _unknown[51] "private"
  {
    {
      unknown i[64579] 0
      unknown tmp[64580] "maybe param" "temp"
      (64592 'move' tmp[64580](64590 call chpl_compute_low_param_loop_bound 0(64558 call -(64554 call . args[64546] c"size") 1)))
      unknown tmp[64581] "maybe param" "temp"
      (64605 'move' tmp[64581](64603 call chpl_compute_high_param_loop_bound 0(64597 call -(64599 call . args[64546] c"size") 1)))
      unknown tmp[64582] "maybe param" "temp"
      (64608 'move' tmp[64582] 1)
      ParamForLoop[64610]
      { i[64579] tmp[64580] tmp[64581] tmp[64582]
        {
          if(64573 call _cond_test(64569 call isNothingType(64567 'typeof'(64566 call args[64546] i[64579]))))
          {
            (64571 return 1)
          }
        }
      }
      label _unused_continueLabel[64584]
      label _breakLabel[64583]
    }
    (64621 return 0)
  }
  { scopeless type
    bool[10]
  }
  function range[64319](?).init[64633](arg _mt[64679]:_MT[238], arg this[64676]:range[64319](?) :
  range[64319](?), arg idxType[64630]:_any[178](?) =
  int(64)[13], param arg boundedType[64640] :
  BoundedRangeType[64216] =
  bounded[64208], param arg stridable[64646] :
  bool[10] =
  0, arg _low[64656] :
  idxType[64630] =
  (64655 call chpl__intToIdx idxType[64630] 1), arg _high[64666] :
  idxType[64630] =
  (64665 call chpl__intToIdx idxType[64630] 0), arg _stride[64670]:_any[178](?), arg _alignment[64672]:_any[178](?), arg _aligned[64674]:_any[178](?)) : _unknown[51] "method" "no doc" "no return value for void"
  {
    (64692 call =(64688 call . this[64676] c"idxType") idxType[64630])
    (64701 call =(64697 call . this[64676] c"boundedType") boundedType[64640])
    (64709 call =(64705 call . this[64676] c"stridable") stridable[64646])
    (64720 call =(64713 call . this[64676] c"_low")(64719 call chpl__idxToInt _low[64656]))
    (64731 call =(64724 call . this[64676] c"_high")(64730 call chpl__idxToInt _high[64666]))
    (64739 call(64735 call . this[64676] c"complete"))
    if(64763 call _cond_test stridable[64646])
    {
      (64761 call compilerError "non-stridable range initializer called with stridable=true")
    }
  }
  where {
    (64686 call _isAnyNothing _stride[64670] _alignment[64672] _aligned[64674])
  }
  function range[64319](?).init=[64786](arg _mt[64791]:_MT[238], arg this[64788]:range[64319](?) :
  range[64319](?), arg other[64783] :
  (64782 call range[64319](?) unknown i[64775] unknown b[64778] unknown s[64780])) : _unknown[51] "method" "no doc" "no return value for void"
  {
    unknown idxType[64810] "type variable"(64807 IfExpr (64799 call ==(64795 call .(64794 'typeof' this[64788]) c"idxType") ?[260]) then
    { scopeless
      i[64775]
    } else
    { scopeless
      (64804 call .(64803 'typeof' this[64788]) c"idxType")
    } )
    unknown boundedType[64831] "param"(64828 IfExpr (64820 call ==(64816 call .(64815 'typeof' this[64788]) c"boundedType") ?[260]) then
    { scopeless
      b[64778]
    } else
    { scopeless
      (64825 call .(64824 'typeof' this[64788]) c"boundedType")
    } )
    (64834 'end of statement')
    unknown stridable[64852] "param"(64849 IfExpr (64841 call ==(64837 call .(64836 'typeof' this[64788]) c"stridable") ?[260]) then
    { scopeless
      s[64780]
    } else
    { scopeless
      (64846 call .(64845 'typeof' this[64788]) c"stridable")
    } )
    (64855 'end of statement')
    if(64920 call _cond_test(64858 call != boundedType[64831] b[64778]))
    {
      (64917 call compilerError(64914 call +(64911 call +(64905 call +(64886 call + "range(boundedType="(64884 call _cast string[26](64880 call .(64879 'typeof' this[64788]) c"boundedType"))) ") cannot be initialized from range(boundedType=")(64909 call _cast string[26] b[64778])) ")"))
    }
    if(64951 call _cond_test(64928 call &&(64925 call ! stridable[64852]) s[64780]))
    {
      (64949 call compilerError "cannot initialize a non-stridable range from a stridable range")
    }
    const str[64974] "const"(64971 IfExpr (64958 call && stridable[64852] s[64780]) then
    { scopeless
      (64961 call . other[64783] c"stride")
    } else
    { scopeless
      (64969 call _cast(64968 call chpl__rangeStrideType idxType[64810]) 1)
    } )
    (64977 'end of statement')
    (65022 call(64979 call . this[64788] c"init") idxType[64810] boundedType[64831] stridable[64852](64993 call chpl__intToIdx idxType[64810](64990 call . other[64783] c"_low"))(65001 call chpl__intToIdx idxType[64810](64998 call . other[64783] c"_high")) str[64974](65015 call chpl__intToIdx idxType[64810](65014 call chpl__idxToInt(65010 call . other[64783] c"alignment")))(65019 call . other[64783] c"aligned"))
  }
  function range[64319](?).displayRepresentation[65051](arg _mt[65056]:_MT[238], arg this[65053]:range[64319](?) :
  range[64319](?), arg msg[65047] :
  string[26] =
  "") : _unknown[51] "method" "no doc" "no return value for void"
  {
    (65152 call chpl_debug_writeln msg[65047] "("(65081 call _cast string[26](373876 call . this[65053] c"idxType")) ","(373881 call . this[65053] c"boundedType") ","(373886 call . this[65053] c"stridable") " : "(373890 call . this[65053] c"low") ","(373894 call . this[65053] c"high") ","(373898 call . this[65053] c"stride") ","(65148 IfExpr (373902 call . this[65053] c"aligned") then
    { scopeless
      (65129 call _cast string[26](373906 call . this[65053] c"alignment"))
    } else
    { scopeless
      "\?"
    } ) ")")
  }
  { scopeless type
    void[4]
  }
  function chpl_build_bounded_range[65168](arg low[65165] :
  (65164 call int(64)[13] unknown w[65161]), arg high[65174] :
  (65173 call int(64)[13] w[65161])) : _unknown[51]
  {
    (65189 return(65177 'new'(65188 call range[64319](?)(65182 call int(64)[13] w[65161])(_low = low[65165])(_high = high[65174]))))
  }
  function chpl_build_bounded_range[65204](arg low[65201] :
  (65200 call uint(64)[115] unknown w[65197]), arg high[65210] :
  (65209 call uint(64)[115] w[65197])) : _unknown[51]
  {
    (65225 return(65213 'new'(65224 call range[64319](?)(65218 call uint(64)[115] w[65197])(_low = low[65201])(_high = high[65210]))))
  }
  function chpl_build_bounded_range[65236](arg low[65233] :
  enum[187](?), arg high[65239] :
  enum[187](?)) : _unknown[51]
  {
    if(65269 call _cond_test(65246 call !=(65243 'typeof' low[65233])(65245 'typeof' high[65239])))
    {
      (65267 call compilerError "ranges of enums must use a single enum type")
    }
    (65285 return(65275 'new'(65284 call range[64319](?)(65278 'typeof' low[65233])(_low = low[65233])(_high = high[65239]))))
  }
  function chpl_build_bounded_range[65295](arg low[65292] :
  bool[10], arg high[65298] :
  bool[10]) : _unknown[51]
  {
    (65310 return(65301 'new'(65309 call range[64319](?) bool[10](_low = low[65292])(_high = high[65298]))))
  }
  function chpl_build_bounded_range[65319](arg low[65317]:_any[178](?), arg high[65321]:_any[178](?)) : _unknown[51] "no return value for void"
  {
    (65342 call compilerError "Bounds of 'low..high' must be integers of compatible types.")
  }
  function chpl_build_low_bounded_range[65353](arg low[65350] :
  integral[199](?)) : _unknown[51]
  {
    (65367 return(65355 'new'(65366 call range[64319](?)(65358 'typeof' low[65350]) boundedLow[64210](_low = low[65350]))))
  }
  function chpl_build_low_bounded_range[65378](arg low[65375] :
  enum[187](?)) : _unknown[51]
  {
    (65392 return(65380 'new'(65391 call range[64319](?)(65383 'typeof' low[65375]) boundedLow[64210](_low = low[65375]))))
  }
  function chpl_build_low_bounded_range[65403](arg low[65400] :
  bool[10]) : _unknown[51]
  {
    (65417 return(65405 'new'(65416 call range[64319](?)(65408 'typeof' low[65400]) boundedLow[64210](_low = low[65400]))))
  }
  function chpl_build_low_bounded_range[65426](arg low[65424]:_any[178](?)) : _unknown[51] "no return value for void"
  {
    (65447 call compilerError "Bound of 'low..' must be an integer")
  }
  function chpl_build_high_bounded_range[65458](arg high[65455] :
  integral[199](?)) : _unknown[51]
  {
    (65472 return(65460 'new'(65471 call range[64319](?)(65463 'typeof' high[65455]) boundedHigh[64212](_high = high[65455]))))
  }
  function chpl_build_high_bounded_range[65483](arg high[65480] :
  enum[187](?)) : _unknown[51]
  {
    (65497 return(65485 'new'(65496 call range[64319](?)(65488 'typeof' high[65480]) boundedHigh[64212](_high = high[65480]))))
  }
  function chpl_build_high_bounded_range[65508](arg high[65505] :
  bool[10]) : _unknown[51]
  {
    (65522 return(65510 'new'(65521 call range[64319](?)(65513 'typeof' high[65505]) boundedHigh[64212](_high = high[65505]))))
  }
  function chpl_build_high_bounded_range[65531](arg high[65529]:_any[178](?)) : _unknown[51] "no return value for void"
  {
    (65552 call compilerError "Bound of '..high' must be an integer.")
  }
  function chpl_build_unbounded_range[65559]() : _unknown[51]
  {
    (65572 return(65561 'new'(65571 call range[64319](?) int(64)[13] boundedNone[64214])))
  }
  function chpl_compute_low_param_loop_bound[65587](param arg low[65584] :
  (65583 call int(64)[13] unknown w[65580]), param arg high[65593] :
  (65592 call int(64)[13] w[65580])) param : _unknown[51]
  {
    (65597 return low[65584])
  }
  function chpl_compute_high_param_loop_bound[65612](param arg low[65609] :
  (65608 call int(64)[13] unknown w[65605]), param arg high[65618] :
  (65617 call int(64)[13] w[65605])) param : _unknown[51]
  {
    (65622 return high[65618])
  }
  function chpl_compute_low_param_loop_bound[65637](param arg low[65634] :
  (65633 call uint(64)[115] unknown w[65630]), param arg high[65643] :
  (65642 call uint(64)[115] w[65630])) param : _unknown[51]
  {
    (65647 return low[65634])
  }
  function chpl_compute_high_param_loop_bound[65662](param arg low[65659] :
  (65658 call uint(64)[115] unknown w[65655]), param arg high[65668] :
  (65667 call uint(64)[115] w[65655])) param : _unknown[51]
  {
    (65672 return high[65668])
  }
  function chpl_compute_low_param_loop_bound[65683](param arg low[65680] :
  bool[10], param arg high[65686] :
  bool[10]) param : _unknown[51]
  {
    (65690 return low[65680])
  }
  function chpl_compute_high_param_loop_bound[65701](param arg low[65698] :
  bool[10], param arg high[65704] :
  bool[10]) param : _unknown[51]
  {
    (65708 return high[65704])
  }
  function chpl_compute_low_param_loop_bound[65717](param arg low[65715]:_any[178](?), param arg high[65719]:_any[178](?)) param : _unknown[51] "last resort" "no return value for void"
  {
    (65742 call compilerError "Range bounds must be integers of compatible types in param for-loops")
  }
  function chpl_compute_low_param_loop_bound[65751](arg low[65749]:_any[178](?), arg high[65753]:_any[178](?)) : _unknown[51] "last resort" "no return value for void"
  {
    (65774 call compilerError "param for-loops must be defined over a bounded param range")
  }
  function chpl_compute_count_param_loop[65785](param arg count[65782] :
  integral[199](?)) param : _unknown[51]
  {
    (65788 return count[65782])
  }
  function chpl_compute_count_param_loop[65797](arg count[65795]:_any[178](?)) : _unknown[51] "last resort" "no return value for void"
  {
    (65820 call compilerError "in a param for-loop, the count operator requires a param integral value")
  }
  function chpl_low_bound_count_for_param_loop[65831](param arg high[65828] :
  integral[199](?), param arg count[65834] :
  integral[199](?)) param : _unknown[51]
  {
    if(65888 call _cond_test(65839 call > count[65834] 0))
    {
      (65860 call compilerError "count operators with positive count require the range to have a low bound")
    }
    {
      if(65884 call _cond_test(65865 call == count[65834] 0))
      {
        (65871 return(65869 call + high[65828] 1))
      }
      {
        (65881 return(65879 call +(65876 call + high[65828] count[65834]) 1))
      }
    }
  }
  function chpl_low_bound_count_for_param_loop[65900](arg high[65898]:_any[178](?), arg count[65902]:_any[178](?)) : _unknown[51] "last resort" "no return value for void"
  {
    (65907 call compilerError "Range bounds must be integers of compatible types in param for-loops")
  }
  function chpl_high_bound_count_for_param_loop[65918](param arg low[65915] :
  integral[199](?), param arg count[65921] :
  integral[199](?)) param : _unknown[51]
  {
    if(65977 call _cond_test(65926 call < count[65921] 0))
    {
      (65949 call compilerError "count operators with negative count require the range to have a high bound")
    }
    {
      if(65973 call _cond_test(65954 call == count[65921] 0))
      {
        (65960 return(65958 call - low[65915] 1))
      }
      {
        (65970 return(65968 call -(65965 call + low[65915] count[65921]) 1))
      }
    }
  }
  function chpl_high_bound_count_for_param_loop[65989](arg low[65987]:_any[178](?), arg count[65991]:_any[178](?)) : _unknown[51] "last resort" "no return value for void"
  {
    (65996 call compilerError "Range bounds must be integers of compatible types in param for-loops")
  }
  function chpl_bounded_count_for_param_loop_low[66007](param arg low[66004] :
  integral[199](?), param arg high[66010] :
  integral[199](?), param arg count[66014] :
  integral[199](?)) param : _unknown[51]
  {
    unknown abs_count[66028] "param"(66025 IfExpr (66019 call < count[66014] 0) then
    { scopeless
      (66022 call - count[66014])
    } else
    { scopeless
      count[66014]
    } )
    (66031 'end of statement')
    unknown size[66040] "param"(66038 call +(66035 call - high[66010] low[66004]) 1)
    (66043 'end of statement')
    if(66133 call _cond_test(66046 call < size[66040] abs_count[66028]))
    {
      (66092 call compilerError "Count of "(66069 call _cast string[26] abs_count[66028]) " is too small for range of size "(66090 call _cast string[26] size[66040]))
    }
    {
      if(66128 call _cond_test(66097 call == count[66014] 0))
      {
        (66103 return(66101 call + high[66010] 1))
      }
      {
        if(66124 call _cond_test(66108 call < count[66014] 0))
        {
          (66117 return(66115 call +(66112 call + high[66010] count[66014]) 1))
        }
        {
          (66121 return low[66004])
        }
      }
    }
  }
  function chpl_bounded_count_for_param_loop_low[66144](arg low[66142]:_any[178](?), arg high[66146]:_any[178](?), arg count[66148]:_any[178](?)) : _unknown[51] "last resort" "no return value for void"
  {
    (66171 call compilerError "Range bounds and counts must be integers of compatible types in param for-loops")
  }
  function chpl_bounded_count_for_param_loop_high[66182](param arg low[66179] :
  integral[199](?), param arg high[66185] :
  integral[199](?), param arg count[66189] :
  integral[199](?)) param : _unknown[51]
  {
    if(66225 call _cond_test(66194 call == count[66189] 0))
    {
      (66200 return(66198 call - low[66179] 1))
    }
    {
      if(66221 call _cond_test(66205 call < count[66189] 0))
      {
        (66208 return high[66185])
      }
      {
        (66218 return(66216 call -(66213 call + low[66179] count[66189]) 1))
      }
    }
  }
  function chpl_bounded_count_for_param_loop_high[66237](arg low[66235]:_any[178](?), arg high[66239]:_any[178](?), arg count[66241]:_any[178](?)) : _unknown[51] "last resort" "no return value for void"
  {
    (66246 call compilerError "Range bounds and counts must be integers of compatible types in param for-loops")
  }
  function isRangeType[66255](arg t[66253]:_any[178](?)) param : _unknown[51]
  {
    function isRangeHelp[66266](arg t[66263] :
    (66262 call range[64319](?) ?[260])) param : _unknown[51]
    {
      (66269 return 1)
    }
    function isRangeHelp[66279](arg t[66277]:_any[178](?)) param : _unknown[51]
    {
      (66282 return 0)
    }
    (66291 return(66290 call isRangeHelp t[66253]))
  }
  function isRangeValue[66304](arg r[66301] :
  (66300 call range[64319](?) ?[260])) param : _unknown[51] "no doc"
  {
    (66307 return 1)
  }
  function isRangeValue[66316](arg r[66314]:_any[178](?)) param : _unknown[51] "no doc"
  {
    (66319 return 0)
  }
  function isBoundedRange[66328](arg r[66326]:_any[178](?)) param : _unknown[51] "no doc"
  {
    (66331 return 0)
  }
  function isBoundedRange[66345](arg r[66342] :
  (66341 call range[64319](?) ?[260])) param : _unknown[51]
  {
    (66354 return(66353 call isBoundedRange(66349 call . r[66342] c"boundedType")))
  }
  function isBoundedRange[66365](param arg B[66362] :
  BoundedRangeType[64216]) param : _unknown[51] "no doc"
  {
    (66374 return(66372 call == B[66362] bounded[64208]))
  }
  function range[64319](?).isBounded[66382](arg _mt[66387]:_MT[238], arg this[66384]:range[64319](?) :
  range[64319](?)) param : _unknown[51] "method"
  {
    (66396 return(66394 call ==(374010 call . this[66384] c"boundedType") bounded[64208]))
  }
  function range[64319](?).hasLowBound[66404](arg _mt[66409]:_MT[238], arg this[66406]:range[64319](?) :
  range[64319](?)) param : _unknown[51] "method"
  {
    (66427 return(66425 call ||(66416 call ==(374015 call . this[66406] c"boundedType") bounded[64208])(66423 call ==(374020 call . this[66406] c"boundedType") boundedLow[64210])))
  }
  function range[64319](?).hasHighBound[66435](arg _mt[66440]:_MT[238], arg this[66437]:range[64319](?) :
  range[64319](?)) param : _unknown[51] "method"
  {
    (66458 return(66456 call ||(66447 call ==(374025 call . this[66437] c"boundedType") bounded[64208])(66454 call ==(374030 call . this[66437] c"boundedType") boundedHigh[64212])))
  }
  function range[64319](?).stride[66466](arg _mt[66471]:_MT[238], arg this[66468]:range[64319](?) :
  range[64319](?)) : _unknown[51] "inline" "method" "no parens"
  {
    (66475 return(374040 call . this[66468] c"_stride"))
  }
  where {
    (374035 call . this[66468] c"stridable")
  }
  function range[64319](?).stride[66484](arg _mt[66489]:_MT[238], arg this[66486]:range[64319](?) :
  range[64319](?)) param : _unknown[51] "method" "no doc" "no parens"
  {
    (66498 return(66496 call _cast(374049 call . this[66486] c"strType") 1))
  }
  where {
    (66492 call !(374045 call . this[66486] c"stridable"))
  }
  function range[64319](?).alignment[66507](arg _mt[66512]:_MT[238], arg this[66509]:range[64319](?) :
  range[64319](?)) : _unknown[51] "inline" "method" "no parens"
  {
    (66519 return(66518 call(374058 call . this[66509] c"chpl_intToIdx")(374063 call . this[66509] c"_alignment")))
  }
  where {
    (374054 call . this[66509] c"stridable")
  }
  function range[64319](?).alignment[66528](arg _mt[66533]:_MT[238], arg this[66530]:range[64319](?) :
  range[64319](?)) : _unknown[51] "method" "no doc" "no parens"
  {
    (66544 return(374076 call . this[66530] c"low"))
  }
  where {
    (66541 call &&(66536 call !(374068 call . this[66530] c"stridable"))(66540 call(374072 call . this[66530] c"hasLowBound")))
  }
  function range[64319](?).alignment[66553](arg _mt[66558]:_MT[238], arg this[66555]:range[64319](?) :
  range[64319](?)) : _unknown[51] "method" "no doc" "no parens"
  {
    (66564 return(66563 call(374080 call . this[66555] c"chpl_intToIdx") 0))
  }
  function range[64319](?).aligned[66572](arg _mt[66577]:_MT[238], arg this[66574]:range[64319](?) :
  range[64319](?)) : _unknown[51] "inline" "method" "no parens"
  {
    (66581 return(374090 call . this[66574] c"_aligned"))
  }
  where {
    (374085 call . this[66574] c"stridable")
  }
  function range[64319](?).aligned[66590](arg _mt[66595]:_MT[238], arg this[66592]:range[64319](?) :
  range[64319](?)) param : _unknown[51] "method" "no doc" "no parens"
  {
    (66619 return 1)
  }
  where {
    (66616 call &&(66598 call !(374095 call . this[66592] c"stridable"))(66614 call ||(66605 call ==(374100 call . this[66592] c"boundedType") bounded[64208])(66612 call ==(374105 call . this[66592] c"boundedType") boundedLow[64210])))
  }
  function range[64319](?).aligned[66628](arg _mt[66633]:_MT[238], arg this[66630]:range[64319](?) :
  range[64319](?)) param : _unknown[51] "method" "no doc" "no parens"
  {
    (66636 return 0)
  }
  function range[64319](?).first[66644](arg _mt[66649]:_MT[238], arg this[66646]:range[64319](?) :
  range[64319](?)) : _unknown[51] "inline" "method" "no parens"
  {
    (66660 return(66659 call(374109 call . this[66646] c"chpl_intToIdx")(66655 call . this[66646] c"firstAsInt")))
  }
  function range[64319](?).firstAsInt[66668](arg _mt[66673]:_MT[238], arg this[66670]:range[64319](?) :
  range[64319](?)) : _unknown[51] "inline" "method" "no doc" "no parens"
  {
    if(66702 call _cond_test(66676 call !(374114 call . this[66670] c"stridable")))
    {
      (66679 return(374119 call . this[66670] c"_low"))
    }
    {
      (66700 return(66697 IfExpr (66683 call >(374124 call . this[66670] c"_stride") 0) then
      { scopeless
        (66688 call . this[66670] c"alignedLowAsInt")
      } else
      { scopeless
        (66694 call . this[66670] c"alignedHighAsInt")
      } ))
    }
  }
  function range[64319](?).last[66714](arg _mt[66719]:_MT[238], arg this[66716]:range[64319](?) :
  range[64319](?)) : _unknown[51] "inline" "method" "no parens"
  {
    (66730 return(66729 call(374128 call . this[66716] c"chpl_intToIdx")(66725 call . this[66716] c"lastAsInt")))
  }
  function range[64319](?).lastAsInt[66738](arg _mt[66743]:_MT[238], arg this[66740]:range[64319](?) :
  range[64319](?)) : _unknown[51] "inline" "method" "no doc" "no parens"
  {
    if(66768 call _cond_test(66746 call !(374133 call . this[66740] c"stridable")))
    {
      (66749 return(374138 call . this[66740] c"_high"))
    }
    {
      (66766 return(66763 IfExpr (66753 call >(374142 call . this[66740] c"stride") 0) then
      { scopeless
        (66756 call . this[66740] c"alignedHighAsInt")
      } else
      { scopeless
        (66760 call . this[66740] c"alignedLowAsInt")
      } ))
    }
  }
  function range[64319](?).low[66780](arg _mt[66785]:_MT[238], arg this[66782]:range[64319](?) :
  range[64319](?)) : _unknown[51] "inline" "method" "no parens"
  {
    (66791 return(66790 call(374146 call . this[66782] c"chpl_intToIdx")(374151 call . this[66782] c"_low")))
  }
  function range[64319](?).high[66799](arg _mt[66804]:_MT[238], arg this[66801]:range[64319](?) :
  range[64319](?)) : _unknown[51] "inline" "method" "no parens"
  {
    (66810 return(66809 call(374155 call . this[66801] c"chpl_intToIdx")(374160 call . this[66801] c"_high")))
  }
  function range[64319](?).alignedLow[66818](arg _mt[66823]:_MT[238], arg this[66820]:range[64319](?) :
  range[64319](?)) : _unknown[51] "inline" "method" "no parens"
  {
    (66833 return(66832 call(374169 call . this[66820] c"chpl_intToIdx")(66828 call . this[66820] c"alignedLowAsInt")))
  }
  { scopeless type
    (374165 call . this[66820] c"idxType")
  }
  function range[64319](?).alignedLowAsInt[66842](arg _mt[66847]:_MT[238], arg this[66844]:range[64319](?) :
  range[64319](?)) : _unknown[51] "inline" "method" "no doc" "no parens"
  {
    if(66866 call _cond_test(66850 call !(374174 call . this[66844] c"stridable")))
    {
      (66853 return(374179 call . this[66844] c"_low"))
    }
    {
      (66864 return(66862 call +(374184 call . this[66844] c"_low")(66861 call chpl__diffMod(374189 call . this[66844] c"_alignment")(374194 call . this[66844] c"_low")(374198 call . this[66844] c"stride"))))
    }
  }
  function range[64319](?).alignedHigh[66878](arg _mt[66883]:_MT[238], arg this[66880]:range[64319](?) :
  range[64319](?)) : _unknown[51] "inline" "method" "no parens"
  {
    (66893 return(66892 call(374207 call . this[66880] c"chpl_intToIdx")(66888 call . this[66880] c"alignedHighAsInt")))
  }
  { scopeless type
    (374203 call . this[66880] c"idxType")
  }
  function range[64319](?).alignedHighAsInt[66902](arg _mt[66907]:_MT[238], arg this[66904]:range[64319](?) :
  range[64319](?)) : _unknown[51] "inline" "method" "no doc" "no parens"
  {
    if(66926 call _cond_test(66910 call !(374212 call . this[66904] c"stridable")))
    {
      (66913 return(374217 call . this[66904] c"_high"))
    }
    {
      (66924 return(66922 call -(374222 call . this[66904] c"_high")(66921 call chpl__diffMod(374227 call . this[66904] c"_high")(374232 call . this[66904] c"_alignment")(374236 call . this[66904] c"stride"))))
    }
  }
  function range[64319](?).isEmpty[66938](arg _mt[66943]:_MT[238], arg this[66940]:range[64319](?) :
  range[64319](?)) : _unknown[51] "inline" "method"
  {
    if(66993 call _cond_test(66949 call && 1(66948 call(374241 call . this[66940] c"isAmbiguous"))))
    {
      (66973 call boundsCheckHalt module=[255] HaltWrappers[210085] "isEmpty() is invoked on an ambiguously-aligned range")
      (357660 'referenced modules list' HaltWrappers[210085])
    }
    {
      (66991 return(66989 call &&(66978 call isBoundedRange this[66940])(66987 call >(66980 call . this[66940] c"alignedLow")(66984 call . this[66940] c"alignedHigh"))))
    }
  }
  function range[64319](?).length[67005](arg _mt[67010]:_MT[238], arg this[67007]:range[64319](?) :
  range[64319](?)) : _unknown[51] "inline" "method" "no parens"
  {
    (67051 call compilerWarning(67048 call + "'range.length' is deprecated - " "please use 'range.size' instead"))
    (67058 return(67055 call . this[67007] c"size"))
  }
  { scopeless type
    (374246 call . this[67007] c"intIdxType")
  }
  function range[64319](?).size[67066](arg _mt[67071]:_MT[238], arg this[67068]:range[64319](?) :
  range[64319](?)) : _unknown[51] "method" "no parens"
  {
    if(67101 call _cond_test(67078 call !(67077 call isBoundedRange this[67068])))
    {
      (67099 call compilerError "'size' is not defined on unbounded ranges")
    }
    const ah[67111] "const"(67108 call . this[67068] c"alignedHighAsInt")
    const al[67118] "const"(67115 call . this[67068] c"alignedLowAsInt")
    (67121 'end of statement')
    if(67132 call _cond_test(67124 call > al[67118] ah[67111]))
    {
      (67130 return(67128 call _cast(374257 call . this[67068] c"intIdxType") 0))
    }
    const s[67147] "const"(67145 call _cast(374261 call . this[67068] c"intIdxType")(67143 call abs(67139 call . this[67068] c"stride")))
    (67150 'end of statement')
    (67164 return(67162 call +(67156 call /(67153 call - ah[67111] al[67118]) s[67147])(67160 call _cast(374268 call . this[67068] c"intIdxType") 1)))
  }
  { scopeless type
    (374250 call . this[67068] c"intIdxType")
  }
  function range[64319](?).hasFirst[67172](arg _mt[67177]:_MT[238], arg this[67174]:range[64319](?) :
  range[64319](?)) param : _unknown[51] "method"
  {
    (67192 return(67191 call(374281 call . this[67174] c"hasLowBound")))
  }
  where {
    (67187 call &&(67180 call !(374273 call . this[67174] c"stridable"))(67185 call !(67184 call(374277 call . this[67174] c"hasHighBound"))))
  }
  function range[64319](?).hasFirst[67201](arg _mt[67206]:_MT[238], arg this[67203]:range[64319](?) :
  range[64319](?)) : _unknown[51] "inline" "method" "no doc"
  {
    (67233 return(67230 IfExpr (67214 call ||(67210 call(374285 call . this[67203] c"isAmbiguous"))(67213 call(374289 call . this[67203] c"isEmpty"))) then
    { scopeless
      0
    } else
    { scopeless(67227 IfExpr (67219 call >(374293 call . this[67203] c"stride") 0) then
      { scopeless
        (67223 call(374297 call . this[67203] c"hasLowBound"))
      } else
      { scopeless
        (67226 call(374301 call . this[67203] c"hasHighBound"))
      } )
    } ))
  }
  function range[64319](?).hasLast[67241](arg _mt[67246]:_MT[238], arg this[67243]:range[64319](?) :
  range[64319](?)) param : _unknown[51] "method"
  {
    (67261 return(67260 call(374314 call . this[67243] c"hasHighBound")))
  }
  where {
    (67256 call &&(67249 call !(374306 call . this[67243] c"stridable"))(67254 call !(67253 call(374310 call . this[67243] c"hasLowBound"))))
  }
  function range[64319](?).hasLast[67270](arg _mt[67275]:_MT[238], arg this[67272]:range[64319](?) :
  range[64319](?)) : _unknown[51] "inline" "method" "no doc"
  {
    (67302 return(67299 IfExpr (67283 call ||(67279 call(374318 call . this[67272] c"isAmbiguous"))(67282 call(374322 call . this[67272] c"isEmpty"))) then
    { scopeless
      0
    } else
    { scopeless(67296 IfExpr (67288 call >(374326 call . this[67272] c"stride") 0) then
      { scopeless
        (67292 call(374330 call . this[67272] c"hasHighBound"))
      } else
      { scopeless
        (67295 call(374334 call . this[67272] c"hasLowBound"))
      } )
    } ))
  }
  function range[64319](?).isNaturallyAligned[67310](arg _mt[67315]:_MT[238], arg this[67312]:range[64319](?) :
  range[64319](?)) : _unknown[51] "method"
  {
    if(67343 call _cond_test(67332 call >(374343 call . this[67312] c"stride") 0))
    {
      (67341 return(67339 call ==(67335 call . this[67312] c"alignedLowAsInt")(374348 call . this[67312] c"_low")))
    }
    if(67362 call _cond_test(67351 call <(374352 call . this[67312] c"stride") 0))
    {
      (67360 return(67358 call ==(67354 call . this[67312] c"alignedHighAsInt")(374357 call . this[67312] c"_high")))
    }
    (67368 return 0)
  }
  where {
    (67328 call &&(374339 call . this[67312] c"stridable")(67326 call ==(67319 call . this[67312] c"boundedType") bounded[64208]))
  }
  function range[64319](?).isNaturallyAligned[67376](arg _mt[67381]:_MT[238], arg this[67378]:range[64319](?) :
  range[64319](?)) param : _unknown[51] "inline" "method" "no doc"
  {
    (67399 return 1)
  }
  where {
    (67396 call &&(67384 call !(374362 call . this[67378] c"stridable"))(67394 call ==(67387 call . this[67378] c"boundedType") bounded[64208]))
  }
  function range[64319](?).isNaturallyAligned[67408](arg _mt[67413]:_MT[238], arg this[67410]:range[64319](?) :
  range[64319](?)) : _unknown[51] "inline" "method" "no doc"
  {
    (67437 return(67435 call ==(67431 call . this[67410] c"alignedLowAsInt")(374372 call . this[67410] c"_low")))
  }
  where {
    (67428 call &&(67416 call !(374367 call . this[67410] c"stridable"))(67426 call ==(67419 call . this[67410] c"boundedType") boundedLow[64210]))
  }
  function range[64319](?).isNaturallyAligned[67446](arg _mt[67451]:_MT[238], arg this[67448]:range[64319](?) :
  range[64319](?)) : _unknown[51] "inline" "method" "no doc"
  {
    (67479 return(67477 call &&(67468 call >(374381 call . this[67448] c"stride") 0)(67475 call ==(67471 call . this[67448] c"alignedLowAsInt")(374386 call . this[67448] c"_low"))))
  }
  where {
    (67464 call &&(374377 call . this[67448] c"stridable")(67462 call ==(67455 call . this[67448] c"boundedType") boundedLow[64210]))
  }
  function range[64319](?).isNaturallyAligned[67488](arg _mt[67493]:_MT[238], arg this[67490]:range[64319](?) :
  range[64319](?)) param : _unknown[51] "inline" "method" "no doc"
  {
    (67523 return 0)
  }
  where {
    (67520 call ||(67503 call ==(67496 call . this[67490] c"boundedType") boundedNone[64214])(67518 call &&(67506 call !(374391 call . this[67490] c"stridable"))(67516 call ==(67509 call . this[67490] c"boundedType") boundedHigh[64212])))
  }
  function range[64319](?).isNaturallyAligned[67532](arg _mt[67537]:_MT[238], arg this[67534]:range[64319](?) :
  range[64319](?)) : _unknown[51] "inline" "method" "no doc"
  {
    (67565 return(67563 call &&(67554 call <(374400 call . this[67534] c"stride") 0)(67561 call ==(67557 call . this[67534] c"alignedHighAsInt")(374405 call . this[67534] c"_high"))))
  }
  where {
    (67550 call &&(374396 call . this[67534] c"stridable")(67548 call ==(67541 call . this[67534] c"boundedType") boundedHigh[64212]))
  }
  function range[64319](?).isAmbiguous[67574](arg _mt[67579]:_MT[238], arg this[67576]:range[64319](?) :
  range[64319](?)) param : _unknown[51] "method"
  {
    (67585 return 0)
  }
  where {
    (67582 call !(374410 call . this[67576] c"stridable"))
  }
  function range[64319](?).isAmbiguous[67594](arg _mt[67599]:_MT[238], arg this[67596]:range[64319](?) :
  range[64319](?)) : _unknown[51] "method" "no doc"
  {
    (67619 return(67617 call &&(67603 call !(374419 call . this[67596] c"aligned"))(67615 call ||(67607 call >(374423 call . this[67596] c"stride") 1)(67613 call <(374427 call . this[67596] c"stride")(67611 call - 1)))))
  }
  where {
    (374415 call . this[67596] c"stridable")
  }
  function range[64319](?).contains[67632](arg _mt[67637]:_MT[238], arg this[67634]:range[64319](?) :
  range[64319](?), arg ind[67629] :
  (374432 call . this[67634] c"idxType")) : _unknown[51] "inline" "method"
  {
    if(67650 call _cond_test(67646 call(67642 call . this[67634] c"isAmbiguous")))
    {
      (67648 return 0)
    }
    const i[67660] "const"(67659 call chpl__idxToInt ind[67629])
    (67663 'end of statement')
    if(67680 call _cond_test(67666 call(374437 call . this[67634] c"hasHighBound")))
    {
      if(67674 call _cond_test(67669 call > i[67660](374443 call . this[67634] c"_high")))
      {
        (67672 return 0)
      }
    }
    if(67700 call _cond_test(67686 call(374447 call . this[67634] c"hasLowBound")))
    {
      if(67694 call _cond_test(67689 call < i[67660](374453 call . this[67634] c"_low")))
      {
        (67692 return 0)
      }
    }
    if(67734 call _cond_test(374458 call . this[67634] c"stridable"))
    {
      unknown s[67712](67710 call _cast(374467 call . this[67634] c"intIdxType")(67708 call abs(374463 call . this[67634] c"_stride")))
      (67715 'end of statement')
      if(67729 call _cond_test(67724 call !=(67722 call chpl__diffMod i[67660](374473 call . this[67634] c"_alignment") s[67712]) 0))
      {
        (67727 return 0)
      }
    }
    (67739 return 1)
  }
  function range[64319](?).contains[67753](arg _mt[67758]:_MT[238], arg this[67755]:range[64319](?) :
  range[64319](?), arg other[67750] :
  (67749 call range[64319](?) ?[260])) : _unknown[51] "inline" "method"
  {
    if(67777 call _cond_test(67772 call ||(67765 call(67761 call . this[67755] c"isAmbiguous"))(67771 call(67767 call . other[67750] c"isAmbiguous"))))
    {
      (67775 return 0)
    }
    if(67845 call _cond_test(374480 call . this[67755] c"stridable"))
    {
      if(67819 call _cond_test(67810 call ||(67795 call &&(67786 call >(374484 call . this[67755] c"stride") 0)(67793 call <(67789 call . other[67750] c"stride") 0))(67808 call &&(67799 call <(374488 call . this[67755] c"stride") 0)(67806 call >(67802 call . other[67750] c"stride") 0))))
      {
        (67817 return(67816 call _containsHelp this[67755] other[67750]))
      }
    }
    {
      if(67839 call _cond_test(67830 call <(67826 call . other[67750] c"stride") 0))
      {
        (67837 return(67836 call _containsHelp this[67755] other[67750]))
      }
    }
    (67856 return(67854 call == other[67750](67853 call this[67755] other[67750])))
  }
  function range[64319](?).member[67867](arg _mt[67872]:_MT[238], arg this[67869]:range[64319](?) :
  range[64319](?), arg ind[67864] :
  (374500 call . this[67869] c"idxType")) : _unknown[51] "inline" "method"
  {
    (67912 call compilerWarning(67909 call + "range.member is deprecated - " "please use range.contains instead"))
    (67924 return(67923 call(67918 call . this[67869] c"contains") ind[67864]))
  }
  function range[64319](?).member[67938](arg _mt[67943]:_MT[238], arg this[67940]:range[64319](?) :
  range[64319](?), arg other[67935] :
  (67934 call range[64319](?) ?[260])) : _unknown[51] "inline" "method"
  {
    (67951 call compilerWarning(67948 call + "range.member is deprecated - " "please use range.contains instead"))
    (67961 return(67960 call(67955 call . this[67940] c"contains") other[67935]))
  }
  function _containsHelp[67974](in arg arg1[67971] :
  (67970 call range[64319](?) ?[260]), in arg arg2[67980] :
  (67979 call range[64319](?) ?[260])) : _unknown[51] "inline" "private"
  {
    if(68013 call _cond_test(67984 call . arg2[67980] c"stridable"))
    {
      (67997 call =(67988 call . arg2[67980] c"_stride")(67995 call -(67992 call . arg2[67980] c"_stride")))
    }
    {
      (68010 call =(68001 call . arg1[67971] c"_stride")(68008 call -(68005 call . arg1[67971] c"_stride")))
    }
    (68027 return(68025 call == arg2[67980](68024 call arg1[67971] arg2[67980])))
  }
  function ==[68040](arg r1[68037] :
  (68036 call range[64319](?) ?[260]), arg r2[68046] :
  (68045 call range[64319](?) ?[260])) param : _unknown[51]
  {
    (68060 return 0)
  }
  where {
    (68057 call !=(68050 call . r1[68037] c"boundedType")(68054 call . r2[68046] c"boundedType"))
  }
  function ==[68075](arg r1[68072] :
  (68071 call range[64319](?) ?[260]), arg r2[68081] :
  (68080 call range[64319](?) ?[260])) : _unknown[51]
  {
    if(68112 call _cond_test(68107 call !=(68100 call(68096 call . r1[68072] c"isAmbiguous"))(68106 call(68102 call . r2[68081] c"isAmbiguous"))))
    {
      (68110 return 0)
    }
    if(68131 call _cond_test(68123 call(68119 call . r1[68072] c"isAmbiguous")))
    {
      (68129 return(68128 call ident r1[68072] r2[68081]))
    }
    if(68313 call _cond_test(68139 call isBoundedRange r1[68072]))
    {
      const len[68144] "const"(68141 call . r1[68072] c"size")
      const l2[68151] "const"(68148 call . r2[68081] c"size")
      (68154 'end of statement')
      if(68163 call _cond_test(68158 call != len[68144] l2[68151]))
      {
        (68161 return 0)
      }
      if(68175 call _cond_test(68170 call == len[68144] 0))
      {
        (68173 return 1)
      }
      if(68195 call _cond_test(68190 call !=(68183 call . r1[68072] c"first")(68187 call . r2[68081] c"first")))
      {
        (68193 return 0)
      }
      if(68207 call _cond_test(68202 call == len[68144] 1))
      {
        (68205 return 1)
      }
      if(68225 call _cond_test(68220 call !=(68213 call . r1[68072] c"stride")(68217 call . r2[68081] c"stride")))
      {
        (68223 return 0)
      }
      (68231 return 1)
    }
    {
      if(68246 call _cond_test(68241 call !=(68234 call . r1[68072] c"stride")(68238 call . r2[68081] c"stride")))
      {
        (68244 return 0)
      }
      if(68276 call _cond_test(68257 call(68253 call . r1[68072] c"hasLowBound")))
      {
        if(68271 call _cond_test(68266 call !=(68259 call . r1[68072] c"alignedLow")(68263 call . r2[68081] c"alignedLow")))
        {
          (68269 return 0)
        }
      }
      if(68305 call _cond_test(68286 call(68282 call . r1[68072] c"hasHighBound")))
      {
        if(68300 call _cond_test(68295 call !=(68288 call . r1[68072] c"alignedHigh")(68292 call . r2[68081] c"alignedHigh")))
        {
          (68298 return 0)
        }
      }
      (68311 return 1)
    }
  }
  where {
    (68093 call ==(68086 call . r1[68072] c"boundedType")(68090 call . r2[68081] c"boundedType"))
  }
  { scopeless type
    bool[10]
  }
  function !=[68330](arg r1[68327] :
  (68326 call range[64319](?) ?[260]), arg r2[68336] :
  (68335 call range[64319](?) ?[260])) : _unknown[51]
  {
    (68345 return(68343 call !(68341 call == r1[68327] r2[68336])))
  }
  function ident[68359](arg r1[68356] :
  (68355 call range[64319](?) ?[260]), arg r2[68365] :
  (68364 call range[64319](?) ?[260])) : _unknown[51]
  {
    if(68415 call _cond_test(68410 call !=(68403 call . r1[68356] c"_low")(68407 call . r2[68365] c"_low")))
    {
      (68413 return 0)
    }
    if(68434 call _cond_test(68429 call !=(68422 call . r1[68356] c"_high")(68426 call . r2[68365] c"_high")))
    {
      (68432 return 0)
    }
    if(68511 call _cond_test(68440 call . r1[68356] c"stridable"))
    {
      if(68506 call _cond_test(68444 call . r2[68365] c"stridable"))
      {
        if(68460 call _cond_test(68455 call !=(68448 call . r1[68356] c"_stride")(68452 call . r2[68365] c"_stride")))
        {
          (68458 return 0)
        }
        if(68479 call _cond_test(68474 call !=(68467 call . r1[68356] c"_alignment")(68471 call . r2[68365] c"_alignment")))
        {
          (68477 return 0)
        }
        if(68497 call _cond_test(68492 call !=(68485 call . r1[68356] c"_aligned")(68489 call . r2[68365] c"_aligned")))
        {
          (68495 return 0)
        }
      }
      {
        (68503 return 0)
      }
    }
    (68516 return 1)
  }
  where {
    (68400 call &&(68388 call &&(68376 call ==(68369 call . r1[68356] c"idxType")(68373 call . r2[68365] c"idxType"))(68386 call ==(68379 call . r1[68356] c"boundedType")(68383 call . r2[68365] c"boundedType")))(68398 call ==(68391 call . r1[68356] c"stridable")(68395 call . r2[68365] c"stridable")))
  }
  function ident[68530](arg r1[68527] :
  (68526 call range[64319](?) ?[260]), arg r2[68536] :
  (68535 call range[64319](?) ?[260])) param : _unknown[51] "no doc"
  {
    (68540 return 0)
  }
  function range[64319](?).safeCast[68555](arg _mt[68560]:_MT[238], arg this[68557]:range[64319](?) :
  range[64319](?), arg t[68552] :
  (68551 call range[64319](?) ?[260])) : _unknown[51] "method" "no doc"
  {
    unknown tmp[68563] t[68552]
    (68566 'end of statement')
    if(68631 call _cond_test(68576 call !=(68569 call . tmp[68563] c"boundedType")(68573 call . this[68557] c"boundedType")))
    {
      (68628 call compilerError "cannot cast range from "(68602 call _cast string[26](68598 call . this[68557] c"boundedType")) " to "(68626 call _cast string[26](68622 call . tmp[68563] c"boundedType")))
    }
    if(68725 call _cond_test(68636 call . tmp[68563] c"stridable"))
    {
      (68647 call =(68640 call . tmp[68563] c"_stride")(68644 call . this[68557] c"stride"))
      (68673 call =(68652 call . tmp[68563] c"_alignment")(68672 call(68662 call .(68661 call chpl__idxToInt(68657 call . this[68557] c"alignment")) c"safeCast")(68668 call . tmp[68563] c"intIdxType")))
      (68684 call =(68677 call . tmp[68563] c"_aligned")(68681 call . this[68557] c"aligned"))
    }
    {
      if(68721 call _cond_test(68692 call !=(68688 call . this[68557] c"stride") 1))
      {
        (68718 call safeCastCheckHalt module=[255] HaltWrappers[210085] "illegal safeCast from non-unit stride range to unstridable range")
        (357756 'referenced modules list' HaltWrappers[210085])
      }
    }
    (68747 call =(68731 call . tmp[68563] c"_low")(68746 call(68738 call .(68735 call . this[68557] c"_low") c"safeCast")(68742 call . tmp[68563] c"intIdxType")))
    (68767 call =(68751 call . tmp[68563] c"_high")(68766 call(68758 call .(68755 call . this[68557] c"_high") c"safeCast")(68762 call . tmp[68563] c"intIdxType")))
    (68771 return tmp[68563])
  }
  function _cast[68784](arg t[68781] :
  (68780 call range[64319](?) ?[260]), arg r[68790] :
  (68789 call range[64319](?) ?[260])) : _unknown[51] "no doc"
  {
    unknown tmp[68794] t[68781]
    (68797 'end of statement')
    if(68830 call _cond_test(68807 call !=(68800 call . tmp[68794] c"boundedType")(68804 call . r[68790] c"boundedType")))
    {
      (68827 call compilerError "cannot cast range from "(68817 call _cast string[26](68813 call . r[68790] c"boundedType")) " to "(68825 call _cast string[26](68821 call . tmp[68794] c"boundedType")))
    }
    if(68878 call _cond_test(68835 call . tmp[68794] c"stridable"))
    {
      (68846 call =(68839 call . tmp[68794] c"_stride")(68843 call . r[68790] c"_stride"))
      (68864 call =(68851 call . tmp[68794] c"_alignment")(68862 call _cast(68859 call . tmp[68794] c"intIdxType")(68855 call . r[68790] c"_alignment")))
      (68875 call =(68868 call . tmp[68794] c"_aligned")(68872 call . r[68790] c"_aligned"))
    }
    (68896 call =(68883 call . tmp[68794] c"_low")(68894 call _cast(68891 call . tmp[68794] c"intIdxType")(68887 call . r[68790] c"low")))
    (68913 call =(68900 call . tmp[68794] c"_high")(68911 call _cast(68908 call . tmp[68794] c"intIdxType")(68904 call . r[68790] c"high")))
    (68917 return tmp[68794])
  }
  function range[64319](?).boundsCheck[68936](arg _mt[68941]:_MT[238], arg this[68938]:range[64319](?) :
  range[64319](?), arg other[68933] :
  (68932 call range[64319](?) unknown e[68925] unknown b[68928] unknown s[68930])) : _unknown[51] "inline" "method"
  {
    if(68967 call _cond_test(68962 call ||(68955 call(68951 call . this[68938] c"isAmbiguous"))(68961 call(68957 call . other[68933] c"isAmbiguous"))))
    {
      (68965 return 0)
    }
    (68974 return 1)
  }
  where {
    (68948 call == b[68928] boundedNone[64214])
  }
  function range[64319](?).boundsCheck[68994](arg _mt[68999]:_MT[238], arg this[68996]:range[64319](?) :
  range[64319](?), arg other[68991] :
  (68990 call range[64319](?) unknown e[68983] unknown b[68986] unknown s[68988])) : _unknown[51] "inline" "method" "no doc"
  {
    if(69018 call _cond_test(69013 call ||(69006 call(69002 call . this[68996] c"isAmbiguous"))(69012 call(69008 call . other[68991] c"isAmbiguous"))))
    {
      (69016 return 0)
    }
    unknown boundedOther[69077](69024 'new'(69076 call range[64319](?)(374543 call . this[68996] c"idxType") bounded[64208](69037 call || s[68988](69034 call . this[68996] c"stridable"))(69050 IfExpr (69044 call(69040 call . other[68991] c"hasLowBound")) then
    { scopeless
      (69046 call . other[68991] c"low")
    } else
    { scopeless
      (374548 call . this[68996] c"low")
    } )(69064 IfExpr (69058 call(69054 call . other[68991] c"hasHighBound")) then
    { scopeless
      (69060 call . other[68991] c"high")
    } else
    { scopeless
      (374552 call . this[68996] c"high")
    } )(69068 call . other[68991] c"stride")(69072 call . other[68991] c"alignment") 1))
    (69080 'end of statement')
    (69094 return(69092 call ||(69086 call ==(69082 call . boundedOther[69077] c"size") 0)(69091 call(374556 call . this[68996] c"contains") boundedOther[69077])))
  }
  function range[64319](?).boundsCheck[69105](arg _mt[69110]:_MT[238], arg this[69107]:range[64319](?) :
  range[64319](?), arg other[69102] :
  (374562 call . this[69107] c"idxType")) : _unknown[51] "inline" "method"
  {
    (69116 return(69115 call(374566 call . this[69107] c"contains") other[69102]))
  }
  function range[64319](?).alignLow[69124](arg _mt[69129]:_MT[238], ref arg this[69126]:range[64319](?) :
  range[64319](?)) : _unknown[51] "method" "no doc"
  {
    if(69166 call _cond_test(69138 call && 1(69137 call(69133 call . this[69126] c"isAmbiguous"))))
    {
      (69164 call boundsCheckHalt module=[255] HaltWrappers[210085] "alignLow -- Cannot be applied to a range with ambiguous alignment.")
      (357801 'referenced modules list' HaltWrappers[210085])
    }
    if(69181 call _cond_test(374573 call . this[69126] c"stridable"))
    {
      (69178 call =(374578 call . this[69126] c"_low")(69175 call . this[69126] c"alignedLowAsInt"))
    }
    (69187 return this[69126])
  }
  function range[64319](?).alignHigh[69194](arg _mt[69199]:_MT[238], ref arg this[69196]:range[64319](?) :
  range[64319](?)) : _unknown[51] "method" "no doc"
  {
    if(69234 call _cond_test(69208 call && 1(69207 call(69203 call . this[69196] c"isAmbiguous"))))
    {
      (69232 call boundsCheckHalt module=[255] HaltWrappers[210085] "alignHigh -- Cannot be applied to a range with ambiguous alignment.")
      (357809 'referenced modules list' HaltWrappers[210085])
    }
    if(69249 call _cond_test(374585 call . this[69196] c"stridable"))
    {
      (69246 call =(374590 call . this[69196] c"_high")(69243 call . this[69196] c"alignedHighAsInt"))
    }
    (69255 return this[69196])
  }
  function range[64319](?).indexOrder[69266](arg _mt[69271]:_MT[238], arg this[69268]:range[64319](?) :
  range[64319](?), arg ind[69263] :
  (374596 call . this[69268] c"idxType")) : _unknown[51] "method"
  {
    if(69306 call _cond_test(69280 call && 1(69279 call(69275 call . this[69268] c"isAmbiguous"))))
    {
      (69304 call boundsCheckHalt module=[255] HaltWrappers[210085] "indexOrder -- Undefined on a range with ambiguous alignment.")
      (357817 'referenced modules list' HaltWrappers[210085])
    }
    if(69326 call _cond_test(69316 call !(69315 call(374601 call . this[69268] c"contains") ind[69263])))
    {
      (69324 return(69322 call _cast(374606 call . this[69268] c"intIdxType")(69319 call - 1)))
    }
    if(69396 call _cond_test(69332 call !(374611 call . this[69268] c"stridable")))
    {
      if(69349 call _cond_test(69339 call(69335 call . this[69268] c"hasLowBound")))
      {
        (69347 return(69345 call -(69343 call chpl__idxToInt ind[69263])(374617 call . this[69268] c"_low")))
      }
    }
    {
      if(69390 call _cond_test(69362 call(69358 call . this[69268] c"hasFirst")))
      {
        (69388 return(69386 call _cast(374635 call . this[69268] c"intIdxType")(69383 call /(69380 call -(69368 call _cast(374622 call . this[69268] c"strType")(69366 call chpl__idxToInt ind[69263]))(69378 call _cast(374626 call . this[69268] c"strType")(69376 call chpl__idxToInt(69372 call . this[69268] c"first"))))(374631 call . this[69268] c"_stride"))))
      }
    }
    (69406 return(69404 call _cast(374639 call . this[69268] c"intIdxType")(69401 call - 1)))
  }
  function range[64319](?).orderToIndex[69417](arg _mt[69422]:_MT[238], arg this[69419]:range[64319](?) :
  range[64319](?), arg ord[69414] :
  integral[199](?)) : _unknown[51] "method"
  {
    if(69608 call _cond_test 1)
    {
      if(69455 call _cond_test(69429 call !(69428 call(374650 call . this[69419] c"hasFirst"))))
      {
        (69453 call boundsCheckHalt module=[255] HaltWrappers[210085] "invoking orderToIndex on a range that has no first index")
        (357826 'referenced modules list' HaltWrappers[210085])
      }
      if(69488 call _cond_test(69463 call(374654 call . this[69419] c"isAmbiguous")))
      {
        (69486 call boundsCheckHalt module=[255] HaltWrappers[210085] "invoking orderToIndex on a range that is ambiguously aligned")
        (357832 'referenced modules list' HaltWrappers[210085])
      }
      if(69527 call _cond_test(69495 call < ord[69414] 0))
      {
        (69525 call boundsCheckHalt module=[255] HaltWrappers[210085](69522 call + "invoking orderToIndex on a negative integer: "(69520 call _cast string[26] ord[69414])))
        (357838 'referenced modules list' HaltWrappers[210085])
      }
      if(69603 call _cond_test(69543 call &&(69535 call isBoundedRange this[69419])(69541 call >= ord[69414](69538 call . this[69419] c"size"))))
      {
        (69601 call boundsCheckHalt module=[255] HaltWrappers[210085](69598 call +(69589 call +(69570 call + "invoking orderToIndex on an integer "(69568 call _cast string[26] ord[69414])) " that is larger than the range's number of indices ")(69596 call _cast string[26](69592 call . this[69419] c"size"))))
        (357845 'referenced modules list' HaltWrappers[210085])
      }
    }
    (69628 return(69627 call(374663 call . this[69419] c"chpl_intToIdx")(69625 call chpl__addRangeStrides(69616 call . this[69419] c"firstAsInt")(69621 call . this[69419] c"stride") ord[69414])))
  }
  { scopeless type
    (374645 call . this[69419] c"idxType")
  }
  function range[64319](?).translate[69640](arg _mt[69645]:_MT[238], arg this[69642]:range[64319](?) :
  range[64319](?), arg offset[69637] :
  integral[199](?)) : _unknown[51] "inline" "method"
  {
    (69651 return(69649 call + this[69642] offset[69637]))
  }
  function range[64319](?).translate[69661](arg _mt[69666]:_MT[238], arg this[69663]:range[64319](?) :
  range[64319](?), arg i[69659]:_any[178](?)) : _unknown[51] "inline" "method" "no doc" "no return value for void"
  {
    (69687 call compilerError "offsets must be of integral type")
  }
  function range[64319](?)._effAlmt[69695](arg _mt[69700]:_MT[238], arg this[69697]:range[64319](?) :
  range[64319](?)) : _unknown[51] "inline" "method" "no doc"
  {
    (69704 return(374676 call . this[69697] c"alignment"))
  }
  where {
    (374672 call . this[69697] c"stridable")
  }
  function range[64319](?)._effAlmt[69713](arg _mt[69718]:_MT[238], arg this[69715]:range[64319](?) :
  range[64319](?)) : _unknown[51] "method" "no doc"
  {
    (69727 return(69726 call(374685 call . this[69715] c"chpl_intToIdx") 0))
  }
  where {
    (69721 call !(374681 call . this[69715] c"stridable"))
  }
  function range[64319](?).interior[69740](arg _mt[69745]:_MT[238], arg this[69742]:range[64319](?) :
  range[64319](?), arg offset[69737] :
  integral[199](?)) : _unknown[51] "method" "no doc" "no return value for void"
  {
    (69773 call compilerError "interior is not supported on unbounded ranges")
  }
  where {
    (69752 call !=(374691 call . this[69742] c"boundedType") bounded[64208])
  }
  function range[64319](?).interior[69786](arg _mt[69791]:_MT[238], arg this[69788]:range[64319](?) :
  range[64319](?), arg offset[69783] :
  integral[199](?)) : _unknown[51] "method"
  {
    const i[69800] "const"(69799 call(69794 call . offset[69783] c"safeCast")(374696 call . this[69788] c"intIdxType"))
    (69803 'end of statement')
    if(69834 call _cond_test(69807 call < i[69800] 0))
    {
      (69832 return(69809 'new'(69831 call range[64319](?)(374703 call . this[69788] c"idxType")(374708 call . this[69788] c"boundedType")(374713 call . this[69788] c"stridable")(374717 call . this[69788] c"low")(69825 call(374721 call . this[69788] c"chpl_intToIdx")(69822 call -(69819 call -(374726 call . this[69788] c"_low") 1) i[69800]))(374731 call . this[69788] c"stride")(69829 call(374737 call . this[69788] c"_effAlmt"))(374741 call . this[69788] c"aligned"))))
    }
    if(69868 call _cond_test(69841 call > i[69800] 0))
    {
      (69866 return(69843 'new'(69865 call range[64319](?)(374748 call . this[69788] c"idxType")(374753 call . this[69788] c"boundedType")(374758 call . this[69788] c"stridable")(69858 call(374762 call . this[69788] c"chpl_intToIdx")(69855 call -(69852 call +(374767 call . this[69788] c"_high") 1) i[69800]))(374772 call . this[69788] c"high")(374776 call . this[69788] c"stride")(69863 call(374780 call . this[69788] c"_effAlmt"))(374784 call . this[69788] c"aligned"))))
    }
    (69887 return(69873 'new'(69886 call range[64319](?)(374790 call . this[69788] c"idxType")(374795 call . this[69788] c"boundedType")(374800 call . this[69788] c"stridable")(374804 call . this[69788] c"low")(374808 call . this[69788] c"high")(374812 call . this[69788] c"stride")(69884 call(374816 call . this[69788] c"_effAlmt"))(374820 call . this[69788] c"aligned"))))
  }
  function range[64319](?).exterior[69898](arg _mt[69903]:_MT[238], arg this[69900]:range[64319](?) :
  range[64319](?), arg offset[69895] :
  integral[199](?)) : _unknown[51] "method" "no doc" "no return value for void"
  {
    (69931 call compilerError "exterior is not supported on unbounded ranges")
  }
  where {
    (69910 call !=(374826 call . this[69900] c"boundedType") bounded[64208])
  }
  function range[64319](?).exterior[69944](arg _mt[69949]:_MT[238], arg this[69946]:range[64319](?) :
  range[64319](?), arg offset[69941] :
  integral[199](?)) : _unknown[51] "method"
  {
    const i[69958] "const"(69957 call(69952 call . offset[69941] c"safeCast")(374831 call . this[69946] c"intIdxType"))
    (69961 'end of statement')
    if(69995 call _cond_test(69965 call < i[69958] 0))
    {
      (69993 return(69967 'new'(69992 call range[64319](?)(374838 call . this[69946] c"idxType")(374843 call . this[69946] c"boundedType")(374848 call . this[69946] c"stridable")(69979 call(374852 call . this[69946] c"chpl_intToIdx")(69976 call +(374857 call . this[69946] c"_low") i[69958]))(69986 call(374862 call . this[69946] c"chpl_intToIdx")(69983 call -(374867 call . this[69946] c"_low") 1))(374871 call . this[69946] c"stride")(69990 call(374875 call . this[69946] c"_effAlmt"))(374879 call . this[69946] c"aligned"))))
    }
    if(70032 call _cond_test(70002 call > i[69958] 0))
    {
      (70030 return(70004 'new'(70029 call range[64319](?)(374886 call . this[69946] c"idxType")(374891 call . this[69946] c"boundedType")(374896 call . this[69946] c"stridable")(70016 call(374900 call . this[69946] c"chpl_intToIdx")(70013 call +(374905 call . this[69946] c"_high") 1))(70023 call(374909 call . this[69946] c"chpl_intToIdx")(70020 call +(374914 call . this[69946] c"_high") i[69958]))(374919 call . this[69946] c"stride")(70027 call(374923 call . this[69946] c"_effAlmt"))(374927 call . this[69946] c"aligned"))))
    }
    (70051 return(70037 'new'(70050 call range[64319](?)(374933 call . this[69946] c"idxType")(374938 call . this[69946] c"boundedType")(374943 call . this[69946] c"stridable")(374947 call . this[69946] c"low")(374951 call . this[69946] c"high")(374955 call . this[69946] c"stride")(70048 call(374959 call . this[69946] c"_effAlmt"))(374963 call . this[69946] c"aligned"))))
  }
  function range[64319](?).expand[70062](arg _mt[70067]:_MT[238], arg this[70064]:range[64319](?) :
  range[64319](?), arg offset[70059] :
  integral[199](?)) : _unknown[51] "method" "no doc" "no return value for void"
  {
    (70095 call compilerError "expand() is not supported on unbounded ranges")
  }
  where {
    (70074 call !=(374969 call . this[70064] c"boundedType") bounded[64208])
  }
  function range[64319](?).expand[70108](arg _mt[70113]:_MT[238], arg this[70110]:range[64319](?) :
  range[64319](?), arg offset[70105] :
  integral[199](?)) : _unknown[51] "method"
  {
    const i[70122] "const"(70121 call(70116 call . offset[70105] c"safeCast")(374974 call . this[70110] c"intIdxType"))
    (70125 'end of statement')
    (70151 return(70127 'new'(70150 call range[64319](?)(374980 call . this[70110] c"idxType")(374985 call . this[70110] c"boundedType")(374990 call . this[70110] c"stridable")(70139 call(374994 call . this[70110] c"chpl_intToIdx")(70136 call -(374999 call . this[70110] c"_low") i[70122]))(70146 call(375004 call . this[70110] c"chpl_intToIdx")(70143 call +(375009 call . this[70110] c"_high") i[70122]))(375014 call . this[70110] c"stride")(375018 call . this[70110] c"alignment")(375023 call . this[70110] c"_aligned"))))
  }
  function =[70166](ref arg r1[70163] :
  (70162 call range[64319](?)(stridable = unknown s1[70158])), arg r2[70174] :
  (70173 call range[64319](?)(stridable = unknown s2[70169]))) : _unknown[51] "assignop" "inline" "no return value for void"
  {
    if(70210 call _cond_test(70185 call !=(70178 call . r1[70163] c"boundedType")(70182 call . r2[70174] c"boundedType")))
    {
      (70208 call compilerError "type mismatch in assignment of ranges with different boundedType parameters")
    }
    if(70278 call _cond_test(70220 call &&(70217 call ! s1[70158]) s2[70169]))
    {
      (70241 call compilerError "type mismatch in assignment of ranges with different stridable parameters")
    }
    {
      if(70272 call _cond_test(70245 call && s1[70158] s2[70169]))
      {
        (70255 call =(70248 call . r1[70163] c"_stride")(70252 call . r2[70174] c"stride"))
      }
      {
        if(70267 call _cond_test s1[70158])
        {
          (70264 call =(70260 call . r1[70163] c"_stride") 1)
        }
      }
    }
    (70292 call =(70285 call . r1[70163] c"_low")(70289 call . r2[70174] c"_low"))
    (70303 call =(70296 call . r1[70163] c"_high")(70300 call . r2[70174] c"_high"))
    if(70333 call _cond_test s1[70158])
    {
      (70318 call =(70308 call . r1[70163] c"_alignment")(70317 call chpl__idxToInt(70313 call . r2[70174] c"alignment")))
      (70330 call =(70323 call . r1[70163] c"_aligned")(70327 call . r2[70174] c"aligned"))
    }
  }
  function +[70353](arg r[70350] :
  (70349 call range[64319](?) unknown e[70342] unknown b[70345] unknown s[70347]), arg offset[70356] :
  integral[199](?)) : _unknown[51] "inline"
  {
    const i[70366] "const"(70364 call _cast(70361 call . r[70350] c"intIdxType") offset[70356])
    (70369 'end of statement')
    unknown strType[70375] "type variable"(70374 call chpl__rangeStrideType e[70342])
    (70440 return(70378 'new'(70439 call range[64319](?) e[70342] b[70345] s[70347](70398 call(70387 call . r[70350] c"chpl_intToIdx")(70395 call +(70391 call . r[70350] c"_low") i[70366]))(70411 call(70400 call . r[70350] c"chpl_intToIdx")(70408 call +(70404 call . r[70350] c"_high") i[70366]))(70417 call _cast strType[70375](70413 call . r[70350] c"stride"))(70434 call(70420 call . r[70350] c"chpl_intToIdx")(70431 call +(70429 call chpl__idxToInt(70425 call . r[70350] c"alignment")) i[70366]))(70436 call . r[70350] c"aligned"))))
  }
  function +[70450](arg i[70447] :
  integral[199](?), arg r[70461] :
  (70460 call range[64319](?) unknown e[70453] unknown b[70456] unknown s[70458])) : _unknown[51] "inline"
  {
    (70468 return(70466 call + r[70461] i[70447]))
  }
  function -[70487](arg r[70484] :
  (70483 call range[64319](?) unknown e[70476] unknown b[70479] unknown s[70481]), arg i[70490] :
  integral[199](?)) : _unknown[51] "inline"
  {
    unknown strType[70497] "type variable"(70496 call chpl__rangeStrideType e[70476])
    (70561 return(70501 'new'(70560 call range[64319](?) e[70476] b[70479] s[70481](70519 call(70508 call . r[70484] c"chpl_intToIdx")(70516 call -(70512 call . r[70484] c"_low") i[70490]))(70532 call(70521 call . r[70484] c"chpl_intToIdx")(70529 call -(70525 call . r[70484] c"_high") i[70490]))(70538 call _cast strType[70497](70534 call . r[70484] c"stride"))(70555 call(70541 call . r[70484] c"chpl_intToIdx")(70552 call -(70550 call chpl__idxToInt(70546 call . r[70484] c"alignment")) i[70490]))(70557 call . r[70484] c"aligned"))))
  }
  function chpl_check_step_integral[70569](arg step[70567]:_any[178](?)) : _unknown[51] "inline" "no return value for void"
  {
    if(70604 call _cond_test(70576 call !(70575 call isIntegral(70573 'typeof' step[70567]))))
    {
      (70602 call compilerError "can't apply 'by' using step of a non-integral type "(70600 call _cast string[26](70598 'typeof' step[70567])))
    }
  }
  function chpl_need_to_check_step[70616](arg step[70614]:_any[178](?), arg strType[70618]:_any[178](?)) param : _unknown[51]
  {
    (70626 call compilerAssert(70624 call isInt strType[70618]))
    (70647 return(70645 call &&(70632 call !=(70630 'typeof' step[70614]) strType[70618])(70643 call >=(70638 call numBits(70636 'typeof' step[70614]))(70642 call numBits strType[70618]))))
  }
  function chpl_range_check_stride[70655](arg step[70653]:_any[178](?), arg idxType[70657]:_any[178](?)) : _unknown[51] "inline" "no return value for void"
  {
    (70662 call chpl_check_step_integral step[70653])
    unknown strType[70669] "type variable"(70668 call chpl__rangeStrideType idxType[70657])
    if(70730 call _cond_test(70681 call >(70676 call numBits(70674 'typeof' step[70653]))(70680 call numBits strType[70669])))
    {
      (70728 call compilerError "can't apply 'by' to a range with idxType "(70704 call _cast string[26] idxType[70657]) " using a step of type "(70726 call _cast string[26](70724 'typeof' step[70653])))
    }
    if(70825 call _cond_test 1)
    {
      if(70764 call _cond_test(70738 call == step[70653] 0))
      {
        (70762 call boundsCheckHalt module=[255] HaltWrappers[210085] "the step argument of the 'by' operator is zero")
        (357890 'referenced modules list' HaltWrappers[210085])
      }
      if(70820 call _cond_test(70786 call &&(70774 call chpl_need_to_check_step step[70653] strType[70669])(70784 call > step[70653](70782 call _cast(70781 'typeof' step[70653])(70779 call max strType[70669])))))
      {
        (70818 call boundsCheckHalt module=[255] HaltWrappers[210085](70815 call + "the step argument of the 'by' operator is too large and cannot be represented within the range's stride type "(70813 call _cast string[26] strType[70669])))
        (357896 'referenced modules list' HaltWrappers[210085])
      }
    }
  }
  function chpl_range_check_stride[70835](param arg step[70833]:_any[178](?), arg idxType[70837]:_any[178](?)) : _unknown[51] "inline" "no return value for void"
  {
    (70842 call chpl_check_step_integral step[70833])
    unknown strType[70849] "type variable"(70848 call chpl__rangeStrideType idxType[70837])
    if(70861 call _cond_test(70854 call == step[70833] 0))
    {
      (70859 call compilerError "the step argument of the 'by' operator is zero")
    }
    if(70895 call _cond_test(70882 call &&(70870 call chpl_need_to_check_step step[70833] strType[70849])(70880 call > step[70833](70878 call _cast(70877 'typeof' step[70833])(70875 call max strType[70849])))))
    {
      (70893 call compilerError(70890 call + "the step argument of the 'by' operator is too large and cannot be represented within the range's stride type "(70888 call _cast string[26] strType[70849])))
    }
  }
  function chpl_by_help[70916](arg r[70913] :
  (70912 call range[64319](?) unknown i[70905] unknown b[70908] unknown s[70910]), arg step[70918]:_any[178](?)) : _unknown[51]
  {
    const lw[70925] "const"(70922 call . r[70913] c"low") i[70905]
    const hh[70933] "const"(70930 call . r[70913] c"high") i[70905]
    const st[70955] "const"(70953 call *(70943 call . r[70913] c"stride")(70951 call _cast(70948 call . r[70913] c"strType") step[70918]))(70939 call . r[70913] c"strType")
    (70958 'end of statement')
    const tmp[71080] "const" "temp"(71077 IfExpr (70975 call(70971 call . r[70913] c"isAmbiguous")) then
    { scopeless(70999 IfExpr (70977 call . r[70913] c"stridable") then
      { scopeless
        (70986 call _build_tuple 0(70982 call . r[70913] c"alignment"))
      } else
      { scopeless
        (70997 call _build_tuple 0(70995 call(70990 call . r[70913] c"chpl_intToIdx") 0))
      } )
    } else
    { scopeless(71074 IfExpr (71012 call &&(71007 call(71003 call . r[70913] c"hasLowBound"))(71010 call > st[70955] 0)) then
      { scopeless
        (71020 call _build_tuple 1(71016 call . r[70913] c"alignedLow"))
      } else
      { scopeless(71071 IfExpr (71032 call &&(71027 call(71023 call . r[70913] c"hasHighBound"))(71030 call < st[70955] 0)) then
        { scopeless
          (71040 call _build_tuple 1(71036 call . r[70913] c"alignedHigh"))
        } else
        { scopeless(71068 IfExpr (71043 call . r[70913] c"stridable") then
          { scopeless
            (71055 call _build_tuple(71047 call . r[70913] c"aligned")(71051 call . r[70913] c"alignment"))
          } else
          { scopeless
            (71066 call _build_tuple 0(71064 call(71059 call . r[70913] c"chpl_intToIdx") 0))
          } )
        } )
      } )
    } )(70968 call _build_tuple bool[10] i[70905])
    (71087 call _check_tuple_var_decl tmp[71080] 2)
    const ald[70960] "const"(71081 call tmp[71080] 0)
    const alt[70962] "const"(71084 call tmp[71080] 1)
    (71092 'end of statement')
    (71105 return(71093 'new'(71104 call range[64319](?) i[70905] b[70908] 1 lw[70925] hh[70933] st[70955] alt[70962] ald[70960])))
  }
  function chpl_by[71113](arg r[71111]:_any[178](?), arg step[71115]:_any[178](?)) : _unknown[51] "inline" "no doc"
  {
    if(71144 call _cond_test(71121 call !(71120 call isRange r[71111])))
    {
      (71142 call compilerError "the first argument of the 'by' operator is not a range")
    }
    (71157 call chpl_range_check_stride step[71115](71154 call . r[71111] c"idxType"))
    (71164 return(71163 call chpl_by_help r[71111] step[71115]))
  }
  function chpl_by[71177](arg r[71174] :
  (71173 call range[64319](?) ?[260]), param arg step[71179]:_any[178](?)) : _unknown[51] "inline" "no doc"
  {
    (71188 call chpl_range_check_stride step[71179](71185 call . r[71174] c"idxType"))
    (71202 return(71201 call chpl_by_help r[71174](71199 call _cast(71196 call . r[71174] c"strType") step[71179])))
  }
  function chpl_align[71220](arg r[71217] :
  (71216 call range[64319](?) unknown i[71209] unknown b[71212] unknown s[71214]), arg algn[71223] :
  i[71209]) : _unknown[51] "inline" "no doc"
  {
    (71259 return(71226 'new'(71258 call range[64319](?) i[71209] b[71212] 1(71241 call(71233 call . r[71217] c"chpl_intToIdx")(71237 call . r[71217] c"_low"))(71251 call(71243 call . r[71217] c"chpl_intToIdx")(71247 call . r[71217] c"_high"))(71253 call . r[71217] c"stride") algn[71223] 1)))
  }
  function chpl_align[71278](arg r[71275] :
  (71274 call range[64319](?) unknown i[71267] unknown b[71270] unknown s[71272]), arg algn[71280]:_any[178](?)) : _unknown[51] "inline" "no doc"
  {
    (71327 call compilerError "can't align a range with idxType "(71303 call _cast string[26] i[71267]) " using a value of type "(71325 call _cast string[26](71323 'typeof' algn[71280])))
    (71331 return r[71275])
  }
  function range[64319](?).offset[71342](arg _mt[71347]:_MT[238], arg this[71344]:range[64319](?) :
  range[64319](?), in arg offset[71339] :
  integral[199](?)) : _unknown[51] "method"
  {
    unknown offs[71356](71355 call(71350 call . offset[71339] c"safeCast")(375126 call . this[71344] c"intIdxType"))
    (71359 'end of statement')
    if(71391 call _cond_test(71362 call !(375131 call . this[71344] c"stridable")))
    {
      (71383 call compilerWarning "invoking 'offset' on an unstrided range has no effect.")
      (71388 call = offs[71356] 0)
    }
    if(71427 call _cond_test(71401 call && 1(71399 call !(71398 call(375137 call . this[71344] c"hasFirst")))))
    {
      (71425 call boundsCheckHalt module=[255] HaltWrappers[210085] "invoking 'offset' on a range without the first index")
      (357928 'referenced modules list' HaltWrappers[210085])
    }
    (71453 return(71432 'new'(71452 call range[64319](?)(375143 call . this[71344] c"idxType")(375148 call . this[71344] c"boundedType")(375153 call . this[71344] c"stridable")(375157 call . this[71344] c"low")(375161 call . this[71344] c"high")(375165 call . this[71344] c"stride")(71450 call(375169 call . this[71344] c"chpl_intToIdx")(71447 call +(71443 call . this[71344] c"firstAsInt") offs[71356])) 1)))
  }
  function range[64319](?).this[71467](arg _mt[71472]:_MT[238], const arg this[71469]:range[64319](?) :
  range[64319](?), arg other[71464] :
  (71463 call range[64319](?) ?[260])) : _unknown[51] "method" "no doc"
  {
    unknown ambig[71475] 0
    (71478 'end of statement')
    if(71583 call _cond_test(71492 call ||(71485 call(71481 call . this[71469] c"isAmbiguous"))(71491 call(71487 call . other[71464] c"isAmbiguous"))))
    {
      unknown st1[71501](71500 call abs(71496 call . this[71469] c"stride"))
      (71504 'end of statement')
      unknown st2[71513](71512 call abs(71508 call . other[71464] c"stride"))
      (71516 'end of statement')
      unknown tmp[71527] "temp"(71526 call chpl__extendedEuclid st1[71501] st2[71513])
      (71534 call _check_tuple_var_decl tmp[71527] 2)
      unknown g[71517](71528 call tmp[71527] 0)
      unknown x[71519](71531 call tmp[71527] 1)
      (71539 'end of statement')
      if(71573 call _cond_test(71545 call && 1(71543 call > g[71517] 1)))
      {
        (71571 call boundsCheckHalt module=[255] HaltWrappers[210085] "Cannot slice ranges with ambiguous alignments unless their strides are relatively prime.")
        (357939 'referenced modules list' HaltWrappers[210085])
      }
      (71580 call = ambig[71475] 1)
    }
    function computeBoundedType[71591](arg r1[71589]:_any[178](?), arg r2[71593]:_any[178](?)) param : _unknown[51]
    {
      unknown low[71609] "param"(71607 call ||(71600 call(71596 call . r1[71589] c"hasLowBound"))(71606 call(71602 call . r2[71593] c"hasLowBound")))
      (71612 'end of statement')
      unknown high[71628] "param"(71626 call ||(71619 call(71615 call . r1[71589] c"hasHighBound"))(71625 call(71621 call . r2[71593] c"hasHighBound")))
      (71631 'end of statement')
      if(71674 call _cond_test(71634 call && low[71609] high[71628]))
      {
        (71640 return bounded[64208])
      }
      {
        if(71668 call _cond_test low[71609])
        {
          (71647 return boundedLow[64210])
        }
        {
          if(71662 call _cond_test high[71628])
          {
            (71654 return boundedHigh[64212])
          }
          {
            (71660 return boundedNone[64214])
          }
        }
      }
    }
    unknown lo1[71696](71693 IfExpr (71684 call(375184 call . this[71469] c"hasLowBound")) then
    { scopeless
      (71686 call . this[71469] c"_low")
    } else
    { scopeless
      (71690 call . other[71464] c"_low")
    } )
    (71699 'end of statement')
    unknown hi1[71714](71711 IfExpr (71702 call(375188 call . this[71469] c"hasHighBound")) then
    { scopeless
      (71704 call . this[71469] c"_high")
    } else
    { scopeless
      (71708 call . other[71464] c"_high")
    } )
    (71717 'end of statement')
    unknown st1[71725](71724 call abs(71720 call . this[71469] c"stride"))
    (71728 'end of statement')
    unknown lo2[71746](71743 IfExpr (71734 call(71730 call . other[71464] c"hasLowBound")) then
    { scopeless
      (71736 call . other[71464] c"_low")
    } else
    { scopeless
      (71740 call . this[71469] c"_low")
    } )
    (71749 'end of statement')
    unknown hi2[71767](71764 IfExpr (71755 call(71751 call . other[71464] c"hasHighBound")) then
    { scopeless
      (71757 call . other[71464] c"_high")
    } else
    { scopeless
      (71761 call . this[71469] c"_high")
    } )
    (71770 'end of statement')
    unknown st2[71778](71777 call abs(71773 call . other[71464] c"stride"))
    (71781 'end of statement')
    if(71801 call _cond_test(71785 call isUintType(375192 call . this[71469] c"intIdxType")))
    {
      if(71795 call _cond_test(71788 call < lo1[71696] 0))
      {
        (71792 call = lo1[71696] 0)
      }
    }
    unknown newStride[71810](71807 call . this[71469] c"stride")(375198 call . this[71469] c"strType")
    (71813 'end of statement')
    unknown lcm[71822](71821 call abs(71817 call . this[71469] c"stride"))(375202 call . this[71469] c"strType")
    (71825 'end of statement')
    unknown tmp[71843] "temp"(71841 call _build_tuple lcm[71822](71838 call _cast(375211 call . this[71469] c"strType") 0))(71833 call * 2(375206 call . this[71469] c"strType"))
    (71850 call _check_tuple_var_decl tmp[71843] 2)
    unknown g[71826](71844 call tmp[71843] 0)
    unknown x[71828](71847 call tmp[71843] 1)
    (71855 'end of statement')
    if(71958 call _cond_test(71878 call &&(71864 call !=(71857 call . this[71469] c"stride")(71861 call . other[71464] c"stride"))(71876 call !=(71867 call . this[71469] c"stride")(71874 call -(71871 call . other[71464] c"stride")))))
    {
      const tmp[71890] "const" "temp"(71889 call chpl__extendedEuclid st1[71725] st2[71778])
      (71897 call _check_tuple_var_decl tmp[71890] 2)
      const tg[71880] "const"(71891 call tmp[71890] 0)
      const tx[71882] "const"(71894 call tmp[71890] 1)
      (71902 'end of statement')
      (71926 call =(71907 call _build_tuple g[71826] x[71828])(71924 call _build_tuple(71915 call(71910 call . tg[71880] c"safeCast")(375219 call . this[71469] c"strType"))(71922 call(71917 call . tx[71882] c"safeCast")(375223 call . this[71469] c"strType"))))
      (71937 call = lcm[71822](71935 call *(71932 call / st1[71725] g[71826]) st2[71778]))
      (71955 call = newStride[71810](71952 IfExpr (71946 call >(71942 call . this[71469] c"stride") 0) then
      { scopeless
        lcm[71822]
      } else
      { scopeless
        (71950 call - lcm[71822])
      } ))
    }
    unknown emptyIntersection[71963] bool[10]
    (71966 'end of statement')
    function min[71973](arg x[71970] :
    int(64)[13], arg y[71976] :
    uint(64)[115]) : _unknown[51]
    {
      if(71990 call _cond_test(71984 call > y[71976](71983 call max int(64)[13])))
      {
        (71987 return x[71970])
      }
      (72003 return(72002 call min x[71970](72000 call _cast int(64)[13] y[71976])))
    }
    function min[72013](arg x[72010] :
    uint(64)[115], arg y[72016] :
    int(64)[13]) : _unknown[51]
    {
      if(72032 call _cond_test(72021 call < y[72016] 0))
      {
        (72025 call = emptyIntersection[71963] 1)
        (72030 return x[72010])
      }
      (72045 return(72044 call min x[72010](72042 call _cast uint(64)[115] y[72016])))
    }
    function max[72055](arg x[72052] :
    int(64)[13], arg y[72058] :
    uint(64)[115]) : _unknown[51]
    {
      if(72077 call _cond_test(72066 call > y[72058](72065 call max int(64)[13])))
      {
        (72070 call = emptyIntersection[71963] 1)
        (72075 return x[72052])
      }
      (72090 return(72089 call max x[72052](72087 call _cast int(64)[13] y[72058])))
    }
    function max[72100](arg x[72097] :
    uint(64)[115], arg y[72103] :
    int(64)[13]) : _unknown[51]
    {
      if(72114 call _cond_test(72108 call < y[72103] 0))
      {
        (72111 return x[72097])
      }
      (72127 return(72126 call max x[72097](72124 call _cast uint(64)[115] y[72103])))
    }
    (72133 call = emptyIntersection[71963] 0)
    unknown newlo[72144](72142 call _cast(375255 call . this[71469] c"intIdxType")(72140 call max lo1[71696] lo2[71746]))
    (72147 'end of statement')
    unknown newhi[72156](72154 call _cast(375261 call . this[71469] c"intIdxType")(72152 call min hi1[71714] hi2[71767]))
    (72159 'end of statement')
    if(72172 call _cond_test emptyIntersection[71963])
    {
      (72163 call = newlo[72144] 1)
      (72169 call = newhi[72156] 0)
    }
    unknown result[72224](72176 'new'(72223 call range[64319](?)(375270 call . this[71469] c"idxType")(72184 call computeBoundedType this[71469] other[71464])(72193 call |(72186 call . this[71469] c"stridable")(72190 call . other[71464] c"stridable"))(72198 call(375276 call . this[71469] c"chpl_intToIdx") newlo[72144])(72202 call(375281 call . this[71469] c"chpl_intToIdx") newhi[72156]) newStride[71810](72207 call(375287 call . this[71469] c"chpl_intToIdx") 0)(72221 call &&(72209 call ! ambig[71475])(72219 call ||(72212 call . this[71469] c"aligned")(72216 call . other[71464] c"aligned")))))
    (72227 'end of statement')
    if(72433 call _cond_test(72229 call . result[72224] c"stridable"))
    {
      unknown al1[72248](72246 call _cast int(64)[13](72243 call %(72238 call chpl__idxToInt(72234 call . this[71469] c"alignment"))(72241 call _cast(375293 call . this[71469] c"intIdxType") st1[71725])))
      (72251 'end of statement')
      unknown al2[72272](72270 call _cast int(64)[13](72267 call %(72259 call chpl__idxToInt(72255 call . other[71464] c"alignment"))(72265 call _cast(72262 call . other[71464] c"intIdxType") st2[71778])))
      (72275 'end of statement')
      if(72429 call _cond_test(72284 call !=(72281 call %(72278 call - al2[72272] al1[72248]) g[71826]) 0))
      {
        if(72321 call _cond_test(72293 call && 1(72291 call !(72290 call isBoundedRange result[72224]))))
        {
          (72319 call boundsCheckHalt module=[255] HaltWrappers[210085] "could not represent range slice - it needs to be empty, but the slice type is not bounded")
          (357982 'referenced modules list' HaltWrappers[210085])
        }
        (72335 call =(72328 call . result[72224] c"_low")(72333 call _cast(375303 call . this[71469] c"intIdxType") 1))
        (72346 call =(72339 call . result[72224] c"_high")(72344 call _cast(375307 call . this[71469] c"intIdxType") 0))
        (72371 call =(72350 call . result[72224] c"_alignment")(72368 IfExpr (72358 call >(72354 call . this[71469] c"stride") 0) then
        { scopeless
          (72362 call _cast(375311 call . this[71469] c"intIdxType") 1)
        } else
        { scopeless
          (72366 call _cast(375315 call . this[71469] c"intIdxType") 0)
        } ))
      }
      {
        unknown offset[72381](72379 call *(72376 call - al2[72272] al1[72248]) x[71828])
        (72384 'end of statement')
        if(72395 call _cond_test(72388 call < offset[72381] 0))
        {
          (72392 call += offset[72381] lcm[71822])
        }
        (72426 call =(72401 call . result[72224] c"_alignment")(72424 call +(72406 call _cast(375326 call . this[71469] c"intIdxType") al1[72248])(72422 call /(72416 call *(72410 call _cast(375331 call . this[71469] c"intIdxType") offset[72381])(72414 call _cast(375336 call . this[71469] c"intIdxType") st1[71725]))(72420 call _cast(375341 call . this[71469] c"intIdxType") g[71826]))))
      }
    }
    (72438 return result[72224])
  }
  function chpl_count_help[72451](arg r[72448] :
  (72447 call range[64319](?) ?[260]), arg i[72453]:_any[178](?)) : _unknown[51] "no return value for void"
  {
    (72486 call compilerError "count operator is not defined for unbounded ranges")
  }
  where {
    (72463 call ==(72456 call . r[72448] c"boundedType") boundedNone[64214])
  }
  function chpl_count_help[72496](arg r[72494]:_any[178](?), arg count[72499] :
  integral[199](?)) : _unknown[51]
  {
    if(72534 call _cond_test(72509 call && 1(72508 call(72504 call . r[72494] c"isAmbiguous"))))
    {
      (72532 call boundsCheckHalt "count -- Cannot count off elements from a range which is ambiguously aligned.")
    }
    unknown resultType[72544] "type variable"(72541 call . r[72494] c"intIdxType")
    unknown strType[72551] "type variable"(72550 call chpl__rangeStrideType resultType[72544])
    function absSameType[72558](arg str[72556]:_any[178](?)) : _unknown[51]
    {
      if(72589 call _cond_test(72565 call <(72561 call . r[72494] c"stride") 0))
      {
        (72576 return(72574 call _cast resultType[72544](72571 call -(72568 call . r[72494] c"stride"))))
      }
      {
        (72586 return(72584 call _cast resultType[72544](72580 call . r[72494] c"stride")))
      }
    }
    if(72798 call _cond_test(72598 call == count[72499] 0))
    {
      if(72792 call _cond_test(72605 call(72601 call . r[72494] c"hasLowBound")))
      {
        (72680 return(72606 'new'(72679 call range[64319](?)(idxType =(72609 call . r[72494] c"idxType"))(boundedType = bounded[64208])(stridable =(72620 call . r[72494] c"stridable"))(_low =(72634 call chpl__intToIdx(72626 call . r[72494] c"idxType")(72631 call . r[72494] c"_low")))(_high =(72655 call chpl__intToIdx(72638 call . r[72494] c"idxType")(72653 call -(72643 call . r[72494] c"_low")(72652 call absSameType(72648 call . r[72494] c"stride")))))(_stride =(72658 call . r[72494] c"stride"))(_alignment =(72672 call chpl__intToIdx(72664 call . r[72494] c"idxType")(72669 call . r[72494] c"_alignment")))(_aligned =(72675 call . r[72494] c"aligned")))))
      }
      {
        if(72788 call _cond_test(72688 call(72684 call . r[72494] c"hasHighBound")))
        {
          (72763 return(72689 'new'(72762 call range[64319](?)(idxType =(72692 call . r[72494] c"idxType"))(boundedType = bounded[64208])(stridable =(72703 call . r[72494] c"stridable"))(_low =(72726 call chpl__intToIdx(72709 call . r[72494] c"idxType")(72724 call +(72714 call . r[72494] c"_high")(72723 call absSameType(72719 call . r[72494] c"stride")))))(_high =(72738 call chpl__intToIdx(72730 call . r[72494] c"idxType")(72735 call . r[72494] c"_high")))(_stride =(72741 call . r[72494] c"stride"))(_alignment =(72755 call chpl__intToIdx(72747 call . r[72494] c"idxType")(72752 call . r[72494] c"_alignment")))(_aligned =(72758 call . r[72494] c"aligned")))))
        }
        {
          (72785 call halt "Internal error: Unexpected case in chpl_count_help")
        }
      }
    }
    if(72840 call _cond_test(72817 call &&(72811 call && 1(72809 call !(72808 call(72804 call . r[72494] c"hasFirst"))))(72815 call > count[72499] 0)))
    {
      (72838 call boundsCheckHalt "With a positive count, the range must have a first index.")
    }
    if(72885 call _cond_test(72862 call &&(72856 call && 1(72854 call !(72853 call(72849 call . r[72494] c"hasLast"))))(72860 call < count[72499] 0)))
    {
      (72883 call boundsCheckHalt "With a negative count, the range must have a last index.")
    }
    if(72984 call _cond_test(72932 call &&(72901 call && 1(72899 call ==(72892 call . r[72494] c"boundedType") bounded[64208]))(72930 call >(72918 call _cast(72917 call uint(64)[115] 64)(72913 call abs(72910 call _cast(72909 call chpl__maxIntTypeSameSign(72907 'typeof' count[72499])) count[72499])))(72928 call _cast(72927 call uint(64)[115] 64)(72921 call . r[72494] c"size")))))
    {
      (72981 call boundsCheckHalt(72978 call +(72959 call + "bounded range is too small to access "(72957 call _cast string[26](72955 call abs count[72499]))) " elements"))
    }
    function chpl__computeTypeForCountMath[72992](arg t1[72990]:_any[178](?), arg t2[72994]:_any[178](?)) type : _unknown[51]
    {
      if(73052 call _cond_test(72998 call == t1[72990] t2[72994]))
      {
        (73004 return(73003 call chpl__idxTypeToIntIdxType t1[72990]))
      }
      {
        if(73048 call _cond_test(73021 call ||(73012 call ==(73010 call numBits t1[72990]) 64)(73019 call ==(73017 call numBits t2[72994]) 64)))
        {
          (73027 return(73026 call int(64)[13] 64))
        }
        {
          unknown x1[73031] t1[72990]
          (73034 'end of statement')
          unknown x2[73037] t2[72994]
          (73040 'end of statement')
          (73046 return(73045 'typeof'(73043 call + x1[73031] x2[73037])))
        }
      }
    }
    unknown computeType[73066] "type variable"(73065 call chpl__computeTypeForCountMath resultType[72544](73064 'typeof' count[72499]))
    unknown signedComputeType[73073] "type variable"(73072 call chpl__signedType computeType[73066])
    unknown diff[73089](73087 call *(73078 call _cast signedComputeType[73073] count[72499])(73085 call _cast signedComputeType[73073](73081 call . r[72494] c"stride")))
    (73092 'end of statement')
    unknown lo[73123](73120 IfExpr (73096 call > diff[73089] 0) then
    { scopeless
      (73099 call . r[72494] c"_low")
    } else
    { scopeless
      (73119 call chpl__add(73108 call _cast computeType[73066](73104 call . r[72494] c"_high"))(73116 call _cast computeType[73066](73113 call + diff[73089] 1)) resultType[72544])
    } ) resultType[72544]
    (73126 'end of statement')
    unknown hi[73157](73154 IfExpr (73130 call < diff[73089] 0) then
    { scopeless
      (73133 call . r[72494] c"_high")
    } else
    { scopeless
      (73153 call chpl__add(73142 call _cast computeType[73066](73138 call . r[72494] c"_low"))(73150 call -(73147 call _cast computeType[73066] diff[73089]) 1) resultType[72544])
    } ) resultType[72544]
    (73160 'end of statement')
    if(73222 call _cond_test(73162 call . r[72494] c"stridable"))
    {
      if(73188 call _cond_test(73178 call &&(73170 call(73166 call . r[72494] c"hasLowBound"))(73176 call < lo[73123](73173 call . r[72494] c"_low"))))
      {
        (73185 call = lo[73123](73182 call . r[72494] c"_low"))
      }
      if(73217 call _cond_test(73207 call &&(73199 call(73195 call . r[72494] c"hasHighBound"))(73205 call > hi[73157](73202 call . r[72494] c"_high"))))
      {
        (73214 call = hi[73157](73211 call . r[72494] c"_high"))
      }
    }
    (73303 return(73226 'new'(73302 call range[64319](?)(idxType =(73229 call . r[72494] c"idxType"))(boundedType = bounded[64208])(stridable =(73240 call . r[72494] c"stridable"))(_low =(73250 call(73245 call . r[72494] c"chpl_intToIdx") lo[73123]))(_high =(73258 call(73253 call . r[72494] c"chpl_intToIdx") hi[73157]))(_stride =(73272 IfExpr (73261 call . r[72494] c"stridable") then
    { scopeless
      (73269 call _cast strType[72551](73265 call . r[72494] c"stride"))
    } else
    { scopeless
      none[57]
    } ))(_alignment =(73285 IfExpr (73277 call . r[72494] c"stridable") then
    { scopeless
      (73281 call . r[72494] c"alignment")
    } else
    { scopeless
      none[57]
    } ))(_aligned =(73298 IfExpr (73290 call . r[72494] c"stridable") then
    { scopeless
      (73294 call . r[72494] c"aligned")
    } else
    { scopeless
      none[57]
    } )))))
  }
  function #[73317](arg r[73314] :
  (73313 call range[64319](?) unknown i[73310]), arg count[73323] :
  (73322 call chpl__rangeStrideType i[73310])) : _unknown[51]
  {
    (73331 return(73330 call chpl_count_help r[73314] count[73323]))
  }
  function #[73346](arg r[73343] :
  (73342 call range[64319](?) unknown i[73339]), arg count[73352] :
  (73351 call chpl__rangeUnsignedType i[73339])) : _unknown[51]
  {
    (73360 return(73359 call chpl_count_help r[73343] count[73352]))
  }
  function #[73375](arg r[73372] :
  (73371 call range[64319](?) unknown i[73368]), arg count[73377]:_any[178](?)) : _unknown[51]
  {
    (73424 call compilerError "can't apply '#' to a range with idxType "(73400 call _cast string[26] i[73368]) " using a count of type "(73422 call _cast string[26](73420 'typeof' count[73377])))
    (73428 return r[73372])
  }
  function chpl_checkIfRangeIterWillOverflow[73436](arg idxType[73434]:_any[178](?), arg low[73438]:_any[178](?), arg high[73440]:_any[178](?), arg stride[73442]:_any[178](?), arg first[73445] =
  low[73438], arg last[73449] =
  high[73440], arg shouldHalt[73453] =
  1) : _unknown[51]
  {
    if(73464 call _cond_test(73458 call > low[73438] high[73440]))
    {
      (73461 return 0)
    }
    unknown willOverFlow[73470] 0
    (73473 'end of statement')
    if(73657 call _cond_test(73477 call isIntType idxType[73434]))
    {
      if(73544 call _cond_test(73486 call &&(73480 call > last[73449] 0)(73484 call > stride[73442] 0)))
      {
        if(73504 call _cond_test(73496 call > stride[73442](73494 call -(73492 call max idxType[73434]) last[73449])))
        {
          (73500 call = willOverFlow[73470] 1)
        }
      }
      {
        if(73540 call _cond_test(73517 call &&(73511 call < last[73449] 0)(73515 call < stride[73442] 0)))
        {
          if(73535 call _cond_test(73527 call < stride[73442](73525 call -(73523 call min idxType[73434]) last[73449])))
          {
            (73531 call = willOverFlow[73470] 1)
          }
        }
      }
    }
    {
      if(73653 call _cond_test(73553 call isUintType idxType[73434]))
      {
        if(73608 call _cond_test(73556 call > stride[73442] 0))
        {
          if(73574 call _cond_test(73566 call <(73563 call + last[73449](73561 call _cast idxType[73434] stride[73442])) last[73449]))
          {
            (73570 call = willOverFlow[73470] 1)
          }
        }
        {
          if(73604 call _cond_test(73581 call < stride[73442] 0))
          {
            if(73599 call _cond_test(73591 call >(73588 call + last[73449](73586 call _cast idxType[73434] stride[73442])) last[73449]))
            {
              (73595 call = willOverFlow[73470] 1)
            }
          }
        }
      }
      {
        (73650 call compilerError "Iterator overflow checking is only supported " "for integral types")
      }
    }
    if(73691 call _cond_test(73664 call && willOverFlow[73470] shouldHalt[73453]))
    {
      (73688 call boundsCheckHalt module=[255] HaltWrappers[210085] "Iteration over a bounded range may be incorrect due to overflow.")
      (358054 'referenced modules list' HaltWrappers[210085])
    }
    (73696 return willOverFlow[73470])
  }
  function range[64319](?).checkIfIterWillOverflow[73707](arg _mt[73712]:_MT[238], arg this[73709]:range[64319](?) :
  range[64319](?), arg shouldHalt[73704] =
  1) : _unknown[51] "method" "no doc"
  {
    (73742 return(73741 call chpl_checkIfRangeIterWillOverflow(73716 call . this[73709] c"intIdxType")(73721 call . this[73709] c"_low")(73725 call . this[73709] c"_high")(73729 call . this[73709] c"stride")(73733 call . this[73709] c"firstAsInt")(73737 call . this[73709] c"lastAsInt") shouldHalt[73704]))
  }
  function chpl_direct_range_iter[73757](arg low[73754] :
  (73753 call int(64)[13] unknown w[73750]), arg high[73763] :
  (73762 call int(64)[13] w[73750]), arg stride[73770] :
  (73769 call int(64)[13] w[73750])) : _unknown[51] "iterator fn" "no return value for void"
  {
    const r[73780] "const"(73778 call chpl_by(73775 call chpl_build_bounded_range low[73754] high[73763]) stride[73770])
    (73783 'end of statement')
    {
      unknown _indexOfInterest[73790] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[73791] "expr temp" "temp"
      (73800 'move' _iterator[73791](73798 call _getIterator r[73780]))
      Defer
      {
        {
          (73816 call _freeIterator _iterator[73791])
        }
      }
      { scopeless type
        (73805 'move' _indexOfInterest[73790](73802 call iteratorIndex _iterator[73791]))
      }
      ForLoop[73792]
      {
        unknown i[73809] "index var" "insert auto destroy"
        (73811 'move' i[73809] _indexOfInterest[73790])
        (73788 yield i[73809])
        label _continueLabel[73795]
        _indexOfInterest[73790]
        _iterator[73791]
      }
      label _breakLabel[73796]
    }
  }
  function chpl_direct_range_iter[73835](arg low[73832] :
  (73831 call uint(64)[115] unknown w[73828]), arg high[73841] :
  (73840 call uint(64)[115] w[73828]), arg stride[73848] :
  (73847 call int(64)[13] w[73828])) : _unknown[51] "iterator fn" "no return value for void"
  {
    const r[73858] "const"(73856 call chpl_by(73853 call chpl_build_bounded_range low[73832] high[73841]) stride[73848])
    (73861 'end of statement')
    {
      unknown _indexOfInterest[73868] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[73869] "expr temp" "temp"
      (73878 'move' _iterator[73869](73876 call _getIterator r[73858]))
      Defer
      {
        {
          (73894 call _freeIterator _iterator[73869])
        }
      }
      { scopeless type
        (73883 'move' _indexOfInterest[73868](73880 call iteratorIndex _iterator[73869]))
      }
      ForLoop[73870]
      {
        unknown i[73887] "index var" "insert auto destroy"
        (73889 'move' i[73887] _indexOfInterest[73868])
        (73866 yield i[73887])
        label _continueLabel[73873]
        _indexOfInterest[73868]
        _iterator[73869]
      }
      label _breakLabel[73874]
    }
  }
  function chpl_direct_range_iter[73909](arg low[73906] :
  enum[187](?), arg high[73912] :
  enum[187](?), arg stride[73916] :
  integral[199](?)) : _unknown[51] "iterator fn" "no return value for void"
  {
    const r[73926] "const"(73924 call chpl_by(73921 call chpl_build_bounded_range low[73906] high[73912]) stride[73916])
    (73929 'end of statement')
    {
      unknown _indexOfInterest[73936] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[73937] "expr temp" "temp"
      (73946 'move' _iterator[73937](73944 call _getIterator r[73926]))
      Defer
      {
        {
          (73962 call _freeIterator _iterator[73937])
        }
      }
      { scopeless type
        (73951 'move' _indexOfInterest[73936](73948 call iteratorIndex _iterator[73937]))
      }
      ForLoop[73938]
      {
        unknown i[73955] "index var" "insert auto destroy"
        (73957 'move' i[73955] _indexOfInterest[73936])
        (73934 yield i[73955])
        label _continueLabel[73941]
        _indexOfInterest[73936]
        _iterator[73937]
      }
      label _breakLabel[73942]
    }
  }
  function chpl_direct_range_iter[73977](arg low[73974] :
  bool[10], arg high[73980] :
  bool[10], arg stride[73984] :
  integral[199](?)) : _unknown[51] "iterator fn" "no return value for void"
  {
    const r[73994] "const"(73992 call chpl_by(73989 call chpl_build_bounded_range low[73974] high[73980]) stride[73984])
    (73997 'end of statement')
    {
      unknown _indexOfInterest[74004] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74005] "expr temp" "temp"
      (74014 'move' _iterator[74005](74012 call _getIterator r[73994]))
      Defer
      {
        {
          (74030 call _freeIterator _iterator[74005])
        }
      }
      { scopeless type
        (74019 'move' _indexOfInterest[74004](74016 call iteratorIndex _iterator[74005]))
      }
      ForLoop[74006]
      {
        unknown i[74023] "index var" "insert auto destroy"
        (74025 'move' i[74023] _indexOfInterest[74004])
        (74002 yield i[74023])
        label _continueLabel[74009]
        _indexOfInterest[74004]
        _iterator[74005]
      }
      label _breakLabel[74010]
    }
  }
  function chpl_direct_range_iter[74049](arg low[74046] :
  (74045 call int(64)[13] unknown w[74042]), arg high[74055] :
  (74054 call int(64)[13] w[74042]), param arg stride[74062] :
  (74061 call int(64)[13] w[74042])) : _unknown[51] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[74075] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74076] "expr temp" "temp"
      (74085 'move' _iterator[74076](74083 call _getIterator(74071 call chpl_direct_param_stride_range_iter low[74046] high[74055] stride[74062])))
      Defer
      {
        {
          (74102 call _freeIterator _iterator[74076])
        }
      }
      { scopeless type
        (74091 'move' _indexOfInterest[74075](74088 call iteratorIndex _iterator[74076]))
      }
      ForLoop[74077]
      {
        unknown i[74095] "index var" "insert auto destroy"
        (74097 'move' i[74095] _indexOfInterest[74075])
        (74073 yield i[74095])
        label _continueLabel[74080]
        _indexOfInterest[74075]
        _iterator[74076]
      }
      label _breakLabel[74081]
    }
  }
  function chpl_direct_range_iter[74122](arg low[74119] :
  (74118 call uint(64)[115] unknown w[74115]), arg high[74128] :
  (74127 call uint(64)[115] w[74115]), param arg stride[74135] :
  (74134 call int(64)[13] w[74115])) : _unknown[51] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[74148] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74149] "expr temp" "temp"
      (74158 'move' _iterator[74149](74156 call _getIterator(74144 call chpl_direct_param_stride_range_iter low[74119] high[74128] stride[74135])))
      Defer
      {
        {
          (74175 call _freeIterator _iterator[74149])
        }
      }
      { scopeless type
        (74164 'move' _indexOfInterest[74148](74161 call iteratorIndex _iterator[74149]))
      }
      ForLoop[74150]
      {
        unknown i[74168] "index var" "insert auto destroy"
        (74170 'move' i[74168] _indexOfInterest[74148])
        (74146 yield i[74168])
        label _continueLabel[74153]
        _indexOfInterest[74148]
        _iterator[74149]
      }
      label _breakLabel[74154]
    }
  }
  function chpl_direct_range_iter[74191](arg low[74188] :
  enum[187](?), arg high[74194] :
  enum[187](?), param arg stride[74198] :
  integral[199](?)) : _unknown[51] "iterator fn" "no return value for void"
  {
    if(74302 call _cond_test(74203 call == stride[74198] 1))
    {
      const r[74209] "const"(74207 call chpl_build_bounded_range low[74188] high[74194])
      (74212 'end of statement')
      {
        unknown _indexOfInterest[74219] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[74220] "expr temp" "temp"
        (74229 'move' _iterator[74220](74227 call _getIterator r[74209]))
        Defer
        {
          {
            (74245 call _freeIterator _iterator[74220])
          }
        }
        { scopeless type
          (74234 'move' _indexOfInterest[74219](74231 call iteratorIndex _iterator[74220]))
        }
        ForLoop[74221]
        {
          unknown i[74238] "index var" "insert auto destroy"
          (74240 'move' i[74238] _indexOfInterest[74219])
          (74217 yield i[74238])
          label _continueLabel[74224]
          _indexOfInterest[74219]
          _iterator[74220]
        }
        label _breakLabel[74225]
      }
    }
    {
      const r[74259] "const"(74257 call chpl_by(74254 call chpl_build_bounded_range low[74188] high[74194]) stride[74198])
      (74262 'end of statement')
      {
        unknown _indexOfInterest[74269] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[74270] "expr temp" "temp"
        (74279 'move' _iterator[74270](74277 call _getIterator r[74259]))
        Defer
        {
          {
            (74295 call _freeIterator _iterator[74270])
          }
        }
        { scopeless type
          (74284 'move' _indexOfInterest[74269](74281 call iteratorIndex _iterator[74270]))
        }
        ForLoop[74271]
        {
          unknown i[74288] "index var" "insert auto destroy"
          (74290 'move' i[74288] _indexOfInterest[74269])
          (74267 yield i[74288])
          label _continueLabel[74274]
          _indexOfInterest[74269]
          _iterator[74270]
        }
        label _breakLabel[74275]
      }
    }
  }
  function chpl_direct_range_iter[74315](arg low[74312] :
  bool[10], arg high[74318] :
  bool[10], param arg stride[74322] :
  integral[199](?)) : _unknown[51] "iterator fn" "no return value for void"
  {
    if(74426 call _cond_test(74327 call == stride[74322] 1))
    {
      const r[74333] "const"(74331 call chpl_build_bounded_range low[74312] high[74318])
      (74336 'end of statement')
      {
        unknown _indexOfInterest[74343] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[74344] "expr temp" "temp"
        (74353 'move' _iterator[74344](74351 call _getIterator r[74333]))
        Defer
        {
          {
            (74369 call _freeIterator _iterator[74344])
          }
        }
        { scopeless type
          (74358 'move' _indexOfInterest[74343](74355 call iteratorIndex _iterator[74344]))
        }
        ForLoop[74345]
        {
          unknown i[74362] "index var" "insert auto destroy"
          (74364 'move' i[74362] _indexOfInterest[74343])
          (74341 yield i[74362])
          label _continueLabel[74348]
          _indexOfInterest[74343]
          _iterator[74344]
        }
        label _breakLabel[74349]
      }
    }
    {
      const r[74383] "const"(74381 call chpl_by(74378 call chpl_build_bounded_range low[74312] high[74318]) stride[74322])
      (74386 'end of statement')
      {
        unknown _indexOfInterest[74393] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[74394] "expr temp" "temp"
        (74403 'move' _iterator[74394](74401 call _getIterator r[74383]))
        Defer
        {
          {
            (74419 call _freeIterator _iterator[74394])
          }
        }
        { scopeless type
          (74408 'move' _indexOfInterest[74393](74405 call iteratorIndex _iterator[74394]))
        }
        ForLoop[74395]
        {
          unknown i[74412] "index var" "insert auto destroy"
          (74414 'move' i[74412] _indexOfInterest[74393])
          (74391 yield i[74412])
          label _continueLabel[74398]
          _indexOfInterest[74393]
          _iterator[74394]
        }
        label _breakLabel[74399]
      }
    }
  }
  function chpl_direct_range_iter[74443](arg low[74440] :
  (74439 call int(64)[13] unknown w[74436]), arg high[74449] :
  (74448 call int(64)[13] w[74436]), arg stride[74456] :
  (74455 call uint(64)[115] w[74436])) : _unknown[51] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[74469] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74470] "expr temp" "temp"
      (74479 'move' _iterator[74470](74477 call _getIterator(74465 call chpl_direct_pos_stride_range_iter low[74440] high[74449] stride[74456])))
      Defer
      {
        {
          (74496 call _freeIterator _iterator[74470])
        }
      }
      { scopeless type
        (74485 'move' _indexOfInterest[74469](74482 call iteratorIndex _iterator[74470]))
      }
      ForLoop[74471]
      {
        unknown i[74489] "index var" "insert auto destroy"
        (74491 'move' i[74489] _indexOfInterest[74469])
        (74467 yield i[74489])
        label _continueLabel[74474]
        _indexOfInterest[74469]
        _iterator[74470]
      }
      label _breakLabel[74475]
    }
  }
  function chpl_direct_range_iter[74516](arg low[74513] :
  (74512 call uint(64)[115] unknown w[74509]), arg high[74522] :
  (74521 call uint(64)[115] w[74509]), arg stride[74529] :
  (74528 call uint(64)[115] w[74509])) : _unknown[51] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[74542] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74543] "expr temp" "temp"
      (74552 'move' _iterator[74543](74550 call _getIterator(74538 call chpl_direct_pos_stride_range_iter low[74513] high[74522] stride[74529])))
      Defer
      {
        {
          (74569 call _freeIterator _iterator[74543])
        }
      }
      { scopeless type
        (74558 'move' _indexOfInterest[74542](74555 call iteratorIndex _iterator[74543]))
      }
      ForLoop[74544]
      {
        unknown i[74562] "index var" "insert auto destroy"
        (74564 'move' i[74562] _indexOfInterest[74542])
        (74540 yield i[74562])
        label _continueLabel[74547]
        _indexOfInterest[74542]
        _iterator[74543]
      }
      label _breakLabel[74548]
    }
  }
  function chpl_direct_range_iter[74589](arg low[74586] :
  (74585 call int(64)[13] unknown w[74582]), arg high[74595] :
  (74594 call int(64)[13] w[74582]), arg stride[74598]:_any[178](?)) : _unknown[51] "iterator fn" "no return value for void"
  {
    (74616 call compilerError "can't apply 'by' to a range with idxType "(74608 call _cast string[26](74606 call int(64)[13] w[74582])) " using a step of type "(74614 call _cast string[26](74612 'typeof' stride[74598])))
  }
  function chpl_direct_range_iter[74631](arg low[74628] :
  (74627 call uint(64)[115] unknown w[74624]), arg high[74637] :
  (74636 call uint(64)[115] w[74624]), arg stride[74640]:_any[178](?)) : _unknown[51] "iterator fn" "no return value for void"
  {
    (74658 call compilerError "can't apply 'by' to a range with idxType "(74650 call _cast string[26](74648 call uint(64)[115] w[74624])) " using a step of type "(74656 call _cast string[26](74654 'typeof' stride[74640])))
  }
  function chpl_direct_range_iter[74667](arg low[74665]:_any[178](?), arg high[74669]:_any[178](?), arg stride[74671]:_any[178](?)) : _unknown[51] "iterator fn" "no return value for void"
  {
    (74676 call compilerError "Bounds of 'low..high' must be integers of compatible types.")
  }
  function chpl_direct_counted_range_iter[74691](arg low[74688] :
  (74687 call int(64)[13] unknown w[74684]), arg count[74697] :
  (74696 call int(64)[13] w[74684])) : _unknown[51] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[74709] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74710] "expr temp" "temp"
      (74719 'move' _iterator[74710](74717 call _getIterator(74705 call chpl_direct_counted_range_iter_helper low[74688] count[74697])))
      Defer
      {
        {
          (74736 call _freeIterator _iterator[74710])
        }
      }
      { scopeless type
        (74725 'move' _indexOfInterest[74709](74722 call iteratorIndex _iterator[74710]))
      }
      ForLoop[74711]
      {
        unknown i[74729] "index var" "insert auto destroy"
        (74731 'move' i[74729] _indexOfInterest[74709])
        (74707 yield i[74729])
        label _continueLabel[74714]
        _indexOfInterest[74709]
        _iterator[74710]
      }
      label _breakLabel[74715]
    }
  }
  function chpl_direct_counted_range_iter[74756](arg low[74753] :
  (74752 call int(64)[13] unknown w[74749]), arg count[74762] :
  (74761 call uint(64)[115] w[74749])) : _unknown[51] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[74774] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74775] "expr temp" "temp"
      (74784 'move' _iterator[74775](74782 call _getIterator(74770 call chpl_direct_counted_range_iter_helper low[74753] count[74762])))
      Defer
      {
        {
          (74801 call _freeIterator _iterator[74775])
        }
      }
      { scopeless type
        (74790 'move' _indexOfInterest[74774](74787 call iteratorIndex _iterator[74775]))
      }
      ForLoop[74776]
      {
        unknown i[74794] "index var" "insert auto destroy"
        (74796 'move' i[74794] _indexOfInterest[74774])
        (74772 yield i[74794])
        label _continueLabel[74779]
        _indexOfInterest[74774]
        _iterator[74775]
      }
      label _breakLabel[74780]
    }
  }
  function chpl_direct_counted_range_iter[74821](arg low[74818] :
  (74817 call uint(64)[115] unknown w[74814]), arg count[74827] :
  (74826 call int(64)[13] w[74814])) : _unknown[51] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[74839] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74840] "expr temp" "temp"
      (74849 'move' _iterator[74840](74847 call _getIterator(74835 call chpl_direct_counted_range_iter_helper low[74818] count[74827])))
      Defer
      {
        {
          (74866 call _freeIterator _iterator[74840])
        }
      }
      { scopeless type
        (74855 'move' _indexOfInterest[74839](74852 call iteratorIndex _iterator[74840]))
      }
      ForLoop[74841]
      {
        unknown i[74859] "index var" "insert auto destroy"
        (74861 'move' i[74859] _indexOfInterest[74839])
        (74837 yield i[74859])
        label _continueLabel[74844]
        _indexOfInterest[74839]
        _iterator[74840]
      }
      label _breakLabel[74845]
    }
  }
  function chpl_direct_counted_range_iter[74886](arg low[74883] :
  (74882 call uint(64)[115] unknown w[74879]), arg count[74892] :
  (74891 call uint(64)[115] w[74879])) : _unknown[51] "iterator fn" "no return value for void"
  {
    {
      unknown _indexOfInterest[74904] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74905] "expr temp" "temp"
      (74914 'move' _iterator[74905](74912 call _getIterator(74900 call chpl_direct_counted_range_iter_helper low[74883] count[74892])))
      Defer
      {
        {
          (74931 call _freeIterator _iterator[74905])
        }
      }
      { scopeless type
        (74920 'move' _indexOfInterest[74904](74917 call iteratorIndex _iterator[74905]))
      }
      ForLoop[74906]
      {
        unknown i[74924] "index var" "insert auto destroy"
        (74926 'move' i[74924] _indexOfInterest[74904])
        (74902 yield i[74924])
        label _continueLabel[74909]
        _indexOfInterest[74904]
        _iterator[74905]
      }
      label _breakLabel[74910]
    }
  }
  function chpl_direct_counted_range_iter[74947](arg low[74944] :
  enum[187](?), arg count[74954] :
  (74953 call int(64)[13] unknown w[74950])) : _unknown[51] "iterator fn" "no return value for void"
  {
    const r[74960] "const"(74958 call chpl_build_low_bounded_range low[74944])
    (74963 'end of statement')
    {
      unknown _indexOfInterest[74973] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[74974] "expr temp" "temp"
      (74983 'move' _iterator[74974](74981 call _getIterator(74968 call # r[74960] count[74954])))
      Defer
      {
        {
          (75001 call _freeIterator _iterator[74974])
        }
      }
      { scopeless type
        (74990 'move' _indexOfInterest[74973](74987 call iteratorIndex _iterator[74974]))
      }
      ForLoop[74975]
      {
        unknown i[74994] "index var" "insert auto destroy"
        (74996 'move' i[74994] _indexOfInterest[74973])
        (74971 yield i[74994])
        label _continueLabel[74978]
        _indexOfInterest[74973]
        _iterator[74974]
      }
      label _breakLabel[74979]
    }
  }
  function chpl_direct_counted_range_iter[75016](arg low[75013] :
  enum[187](?), arg count[75023] :
  (75022 call uint(64)[115] unknown w[75019])) : _unknown[51] "iterator fn" "no return value for void"
  {
    const r[75029] "const"(75027 call chpl_build_low_bounded_range low[75013])
    (75032 'end of statement')
    {
      unknown _indexOfInterest[75042] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[75043] "expr temp" "temp"
      (75052 'move' _iterator[75043](75050 call _getIterator(75037 call # r[75029] count[75023])))
      Defer
      {
        {
          (75070 call _freeIterator _iterator[75043])
        }
      }
      { scopeless type
        (75059 'move' _indexOfInterest[75042](75056 call iteratorIndex _iterator[75043]))
      }
      ForLoop[75044]
      {
        unknown i[75063] "index var" "insert auto destroy"
        (75065 'move' i[75063] _indexOfInterest[75042])
        (75040 yield i[75063])
        label _continueLabel[75047]
        _indexOfInterest[75042]
        _iterator[75043]
      }
      label _breakLabel[75048]
    }
  }
  function chpl_direct_counted_range_iter[75085](arg low[75082] :
  bool[10], arg count[75092] :
  (75091 call int(64)[13] unknown w[75088])) : _unknown[51] "iterator fn" "no return value for void"
  {
    const r[75098] "const"(75096 call chpl_build_low_bounded_range low[75082])
    (75101 'end of statement')
    {
      unknown _indexOfInterest[75111] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[75112] "expr temp" "temp"
      (75121 'move' _iterator[75112](75119 call _getIterator(75106 call # r[75098] count[75092])))
      Defer
      {
        {
          (75139 call _freeIterator _iterator[75112])
        }
      }
      { scopeless type
        (75128 'move' _indexOfInterest[75111](75125 call iteratorIndex _iterator[75112]))
      }
      ForLoop[75113]
      {
        unknown i[75132] "index var" "insert auto destroy"
        (75134 'move' i[75132] _indexOfInterest[75111])
        (75109 yield i[75132])
        label _continueLabel[75116]
        _indexOfInterest[75111]
        _iterator[75112]
      }
      label _breakLabel[75117]
    }
  }
  function chpl_direct_counted_range_iter[75154](arg low[75151] :
  bool[10], arg count[75161] :
  (75160 call uint(64)[115] unknown w[75157])) : _unknown[51] "iterator fn" "no return value for void"
  {
    const r[75167] "const"(75165 call chpl_build_low_bounded_range low[75151])
    (75170 'end of statement')
    {
      unknown _indexOfInterest[75180] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[75181] "expr temp" "temp"
      (75190 'move' _iterator[75181](75188 call _getIterator(75175 call # r[75167] count[75161])))
      Defer
      {
        {
          (75208 call _freeIterator _iterator[75181])
        }
      }
      { scopeless type
        (75197 'move' _indexOfInterest[75180](75194 call iteratorIndex _iterator[75181]))
      }
      ForLoop[75182]
      {
        unknown i[75201] "index var" "insert auto destroy"
        (75203 'move' i[75201] _indexOfInterest[75180])
        (75178 yield i[75201])
        label _continueLabel[75185]
        _indexOfInterest[75180]
        _iterator[75181]
      }
      label _breakLabel[75186]
    }
  }
  function chpl_direct_counted_range_iter[75223](arg low[75220] :
  integral[199](?), arg count[75225]:_any[178](?)) : _unknown[51] "iterator fn" "no return value for void"
  {
    (75241 call compilerError "can't apply '#' to a range with idxType "(75233 call _cast string[26](75231 'typeof' low[75220])) " using a count of type "(75239 call _cast string[26](75237 'typeof' count[75225])))
  }
  function chpl_direct_counted_range_iter[75250](arg low[75248]:_any[178](?), arg count[75252]:_any[178](?)) : _unknown[51] "iterator fn" "no return value for void"
  {
    (75257 call compilerError "Bound of 'low..' must be an integer")
  }
  function chpl_direct_counted_range_iter_helper[75266](arg low[75264]:_any[178](?), arg count[75268]:_any[178](?)) : _unknown[51] "iterator fn" "no return value for void"
  {
    if(75292 call _cond_test(75282 call &&(75276 call && 1(75275 call isIntType(75273 'typeof' count[75268])))(75280 call < count[75268] 0)))
    {
      (75290 call boundsCheckHalt module=[255] HaltWrappers[210085] "With a negative count, the range must have a last index.")
      (358066 'referenced modules list' HaltWrappers[210085])
    }
    const tmp[75340] "const" "temp"(75337 IfExpr (75305 call == count[75268] 0) then
    { scopeless
      (75320 call _build_tuple low[75264](75317 call _cast(75316 'typeof' low[75264])(75313 call -(75310 call _cast uint(64)[115] low[75264]) 1)))
    } else
    { scopeless
      (75335 call _build_tuple low[75264](75332 call + low[75264](75330 call -(75327 call _cast(75326 'typeof' low[75264]) count[75268]) 1)))
    } )
    (75347 call _check_tuple_var_decl tmp[75340] 2)
    const start[75298] "const"(75341 call tmp[75340] 0)
    const end[75300] "const"(75344 call tmp[75340] 1)
    (75352 'end of statement')
    {
      unknown _indexOfInterest[75363] "an _indexOfInterest or chpl__followIdx variable" "temp"
      unknown _iterator[75364] "expr temp" "temp"
      (75373 'move' _iterator[75364](75371 call _getIterator(75359 call chpl_direct_param_stride_range_iter start[75298] end[75300] 1)))
      Defer
      {
        {
          (75390 call _freeIterator _iterator[75364])
        }
      }
      { scopeless type
        (75379 'move' _indexOfInterest[75363](75376 call iteratorIndex _iterator[75364]))
      }
      ForLoop[75365]
      {
        unknown i[75383] "index var" "insert auto destroy"
        (75385 'move' i[75383] _indexOfInterest[75363])
        (75361 yield i[75383])
        label _continueLabel[75368]
        _indexOfInterest[75363]
        _iterator[75364]
      }
      label _breakLabel[75369]
    }
  }
  function chpl_direct_pos_stride_range_iter[75406](arg low[75403] :
  unknown t[75401], arg high[75408]:_any[178](?), arg stride[75410]:_any[178](?)) : _unknown[51] "iterator fn" "no return value for void"
  {
    if(75554 call _cond_test useOptimizedRangeIterators[64203])
    {
      (75417 call chpl_range_check_stride stride[75410] t[75401])
      if(75429 call _cond_test 1)
      {
        (75427 call chpl_checkIfRangeIterWillOverflow t[75401] low[75403] high[75408] stride[75410])
      }
      unknown i[75435] t[75401]
      (75438 'end of statement')
      CForLoop[75481]
      {
        {
          (75477 yield i[75435])
        }
        label _continueLabel[75497]
        {
          (75482 '=' i[75435] low[75403])
        }
        {
          (75485 '<=' i[75435] high[75408])
        }
        {
          (75488 '+=' i[75435](75491 call _cast t[75401] stride[75410]))
        }
      }
      label _breakLabel[75498]
    }
    {
      {
        unknown _indexOfInterest[75519] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[75520] "expr temp" "temp"
        (75529 'move' _iterator[75520](75527 call _getIterator(75515 call(75511 call .(75507 call chpl_by(75504 call chpl_build_bounded_range low[75403] high[75408]) stride[75410]) c"generalIterator"))))
        Defer
        {
          {
            (75546 call _freeIterator _iterator[75520])
          }
        }
        { scopeless type
          (75535 'move' _indexOfInterest[75519](75532 call iteratorIndex _iterator[75520]))
        }
        ForLoop[75521]
        {
          unknown i[75539] "index var" "insert auto destroy"
          (75541 'move' i[75539] _indexOfInterest[75519])
          (75517 yield i[75539])
          label _continueLabel[75524]
          _indexOfInterest[75519]
          _iterator[75520]
        }
        label _breakLabel[75525]
      }
    }
  }
  function chpl_direct_param_stride_range_iter[75568](arg low[75565] :
  unknown t[75563], arg high[75570]:_any[178](?), param arg stride[75572]:_any[178](?)) : _unknown[51] "iterator fn" "no return value for void"
  {
    if(75779 call _cond_test useOptimizedRangeIterators[64203])
    {
      (75579 call chpl_range_check_stride stride[75572] t[75563])
      unknown i[75583] t[75563]
      (75586 'end of statement')
      if(75723 call _cond_test(75589 call > stride[75572] 0))
      {
        if(75600 call _cond_test 1)
        {
          (75598 call chpl_checkIfRangeIterWillOverflow t[75563] low[75565] high[75570] stride[75572])
        }
        CForLoop[75632]
        {
          {
            (75628 yield i[75583])
          }
          label _continueLabel[75648]
          {
            (75633 '=' i[75583] low[75565])
          }
          {
            (75636 '<=' i[75583] high[75570])
          }
          {
            (75639 '+=' i[75583](75642 call _cast t[75563] stride[75572]))
          }
        }
        label _breakLabel[75649]
      }
      {
        if(75719 call _cond_test(75654 call < stride[75572] 0))
        {
          if(75667 call _cond_test 1)
          {
            (75665 call chpl_checkIfRangeIterWillOverflow t[75563] low[75565] high[75570] stride[75572] high[75570] low[75565])
          }
          CForLoop[75699]
          {
            {
              (75695 yield i[75583])
            }
            label _continueLabel[75715]
            {
              (75700 '=' i[75583] high[75570])
            }
            {
              (75703 '>=' i[75583] low[75565])
            }
            {
              (75706 '+=' i[75583](75709 call _cast t[75563] stride[75572]))
            }
          }
          label _breakLabel[75716]
        }
      }
    }
    {
      {
        unknown _indexOfInterest[75744] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[75745] "expr temp" "temp"
        (75754 'move' _iterator[75745](75752 call _getIterator(75740 call(75736 call .(75734 call chpl_by(75731 call chpl_build_bounded_range low[75565] high[75570]) stride[75572]) c"generalIterator"))))
        Defer
        {
          {
            (75771 call _freeIterator _iterator[75745])
          }
        }
        { scopeless type
          (75760 'move' _indexOfInterest[75744](75757 call iteratorIndex _iterator[75745]))
        }
        ForLoop[75746]
        {
          unknown i[75764] "index var" "insert auto destroy"
          (75766 'move' i[75764] _indexOfInterest[75744])
          (75742 yield i[75764])
          label _continueLabel[75749]
          _indexOfInterest[75744]
          _iterator[75745]
        }
        label _breakLabel[75750]
      }
    }
  }
  function range[64319](?).these[75789](arg _mt[75794]:_MT[238], arg this[75791]:range[64319](?) :
  range[64319](?)) : _unknown[51] "iterator fn" "method" "no doc" "no return value for void"
  {
    if(75831 call _cond_test(75808 call ==(375636 call . this[75791] c"boundedType") boundedNone[64214]))
    {
      (75829 call compilerError "iteration over a range with no bounds")
    }
    if(75911 call _cond_test 1)
    {
      if(75870 call _cond_test(75844 call !(75843 call(75839 call . this[75791] c"hasFirst"))))
      {
        (75868 call boundsCheckHalt module=[255] HaltWrappers[210085] "iteration over range that has no first index")
        (358075 'referenced modules list' HaltWrappers[210085])
      }
      if(75906 call _cond_test(75881 call(75877 call . this[75791] c"isAmbiguous")))
      {
        (75904 call boundsCheckHalt module=[255] HaltWrappers[210085] "these -- Attempt to iterate over a range with ambiguous alignment.")
        (358082 'referenced modules list' HaltWrappers[210085])
      }
    }
    unknown i[75916](375641 call . this[75791] c"intIdxType")
    (75919 'end of statement')
    const start[75927] "const"(75926 call chpl__idxToInt(75922 call . this[75791] c"first"))
    (75930 'end of statement')
    CForLoop[75956]
    {
      {
        (75952 yield(75951 call(375645 call . this[75791] c"chpl_intToIdx") i[75916]))
      }
      label _continueLabel[75970]
      {
        (75957 '=' i[75916] start[75927])
      }
      {
        1
      }
      {
        (75961 '+=' i[75916](75964 call _cast(375653 call . this[75791] c"intIdxType")(375657 call . this[75791] c"stride")))
      }
    }
    label _breakLabel[75971]
  }
  where {
    (75801 call !=(375631 call . this[75791] c"boundedType") bounded[64208])
  }
  function range[64319](?).these[75980](arg _mt[75985]:_MT[238], arg this[75982]:range[64319](?) :
  range[64319](?)) : _unknown[51] "iterator fn" "method" "no doc" "no return value for void"
  {
    if(76167 call _cond_test useOptimizedRangeIterators[64203])
    {
      if(76026 call _cond_test 1)
      {
        (76004 call(375675 call . this[75982] c"checkIfIterWillOverflow"))
        if(76021 call _cond_test(76012 call(76008 call . this[75982] c"isAmbiguous")))
        {
          (76019 call boundsCheckHalt module=[255] HaltWrappers[210085] "these -- Attempt to iterate over a range with ambiguous alignment.")
          (358091 'referenced modules list' HaltWrappers[210085])
        }
      }
      unknown i[76032](375679 call . this[75982] c"intIdxType")
      (76035 'end of statement')
      const start[76040] "const"(76037 call . this[75982] c"firstAsInt")
      (76043 'end of statement')
      const end[76069] "const"(76066 IfExpr (76053 call >(76046 call . this[75982] c"low")(76050 call . this[75982] c"high")) then
      { scopeless
        start[76040]
      } else
      { scopeless
        (76064 call +(76057 call . this[75982] c"lastAsInt")(76062 call _cast(375692 call . this[75982] c"intIdxType")(375688 call . this[75982] c"stride")))
      } )(375683 call . this[75982] c"intIdxType")
      (76072 'end of statement')
      CForLoop[76102]
      {
        {
          (76098 yield(76097 call(375696 call . this[75982] c"chpl_intToIdx") i[76032]))
        }
        label _continueLabel[76118]
        {
          (76103 '=' i[76032] start[76040])
        }
        {
          (76106 '!=' i[76032] end[76069])
        }
        {
          (76109 '+=' i[76032](76112 call _cast(375706 call . this[75982] c"intIdxType")(375710 call . this[75982] c"stride")))
        }
      }
      label _breakLabel[76119]
    }
    {
      {
        unknown _indexOfInterest[76132] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[76133] "expr temp" "temp"
        (76142 'move' _iterator[76133](76140 call _getIterator(76128 call(76124 call . this[75982] c"generalIterator"))))
        Defer
        {
          {
            (76159 call _freeIterator _iterator[76133])
          }
        }
        { scopeless type
          (76148 'move' _indexOfInterest[76132](76145 call iteratorIndex _iterator[76133]))
        }
        ForLoop[76134]
        {
          unknown i[76152] "index var" "insert auto destroy"
          (76154 'move' i[76152] _indexOfInterest[76132])
          (76130 yield i[76152])
          label _continueLabel[76137]
          _indexOfInterest[76132]
          _iterator[76133]
        }
        label _breakLabel[76138]
      }
    }
  }
  where {
    (75998 call &&(75992 call ==(375662 call . this[75982] c"boundedType") bounded[64208])(75996 call ==(375667 call . this[75982] c"stridable") 1))
  }
  function range[64319](?).these[76178](arg _mt[76183]:_MT[238], arg this[76180]:range[64319](?) :
  range[64319](?)) : _unknown[51] "iterator fn" "method" "no doc" "no return value for void"
  {
    if(76325 call _cond_test useOptimizedRangeIterators[64203])
    {
      if(76204 call _cond_test 1)
      {
        (76202 call(375727 call . this[76180] c"checkIfIterWillOverflow"))
      }
      unknown i[76211](375731 call . this[76180] c"intIdxType")
      (76214 'end of statement')
      const start[76219] "const"(76216 call . this[76180] c"_low")
      (76222 'end of statement')
      const end[76227] "const"(76224 call . this[76180] c"_high")
      (76230 'end of statement')
      CForLoop[76260]
      {
        {
          (76256 yield(76255 call(375735 call . this[76180] c"chpl_intToIdx") i[76211]))
        }
        label _continueLabel[76276]
        {
          (76261 '=' i[76211] start[76219])
        }
        {
          (76264 '<=' i[76211] end[76227])
        }
        {
          (76267 '+=' i[76211](76270 call _cast(375745 call . this[76180] c"intIdxType")(375749 call . this[76180] c"stride")))
        }
      }
      label _breakLabel[76277]
    }
    {
      {
        unknown _indexOfInterest[76290] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[76291] "expr temp" "temp"
        (76300 'move' _iterator[76291](76298 call _getIterator(76286 call(76282 call . this[76180] c"generalIterator"))))
        Defer
        {
          {
            (76317 call _freeIterator _iterator[76291])
          }
        }
        { scopeless type
          (76306 'move' _indexOfInterest[76290](76303 call iteratorIndex _iterator[76291]))
        }
        ForLoop[76292]
        {
          unknown i[76310] "index var" "insert auto destroy"
          (76312 'move' i[76310] _indexOfInterest[76290])
          (76288 yield i[76310])
          label _continueLabel[76295]
          _indexOfInterest[76290]
          _iterator[76291]
        }
        label _breakLabel[76296]
      }
    }
  }
  where {
    (76196 call &&(76190 call ==(375716 call . this[76180] c"boundedType") bounded[64208])(76194 call ==(375721 call . this[76180] c"stridable") 0))
  }
  function range[64319](?).generalIterator[76336](arg _mt[76341]:_MT[238], arg this[76338]:range[64319](?) :
  range[64319](?)) : _unknown[51] "iterator fn" "method" "no doc" "no return value for void"
  {
    if(76360 call _cond_test(76350 call && 1(76349 call(76345 call . this[76338] c"isAmbiguous"))))
    {
      (76358 call boundsCheckHalt module=[255] HaltWrappers[210085] "these -- Attempt to iterate over a range with ambiguous alignment.")
      (358107 'referenced modules list' HaltWrappers[210085])
    }
    unknown i[76367](375755 call . this[76338] c"intIdxType")
    (76370 'end of statement')
    const start[76375] "const"(76372 call . this[76338] c"first")
    (76378 'end of statement')
    const end[76399] "const"(76396 IfExpr (76387 call >(76380 call . this[76338] c"low")(76384 call . this[76338] c"high")) then
    { scopeless
      start[76375]
    } else
    { scopeless
      (76393 call . this[76338] c"last")
    } )
    (76402 'end of statement')
    CForLoop[76441]
    {
      {
        (76425 yield i[76367])
        if(76435 call _cond_test(76430 call == i[76367] end[76399]))
        {
          break _breakLabel[76458] _breakLabel[76458]
        }
      }
      label _continueLabel[76457]
      {
        (76442 '=' i[76367] start[76375])
      }
      {
        (76445 '>='(375765 call . this[76338] c"high")(375769 call . this[76338] c"low"))
      }
      {
        (76448 '+=' i[76367](76451 call _cast(375774 call . this[76338] c"intIdxType")(375778 call . this[76338] c"stride")))
      }
    }
    label _breakLabel[76458]
  }
  function range[64319](?).these[76470](arg _mt[76475]:_MT[238], arg this[76472]:range[64319](?) :
  range[64319](?), param arg tag[76467] :
  iterKind[453]) : _unknown[51] "iterator fn" "method" "no doc" "no return value for void"
  {
    if(76517 call _cond_test(76493 call !(76492 call isBoundedRange this[76472])))
    {
      (76514 call compilerError "parallel iteration is not supported over unbounded ranges")
    }
    if(76540 call _cond_test(76529 call && 1(76528 call(76524 call . this[76472] c"isAmbiguous"))))
    {
      (76537 call boundsCheckHalt module=[255] HaltWrappers[210085] "these -- Attempt to iterate over a range with ambiguous alignment.")
      (358119 'referenced modules list' HaltWrappers[210085])
    }
    if(76567 call _cond_test debugChapelRange[64198])
    {
      (76564 call chpl_debug_writeln "*** In range standalone iterator:")
    }
    const len[76575] "const"(76572 call . this[76472] c"size")
    (76578 'end of statement')
    const numChunks[76606] "const"(76603 IfExpr (76597 'task_get_serial') then
    { scopeless
      1
    } else
    { scopeless
      (76602 call _computeNumChunks len[76575])
    } )
    (76609 'end of statement')
    if(76652 call _cond_test debugChapelRange[64198])
    {
      (76649 call chpl_debug_writeln "*** RI: length=" len[76575] " numChunks=" numChunks[76606])
    }
    if(77307 call _cond_test(76658 call <= numChunks[76606] 1))
    {
      {
        unknown _indexOfInterest[76666] "an _indexOfInterest or chpl__followIdx variable" "temp"
        unknown _iterator[76667] "expr temp" "temp"
        (76676 'move' _iterator[76667](76674 call _getIterator this[76472]))
        Defer
        {
          {
            (76692 call _freeIterator _iterator[76667])
          }
        }
        { scopeless type
          (76681 'move' _indexOfInterest[76666](76678 call iteratorIndex _iterator[76667]))
        }
        ForLoop[76668]
        {
          unknown i[76685] "index var" "insert auto destroy"
          (76687 'move' i[76685] _indexOfInterest[76666])
          {
            (76663 yield i[76685])
          }
          label _continueLabel[76671]
          _indexOfInterest[76666]
          _iterator[76667]
        }
        label _breakLabel[76672]
      }
    }
    {
      {
        unknown tmpIter[76942] "expr temp" "maybe ref" "no copy" "temp"
        (76945 'move' tmpIter[76942](76705 call #(76702 call chpl_build_low_bounded_range 0) numChunks[76606]))
        unknown isRngDomArr[77287] "maybe param" "temp"
        (77302 'move' isRngDomArr[77287](77300 call ||(77289 call isBoundedRange tmpIter[76942])(77298 call ||(77292 call isDomain tmpIter[76942])(77295 call isArray tmpIter[76942]))))
        if isRngDomArr[77287]
        {
          const _coforallCount[77154] "const" "end count" "temp"
          (77223 'move' _coforallCount[77154](77220 call _endCountAlloc 1))
          unknown numTasks[77155] "temp"
          (77207 'move' numTasks[77155](77203 call . tmpIter[76942] c"size"))
          (77198 call _upEndCount _coforallCount[77154] 1 numTasks[77155])
          (77195 call chpl_resetTaskSpawn numTasks[77155])
          unknown _indexOfInterest[77162] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[77163] "expr temp" "temp"
          (77172 'move' _iterator[77163](77170 call _getIterator tmpIter[76942]))
          Defer
          {
            {
              (77188 call _freeIterator _iterator[77163])
            }
          }
          { scopeless type
            (77177 'move' _indexOfInterest[77162](77174 call iteratorIndex _iterator[77163]))
          }
          ForLoop[77164]
          {
            unknown chunk[77181] "coforall index var" "index var" "insert auto destroy"
            (77183 'move' chunk[77181] _indexOfInterest[77162])
            {
              {
                if(76949 call _cond_test(375854 call . this[76472] c"stridable"))
                {
                  const tmp[76953] "const" "temp"(76955 call _computeBlock len[76575] numChunks[76606] chunk[77181](76960 call - len[76575] 1))
                  (76965 call _check_tuple_var_decl tmp[76953] 2)
                  const lo[76968] "const"(76970 call tmp[76953] 0)
                  const hi[76973] "const"(76975 call tmp[76953] 1)
                  (76978 'end of statement')
                  const mylen[76980] "const"(76982 call - hi[76973](76985 call - lo[76968] 1))
                  (76989 'end of statement')
                  unknown low[76991](76993 call(375864 call . this[76472] c"orderToIndex") lo[76968])
                  (76996 'end of statement')
                  unknown high[76998](77000 call(375869 call . this[76472] c"chpl_intToIdx")(77002 call +(77004 call _cast(375873 call . this[76472] c"strType")(77007 call chpl__idxToInt low[76991]))(77010 call *(375878 call . this[76472] c"stride")(77013 call _cast(375882 call . this[76472] c"strType")(77016 call - mylen[76980] 1)))))
                  (77020 'end of statement')
                  if(77022 call _cond_test(77024 call <(375887 call . this[76472] c"stride") 0))
                  {
                    (77030 call <=> low[76991] high[76998])
                  }
                  {
                    unknown _indexOfInterest[77035] "an _indexOfInterest or chpl__followIdx variable" "temp"
                    unknown _iterator[77037] "expr temp" "temp"
                    (77039 'move' _iterator[77037](77042 call _getIterator(77044 call chpl_direct_range_iter low[76991] high[76998](375895 call . this[76472] c"stride"))))
                    Defer
                    {
                      {
                        (77050 call _freeIterator _iterator[77037])
                      }
                    }
                    { scopeless type
                      (77054 'move' _indexOfInterest[77035](77057 call iteratorIndex _iterator[77037]))
                    }
                    ForLoop[77059]
                    {
                      unknown i[77062] "index var" "insert auto destroy"
                      (77064 'move' i[77062] _indexOfInterest[77035])
                      {
                        (77068 yield i[77062])
                      }
                      label _continueLabel[77070]
                      _indexOfInterest[77035]
                      _iterator[77037]
                    }
                    label _breakLabel[77072]
                  }
                }
                {
                  const tmp[77076] "const" "temp"(77078 call _computeBlock len[76575] numChunks[76606] chunk[77181](77083 call . this[76472] c"_high")(77087 call . this[76472] c"_low")(77091 call . this[76472] c"_low"))
                  (77096 call _check_tuple_var_decl tmp[77076] 2)
                  const lo[77099] "const"(77101 call tmp[77076] 0)
                  const hi[77104] "const"(77106 call tmp[77076] 1)
                  (77109 'end of statement')
                  {
                    unknown _indexOfInterest[77111] "an _indexOfInterest or chpl__followIdx variable" "temp"
                    unknown _iterator[77113] "expr temp" "temp"
                    (77115 'move' _iterator[77113](77118 call _getIterator(77120 call chpl_direct_range_iter lo[77099] hi[77104] 1)))
                    Defer
                    {
                      {
                        (77126 call _freeIterator _iterator[77113])
                      }
                    }
                    { scopeless type
                      (77130 'move' _indexOfInterest[77111](77133 call iteratorIndex _iterator[77113]))
                    }
                    ForLoop[77135]
                    {
                      unknown i[77138] "index var" "insert auto destroy"
                      (77140 'move' i[77138] _indexOfInterest[77111])
                      {
                        (77144 yield(77146 call(375905 call . this[76472] c"chpl_intToIdx") i[77138]))
                      }
                      label _continueLabel[77148]
                      _indexOfInterest[77111]
                      _iterator[77113]
                    }
                    label _breakLabel[77150]
                  }
                }
              }
              (77157 call _downEndCount _coforallCount[77154] nil[44])
              (77156 'coforall loop')
            }
            label _continueLabel[77167]
            _indexOfInterest[77162]
            _iterator[77163]
          }
          label _breakLabel[77168]
          Defer
          {
            {
              (77210 call _endCountFree _coforallCount[77154])
            }
          }
          (77215 call _waitEndCount _coforallCount[77154] 1 numTasks[77155])
        }
        {
          const _coforallCount[77227] "const" "end count" "temp"
          (77284 'move' _coforallCount[77227](77281 call _endCountAlloc 1))
          unknown _indexOfInterest[77235] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[77236] "expr temp" "temp"
          (77245 'move' _iterator[77236](77243 call _getIterator tmpIter[76942]))
          Defer
          {
            {
              (77261 call _freeIterator _iterator[77236])
            }
          }
          { scopeless type
            (77250 'move' _indexOfInterest[77235](77247 call iteratorIndex _iterator[77236]))
          }
          ForLoop[77237]
          {
            unknown chunk[77254] "coforall index var" "index var" "insert auto destroy"
            (77256 'move' chunk[77254] _indexOfInterest[77235])
            (77268 call _upEndCount _coforallCount[77227] 1)
            {
              {
                if(76937 call _cond_test(375797 call . this[76472] c"stridable"))
                {
                  const tmp[76723] "const" "temp"(76722 call _computeBlock len[76575] numChunks[76606] chunk[77254](76720 call - len[76575] 1))
                  (76730 call _check_tuple_var_decl tmp[76723] 2)
                  const lo[76708] "const"(76724 call tmp[76723] 0)
                  const hi[76710] "const"(76727 call tmp[76723] 1)
                  (76735 'end of statement')
                  const mylen[76744] "const"(76742 call - hi[76710](76740 call - lo[76708] 1))
                  (76747 'end of statement')
                  unknown low[76752](76751 call(375807 call . this[76472] c"orderToIndex") lo[76708])
                  (76755 'end of statement')
                  unknown high[76778](76777 call(375812 call . this[76472] c"chpl_intToIdx")(76774 call +(76762 call _cast(375817 call . this[76472] c"strType")(76760 call chpl__idxToInt low[76752]))(76772 call *(375821 call . this[76472] c"stride")(76770 call _cast(375826 call . this[76472] c"strType")(76767 call - mylen[76744] 1)))))
                  (76781 'end of statement')
                  if(76791 call _cond_test(76784 call <(375830 call . this[76472] c"stride") 0))
                  {
                    (76788 call <=> low[76752] high[76778])
                  }
                  {
                    unknown _indexOfInterest[76808] "an _indexOfInterest or chpl__followIdx variable" "temp"
                    unknown _iterator[76809] "expr temp" "temp"
                    (76818 'move' _iterator[76809](76816 call _getIterator(76827 call chpl_direct_range_iter low[76752] high[76778](375837 call . this[76472] c"stride"))))
                    Defer
                    {
                      {
                        (76843 call _freeIterator _iterator[76809])
                      }
                    }
                    { scopeless type
                      (76832 'move' _indexOfInterest[76808](76829 call iteratorIndex _iterator[76809]))
                    }
                    ForLoop[76810]
                    {
                      unknown i[76836] "index var" "insert auto destroy"
                      (76838 'move' i[76836] _indexOfInterest[76808])
                      {
                        (76805 yield i[76836])
                      }
                      label _continueLabel[76813]
                      _indexOfInterest[76808]
                      _iterator[76809]
                    }
                    label _breakLabel[76814]
                  }
                }
                {
                  const tmp[76873] "const" "temp"(76872 call _computeBlock len[76575] numChunks[76606] chunk[77254](76861 call . this[76472] c"_high")(76865 call . this[76472] c"_low")(76869 call . this[76472] c"_low"))
                  (76880 call _check_tuple_var_decl tmp[76873] 2)
                  const lo[76850] "const"(76874 call tmp[76873] 0)
                  const hi[76852] "const"(76877 call tmp[76873] 1)
                  (76885 'end of statement')
                  {
                    unknown _indexOfInterest[76899] "an _indexOfInterest or chpl__followIdx variable" "temp"
                    unknown _iterator[76900] "expr temp" "temp"
                    (76909 'move' _iterator[76900](76907 call _getIterator(76914 call chpl_direct_range_iter lo[76850] hi[76852] 1)))
                    Defer
                    {
                      {
                        (76930 call _freeIterator _iterator[76900])
                      }
                    }
                    { scopeless type
                      (76919 'move' _indexOfInterest[76899](76916 call iteratorIndex _iterator[76900]))
                    }
                    ForLoop[76901]
                    {
                      unknown i[76923] "index var" "insert auto destroy"
                      (76925 'move' i[76923] _indexOfInterest[76899])
                      {
                        (76896 yield(76895 call(375846 call . this[76472] c"chpl_intToIdx") i[76923]))
                      }
                      label _continueLabel[76904]
                      _indexOfInterest[76899]
                      _iterator[76900]
                    }
                    label _breakLabel[76905]
                  }
                }
              }
              (77230 call _downEndCount _coforallCount[77227] nil[44])
              (77229 'coforall loop')
            }
            label _continueLabel[77240]
            _indexOfInterest[77235]
            _iterator[77236]
          }
          label _breakLabel[77241]
          Defer
          {
            {
              (77272 call _endCountFree _coforallCount[77227])
            }
          }
          (77277 call _waitEndCount _coforallCount[77227] 1)
        }
      }
    }
  }
  where {
    (76487 call &&(76482 call == tag[76467] standalone[451])(76485 call ! localeModelHasSublocales[187449]))
  }
  function range[64319](?).these[77321](arg _mt[77326]:_MT[238], arg this[77323]:range[64319](?) :
  range[64319](?), param arg tag[77318] :
  iterKind[453]) : _unknown[51] "iterator fn" "method" "no doc" "no return value for void"
  {
    if(77346 call _cond_test(77339 call !(77338 call isBoundedRange this[77323])))
    {
      (77344 call compilerError "parallel iteration is not supported over unbounded ranges")
    }
    if(77369 call _cond_test(77359 call && 1(77358 call(77354 call . this[77323] c"isAmbiguous"))))
    {
      (77367 call boundsCheckHalt module=[255] HaltWrappers[210085] "these -- Attempt to iterate over a range with ambiguous alignment.")
      (358134 'referenced modules list' HaltWrappers[210085])
    }
    if(77396 call _cond_test debugChapelRange[64198])
    {
      (77394 call chpl_debug_writeln "*** In range leader:")
    }
    const numSublocs[77409] "const"(77408 call(77404 call .(358139 call here[90438]) c"getChildCount"))
    (77412 'end of statement')
    if(79138 call _cond_test(77418 call && localeModelHasSublocales[187449](77416 call != numSublocs[77409] 0)))
    {
      const len[77424] "const"(77421 call . this[77323] c"size")
      (77427 'end of statement')
      const tasksPerLocale[77430] "const" dataParTasksPerLocale[93284]
      (77433 'end of statement')
      const ignoreRunning[77435] "const" dataParIgnoreRunningTasks[93290]
      (77438 'end of statement')
      const minIndicesPerTask[77440] "const" dataParMinGranularity[93296]
      (77443 'end of statement')
      unknown dptpl[77456](77453 IfExpr (77446 call == tasksPerLocale[77430] 0) then
      { scopeless
        (77449 call .(358142 call here[90438]) c"maxTaskPar")
      } else
      { scopeless
        tasksPerLocale[77430]
      } )
      (77459 'end of statement')
      if(77498 call _cond_test(77461 call ! ignoreRunning[77435]))
      {
        const otherTasks[77474] "const"(77472 call -(77470 call(77466 call .(358144 call here[90438]) c"runningTasks")) 1)
        (77477 'end of statement')
        (77495 call = dptpl[77456](77492 IfExpr (77482 call < otherTasks[77474] dptpl[77456]) then
        { scopeless
          (77489 call _cast int(64)[13](77486 call - dptpl[77456] otherTasks[77474]))
        } else
        { scopeless
          1
        } ))
      }
      const numSublocTasks[77507] "const"(77506 call min numSublocs[77409] dptpl[77456])
      (77510 'end of statement')
      const numChunks[77526] "const"(77523 IfExpr (77513 'task_get_serial') then
      { scopeless
        1
      } else
      { scopeless
        (77522 call _computeNumChunks numSublocTasks[77507](ignoreRunning = 1) minIndicesPerTask[77440] len[77424])
      } )
      (77529 'end of statement')
      if(77646 call _cond_test debugDataParNuma[93410])
      {
        (77643 call chpl_debug_writeln "### numSublocs = " numSublocs[77409] "\n" "### numTasksPerSubloc = " numSublocTasks[77507] "\n" "### ignoreRunning = " ignoreRunning[77435] "\n" "### minIndicesPerTask = " minIndicesPerTask[77440] "\n" "### numChunks = " numChunks[77526])
      }
      if(78751 call _cond_test(77652 call == numChunks[77526] 1))
      {
        (77663 yield(77661 call _build_tuple(77659 call chpl_build_bounded_range 0(77657 call - len[77424] 1))))
      }
      {
        {
          unknown tmpIter[78210] "expr temp" "maybe ref" "no copy" "temp"
          (78213 'move' tmpIter[78210](77671 call #(77668 call chpl_build_low_bounded_range 0) numChunks[77526]))
          unknown isRngDomArr[78731] "maybe param" "temp"
          (78746 'move' isRngDomArr[78731](78744 call ||(78733 call isBoundedRange tmpIter[78210])(78742 call ||(78736 call isDomain tmpIter[78210])(78739 call isArray tmpIter[78210]))))
          if isRngDomArr[78731]
          {
            const _coforallCount[78603] "const" "end count" "temp"
            (78668 'move' _coforallCount[78603](78665 call _endCountAlloc 0))
            unknown numTasks[78604] "temp"
            (78652 'move' numTasks[78604](78648 call . tmpIter[78210] c"size"))
            (78643 call _upEndCount _coforallCount[78603] 0 numTasks[78604])
            unknown _indexOfInterest[78610] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
            unknown _iterator[78611] "expr temp" "temp"
            (78620 'move' _iterator[78611](78618 call _getIterator tmpIter[78210]))
            Defer
            {
              {
                (78636 call _freeIterator _iterator[78611])
              }
            }
            { scopeless type
              (78625 'move' _indexOfInterest[78610](78622 call iteratorIndex _iterator[78611]))
            }
            ForLoop[78612]
            {
              unknown chunk[78629] "coforall index var" "index var" "insert auto destroy"
              (78631 'move' chunk[78629] _indexOfInterest[78610])
              const tmp[78216] "const" "temp"
              (78218 'move' tmp[78216](78220 'deref'(78221 '_wide_get_locale'(78226 call(78223 call .(358149 call here[90438]) c"getChild") chunk[78629]))))
              {
                {
                  if(78234 call _cond_test debugDataParNuma[93410])
                  {
                    if(78238 call _cond_test(78240 call != chunk[78629](78243 call chpl_getSubloc)))
                    {
                      (78247 call chpl_debug_writeln "*** ERROR: ON WRONG SUBLOC (should be " chunk[78629] ", on "(78252 call chpl_getSubloc) ") ***")
                    }
                  }
                  const tmp[78257] "const" "temp"(78259 call _computeBlock len[77424] numChunks[77526] chunk[78629](78264 call - len[77424] 1))
                  (78269 call _check_tuple_var_decl tmp[78257] 2)
                  const lo[78272] "const"(78274 call tmp[78257] 0)
                  const hi[78277] "const"(78279 call tmp[78257] 1)
                  (78282 'end of statement')
                  const locRange[78284] "const"(78286 call chpl_build_bounded_range lo[78272] hi[78277])
                  (78290 'end of statement')
                  const locLen[78292] "const"(78294 call . locRange[78284] c"size")
                  (78298 'end of statement')
                  const numSublocTasks[78300] "const"(78321 IfExpr (78302 call < chunk[78629](78305 call % dptpl[77456] numChunks[77526])) then
                  { scopeless
                    (78310 call +(78312 call / dptpl[77456] numChunks[77526]) 1)
                  } else
                  { scopeless
                    (78318 call / dptpl[77456] numChunks[77526])
                  } )
                  (78323 'end of statement')
                  const numTasks[78325] "const"(78327 call _computeNumChunks numSublocTasks[78300](ignoreRunning = 1) minIndicesPerTask[77440] locLen[78292])
                  (78334 'end of statement')
                  {
                    unknown tmpIter[78336] "expr temp" "maybe ref" "no copy" "temp"
                    (78338 'move' tmpIter[78336](78341 call #(78343 call chpl_build_low_bounded_range 0) numTasks[78325]))
                    unknown isRngDomArr[78346] "maybe param" "temp"
                    (78348 'move' isRngDomArr[78346](78351 call ||(78353 call isBoundedRange tmpIter[78336])(78356 call ||(78358 call isDomain tmpIter[78336])(78361 call isArray tmpIter[78336]))))
                    if isRngDomArr[78346]
                    {
                      const _coforallCount[78365] "const" "end count" "temp"
                      (78367 'move' _coforallCount[78365](78370 call _endCountAlloc 1))
                      unknown numTasks[78372] "temp"
                      (78374 'move' numTasks[78372](78377 call . tmpIter[78336] c"size"))
                      (78381 call _upEndCount _coforallCount[78365] 1 numTasks[78372])
                      (78386 call chpl_resetTaskSpawn numTasks[78372])
                      unknown _indexOfInterest[78388] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
                      unknown _iterator[78390] "expr temp" "temp"
                      (78392 'move' _iterator[78390](78395 call _getIterator tmpIter[78336]))
                      Defer
                      {
                        {
                          (78399 call _freeIterator _iterator[78390])
                        }
                      }
                      { scopeless type
                        (78403 'move' _indexOfInterest[78388](78406 call iteratorIndex _iterator[78390]))
                      }
                      ForLoop[78408]
                      {
                        unknown core[78411] "coforall index var" "index var" "insert auto destroy"
                        (78413 'move' core[78411] _indexOfInterest[78388])
                        {
                          {
                            const tmp[78420] "const" "temp"(78422 call _computeBlock locLen[78292] numTasks[78325] core[78411] hi[78277] lo[78272] lo[78272])
                            (78431 call _check_tuple_var_decl tmp[78420] 2)
                            const low[78434] "const"(78436 call tmp[78420] 0)
                            const high[78439] "const"(78441 call tmp[78420] 1)
                            (78444 'end of statement')
                            if(78446 call _cond_test debugDataParNuma[93410])
                            {
                              (78450 call chpl_debug_writeln "### chunk = " chunk[78629] "  core = " core[78411] "  " "locRange = " locRange[78284] "  coreRange = "(78460 call chpl_build_bounded_range low[78434] high[78439]))
                            }
                            (78464 yield(78466 call _build_tuple(78468 call chpl_build_bounded_range low[78434] high[78439])))
                          }
                          (78472 call _downEndCount _coforallCount[78365] nil[44])
                          (78417 'coforall loop')
                        }
                        label _continueLabel[78475]
                        _indexOfInterest[78388]
                        _iterator[78390]
                      }
                      label _breakLabel[78477]
                      Defer
                      {
                        {
                          (78481 call _endCountFree _coforallCount[78365])
                        }
                      }
                      (78485 call _waitEndCount _coforallCount[78365] 1 numTasks[78372])
                    }
                    {
                      const _coforallCount[78490] "const" "end count" "temp"
                      (78492 'move' _coforallCount[78490](78495 call _endCountAlloc 1))
                      unknown _indexOfInterest[78497] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
                      unknown _iterator[78499] "expr temp" "temp"
                      (78501 'move' _iterator[78499](78504 call _getIterator tmpIter[78336]))
                      Defer
                      {
                        {
                          (78508 call _freeIterator _iterator[78499])
                        }
                      }
                      { scopeless type
                        (78512 'move' _indexOfInterest[78497](78515 call iteratorIndex _iterator[78499]))
                      }
                      ForLoop[78517]
                      {
                        unknown core[78520] "coforall index var" "index var" "insert auto destroy"
                        (78522 'move' core[78520] _indexOfInterest[78497])
                        (78526 call _upEndCount _coforallCount[78490] 1)
                        {
                          {
                            const tmp[78533] "const" "temp"(78535 call _computeBlock locLen[78292] numTasks[78325] core[78520] hi[78277] lo[78272] lo[78272])
                            (78544 call _check_tuple_var_decl tmp[78533] 2)
                            const low[78547] "const"(78549 call tmp[78533] 0)
                            const high[78552] "const"(78554 call tmp[78533] 1)
                            (78557 'end of statement')
                            if(78559 call _cond_test debugDataParNuma[93410])
                            {
                              (78563 call chpl_debug_writeln "### chunk = " chunk[78629] "  core = " core[78520] "  " "locRange = " locRange[78284] "  coreRange = "(78573 call chpl_build_bounded_range low[78547] high[78552]))
                            }
                            (78577 yield(78579 call _build_tuple(78581 call chpl_build_bounded_range low[78547] high[78552])))
                          }
                          (78585 call _downEndCount _coforallCount[78490] nil[44])
                          (78530 'coforall loop')
                        }
                        label _continueLabel[78588]
                        _indexOfInterest[78497]
                        _iterator[78499]
                      }
                      label _breakLabel[78590]
                      Defer
                      {
                        {
                          (78594 call _endCountFree _coforallCount[78490])
                        }
                      }
                      (78598 call _waitEndCount _coforallCount[78490] 1)
                    }
                  }
                }
                (78605 call _downEndCount _coforallCount[78603] nil[44])
                (78229 'coforall on block' 1 tmp[78216])
              }
              label _continueLabel[78615]
              _indexOfInterest[78610]
              _iterator[78611]
            }
            label _breakLabel[78616]
            Defer
            {
              {
                (78655 call _endCountFree _coforallCount[78603])
              }
            }
            (78660 call _waitEndCount _coforallCount[78603] 0 numTasks[78604])
          }
          {
            const _coforallCount[78672] "const" "end count" "temp"
            (78728 'move' _coforallCount[78672](78725 call _endCountAlloc 0))
            unknown _indexOfInterest[78679] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
            unknown _iterator[78680] "expr temp" "temp"
            (78689 'move' _iterator[78680](78687 call _getIterator tmpIter[78210]))
            Defer
            {
              {
                (78705 call _freeIterator _iterator[78680])
              }
            }
            { scopeless type
              (78694 'move' _indexOfInterest[78679](78691 call iteratorIndex _iterator[78680]))
            }
            ForLoop[78681]
            {
              unknown chunk[78698] "coforall index var" "index var" "insert auto destroy"
              (78700 'move' chunk[78698] _indexOfInterest[78679])
              (78712 call _upEndCount _coforallCount[78672] 0)
              const tmp[78199] "const" "temp"
              (78201 'move' tmp[78199](78197 'deref'(78196 '_wide_get_locale'(77681 call(77676 call .(358146 call here[90438]) c"getChild") chunk[78698]))))
              {
                {
                  if(77754 call _cond_test debugDataParNuma[93410])
                  {
                    if(77748 call _cond_test(77687 call != chunk[78698](77686 call chpl_getSubloc)))
                    {
                      (77746 call chpl_debug_writeln "*** ERROR: ON WRONG SUBLOC (should be " chunk[78698] ", on "(77728 call chpl_getSubloc) ") ***")
                    }
                  }
                  const tmp[77774] "const" "temp"(77773 call _computeBlock len[77424] numChunks[77526] chunk[78698](77771 call - len[77424] 1))
                  (77781 call _check_tuple_var_decl tmp[77774] 2)
                  const lo[77759] "const"(77775 call tmp[77774] 0)
                  const hi[77761] "const"(77778 call tmp[77774] 1)
                  (77786 'end of statement')
                  const locRange[77791] "const"(77789 call chpl_build_bounded_range lo[77759] hi[77761])
                  (77794 'end of statement')
                  const locLen[77799] "const"(77796 call . locRange[77791] c"size")
                  (77802 'end of statement')
                  const numSublocTasks[77824] "const"(77821 IfExpr (77808 call < chunk[78698](77806 call % dptpl[77456] numChunks[77526])) then
                  { scopeless
                    (77815 call +(77812 call / dptpl[77456] numChunks[77526]) 1)
                  } else
                  { scopeless
                    (77819 call / dptpl[77456] numChunks[77526])
                  } )
                  (77827 'end of statement')
                  const numTasks[77836] "const"(77835 call _computeNumChunks numSublocTasks[77824](ignoreRunning = 1) minIndicesPerTask[77440] locLen[77799])
                  (77839 'end of statement')
                  {
                    unknown tmpIter[77985] "expr temp" "maybe ref" "no copy" "temp"
                    (77988 'move' tmpIter[77985](77845 call #(77842 call chpl_build_low_bounded_range 0) numTasks[77836]))
                    unknown isRngDomArr[78177] "maybe param" "temp"
                    (78192 'move' isRngDomArr[78177](78190 call ||(78179 call isBoundedRange tmpIter[77985])(78188 call ||(78182 call isDomain tmpIter[77985])(78185 call isArray tmpIter[77985]))))
                    if isRngDomArr[78177]
                    {
                      const _coforallCount[78044] "const" "end count" "temp"
                      (78113 'move' _coforallCount[78044](78110 call _endCountAlloc 1))
                      unknown numTasks[78045] "temp"
                      (78097 'move' numTasks[78045](78093 call . tmpIter[77985] c"size"))
                      (78088 call _upEndCount _coforallCount[78044] 1 numTasks[78045])
                      (78085 call chpl_resetTaskSpawn numTasks[78045])
                      unknown _indexOfInterest[78052] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
                      unknown _iterator[78053] "expr temp" "temp"
                      (78062 'move' _iterator[78053](78060 call _getIterator tmpIter[77985]))
                      Defer
                      {
                        {
                          (78078 call _freeIterator _iterator[78053])
                        }
                      }
                      { scopeless type
                        (78067 'move' _indexOfInterest[78052](78064 call iteratorIndex _iterator[78053]))
                      }
                      ForLoop[78054]
                      {
                        unknown core[78071] "coforall index var" "index var" "insert auto destroy"
                        (78073 'move' core[78071] _indexOfInterest[78052])
                        {
                          {
                            const tmp[77992] "const" "temp"(77994 call _computeBlock locLen[77799] numTasks[77836] core[78071] hi[77761] lo[77759] lo[77759])
                            (78003 call _check_tuple_var_decl tmp[77992] 2)
                            const low[78006] "const"(78008 call tmp[77992] 0)
                            const high[78011] "const"(78013 call tmp[77992] 1)
                            (78016 'end of statement')
                            if(78018 call _cond_test debugDataParNuma[93410])
                            {
                              (78022 call chpl_debug_writeln "### chunk = " chunk[78698] "  core = " core[78071] "  " "locRange = " locRange[77791] "  coreRange = "(78032 call chpl_build_bounded_range low[78006] high[78011]))
                            }
                            (78036 yield(78038 call _build_tuple(78040 call chpl_build_bounded_range low[78006] high[78011])))
                          }
                          (78047 call _downEndCount _coforallCount[78044] nil[44])
                          (78046 'coforall loop')
                        }
                        label _continueLabel[78057]
                        _indexOfInterest[78052]
                        _iterator[78053]
                      }
                      label _breakLabel[78058]
                      Defer
                      {
                        {
                          (78100 call _endCountFree _coforallCount[78044])
                        }
                      }
                      (78105 call _waitEndCount _coforallCount[78044] 1 numTasks[78045])
                    }
                    {
                      const _coforallCount[78117] "const" "end count" "temp"
                      (78174 'move' _coforallCount[78117](78171 call _endCountAlloc 1))
                      unknown _indexOfInterest[78125] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
                      unknown _iterator[78126] "expr temp" "temp"
                      (78135 'move' _iterator[78126](78133 call _getIterator tmpIter[77985]))
                      Defer
                      {
                        {
                          (78151 call _freeIterator _iterator[78126])
                        }
                      }
                      { scopeless type
                        (78140 'move' _indexOfInterest[78125](78137 call iteratorIndex _iterator[78126]))
                      }
                      ForLoop[78127]
                      {
                        unknown core[78144] "coforall index var" "index var" "insert auto destroy"
                        (78146 'move' core[78144] _indexOfInterest[78125])
                        (78158 call _upEndCount _coforallCount[78117] 1)
                        {
                          {
                            const tmp[77861] "const" "temp"(77860 call _computeBlock locLen[77799] numTasks[77836] core[78144] hi[77761] lo[77759] lo[77759])
                            (77868 call _check_tuple_var_decl tmp[77861] 2)
                            const low[77847] "const"(77862 call tmp[77861] 0)
                            const high[77849] "const"(77865 call tmp[77861] 1)
                            (77873 'end of statement')
                            if(77973 call _cond_test debugDataParNuma[93410])
                            {
                              (77970 call chpl_debug_writeln "### chunk = " chunk[78698] "  core = " core[78144] "  " "locRange = " locRange[77791] "  coreRange = "(77968 call chpl_build_bounded_range low[77847] high[77849]))
                            }
                            (77983 yield(77981 call _build_tuple(77979 call chpl_build_bounded_range low[77847] high[77849])))
                          }
                          (78120 call _downEndCount _coforallCount[78117] nil[44])
                          (78119 'coforall loop')
                        }
                        label _continueLabel[78130]
                        _indexOfInterest[78125]
                        _iterator[78126]
                      }
                      label _breakLabel[78131]
                      Defer
                      {
                        {
                          (78162 call _endCountFree _coforallCount[78117])
                        }
                      }
                      (78167 call _waitEndCount _coforallCount[78117] 1)
                    }
                  }
                }
                (78674 call _downEndCount _coforallCount[78672] nil[44])
                (78204 'coforall on block' 1 tmp[78199])
              }
              label _continueLabel[78684]
              _indexOfInterest[78679]
              _iterator[78680]
            }
            label _breakLabel[78685]
            Defer
            {
              {
                (78716 call _endCountFree _coforallCount[78672])
              }
            }
            (78721 call _waitEndCount _coforallCount[78672] 0)
          }
        }
      }
    }
    {
      unknown v[78759](78756 call . this[77323] c"size")
      (78762 'end of statement')
      const numChunks[78775] "const"(78772 IfExpr (78766 'task_get_serial') then
      { scopeless
        1
      } else
      { scopeless
        (78771 call _computeNumChunks v[78759])
      } )
      (78778 'end of statement')
      if(78828 call _cond_test debugChapelRange[64198])
      {
        (78786 call chpl_debug_writeln "*** RI: length=" v[78759] " numChunks=" numChunks[78775])
        (78826 call chpl_debug_writeln "*** RI: Using " numChunks[78775] " chunk(s)")
      }
      if(79133 call _cond_test(78834 call == numChunks[78775] 1))
      {
        (78845 yield(78843 call _build_tuple(78841 call chpl_build_bounded_range 0(78839 call - v[78759] 1))))
      }
      {
        {
          unknown tmpIter[78924] "expr temp" "maybe ref" "no copy" "temp"
          (78927 'move' tmpIter[78924](78852 call #(78849 call chpl_build_low_bounded_range 0) numChunks[78775]))
          unknown isRngDomArr[79113] "maybe param" "temp"
          (79128 'move' isRngDomArr[79113](79126 call ||(79115 call isBoundedRange tmpIter[78924])(79124 call ||(79118 call isDomain tmpIter[78924])(79121 call isArray tmpIter[78924]))))
          if isRngDomArr[79113]
          {
            const _coforallCount[78980] "const" "end count" "temp"
            (79049 'move' _coforallCount[78980](79046 call _endCountAlloc 1))
            unknown numTasks[78981] "temp"
            (79033 'move' numTasks[78981](79029 call . tmpIter[78924] c"size"))
            (79024 call _upEndCount _coforallCount[78980] 1 numTasks[78981])
            (79021 call chpl_resetTaskSpawn numTasks[78981])
            unknown _indexOfInterest[78988] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
            unknown _iterator[78989] "expr temp" "temp"
            (78998 'move' _iterator[78989](78996 call _getIterator tmpIter[78924]))
            Defer
            {
              {
                (79014 call _freeIterator _iterator[78989])
              }
            }
            { scopeless type
              (79003 'move' _indexOfInterest[78988](79000 call iteratorIndex _iterator[78989]))
            }
            ForLoop[78990]
            {
              unknown chunk[79007] "coforall index var" "index var" "insert auto destroy"
              (79009 'move' chunk[79007] _indexOfInterest[78988])
              {
                {
                  const tmp[78931] "const" "temp"(78933 call _computeBlock v[78759] numChunks[78775] chunk[79007](78938 call - v[78759] 1))
                  (78943 call _check_tuple_var_decl tmp[78931] 2)
                  const lo[78946] "const"(78948 call tmp[78931] 0)
                  const hi[78951] "const"(78953 call tmp[78931] 1)
                  (78956 'end of statement')
                  if(78958 call _cond_test debugChapelRange[64198])
                  {
                    (78963 call chpl_debug_writeln "*** RI: tuple = "(78966 call _build_tuple(78968 call chpl_build_bounded_range lo[78946] hi[78951])))
                  }
                  (78972 yield(78974 call _build_tuple(78976 call chpl_build_bounded_range lo[78946] hi[78951])))
                }
                (78983 call _downEndCount _coforallCount[78980] nil[44])
                (78982 'coforall loop')
              }
              label _continueLabel[78993]
              _indexOfInterest[78988]
              _iterator[78989]
            }
            label _breakLabel[78994]
            Defer
            {
              {
                (79036 call _endCountFree _coforallCount[78980])
              }
            }
            (79041 call _waitEndCount _coforallCount[78980] 1 numTasks[78981])
          }
          {
            const _coforallCount[79053] "const" "end count" "temp"
            (79110 'move' _coforallCount[79053](79107 call _endCountAlloc 1))
            unknown _indexOfInterest[79061] "coforall index var" "an _indexOfInterest or chpl__followIdx variable" "temp"
            unknown _iterator[79062] "expr temp" "temp"
            (79071 'move' _iterator[79062](79069 call _getIterator tmpIter[78924]))
            Defer
            {
              {
                (79087 call _freeIterator _iterator[79062])
              }
            }
            { scopeless type
              (79076 'move' _indexOfInterest[79061](79073 call iteratorIndex _iterator[79062]))
            }
            ForLoop[79063]
            {
              unknown chunk[79080] "coforall index var" "index var" "insert auto destroy"
              (79082 'move' chunk[79080] _indexOfInterest[79061])
              (79094 call _upEndCount _coforallCount[79053] 1)
              {
                {
                  const tmp[78869] "const" "temp"(78868 call _computeBlock v[78759] numChunks[78775] chunk[79080](78866 call - v[78759] 1))
                  (78876 call _check_tuple_var_decl tmp[78869] 2)
                  const lo[78854] "const"(78870 call tmp[78869] 0)
                  const hi[78856] "const"(78873 call tmp[78869] 1)
                  (78881 'end of statement')
                  if(78911 call _cond_test debugChapelRange[64198])
                  {
                    (78909 call chpl_debug_writeln "*** RI: tuple = "(78907 call _build_tuple(78905 call chpl_build_bounded_range lo[78854] hi[78856])))
                  }
                  (78922 yield(78920 call _build_tuple(78918 call chpl_build_bounded_range lo[78854] hi[78856])))
                }
                (79056 call _downEndCount _coforallCount[79053] nil[44])
                (79055 'coforall loop')
              }
              label _continueLabel[79066]
              _indexOfInterest[79061]
              _iterator[79062]
            }
            label _breakLabel[79067]
            Defer
            {
              {
                (79098 call _endCountFree _coforallCount[79053])
              }
            }
            (79103 call _waitEndCount _coforallCount[79053] 1)
          }
        }
      }
    }
  }
  where {
    (77333 call == tag[77318] leader[447])
  }
  function range[64319](?).these[79152](arg _mt[79159]:_MT[238], arg this[79156]:range[64319](?) :
  range[64319](?), param arg tag[79149] :
  iterKind[453], arg followThis[79154]:_any[178](?)) : _unknown[51] "iterator fn" "method" "no doc" "no return value for void"
  {
    if(79185 call _cond_test(79175 call && 1(79174 call(79170 call . this[79156] c"isAmbiguous"))))
    {
      (79183 call boundsCheckHalt module=[255] HaltWrappers[210085] "these -- Attempt to iterate over a range with ambiguous alignment.")
      (358156 'referenced modules list' HaltWrappers[210085])
    }
    if(79203 call _cond_test(79196 call ==(376070 call . this[79156] c"boundedType") boundedNone[64214]))
    {
      (79201 call compilerError "iteration over a range with no bounds")
    }
    if(79241 call _cond_test(79218 call &&(79209 call !(376075 call . this[79156] c"stridable"))(79216 call ==(376080 call . this[79156] c"boundedType") boundedHigh[64212])))
    {
      (79239 call compilerError "iteration over a range with no first index")
    }
    if(79274 call _cond_test(79251 call !=(79247 call . followThis[79154] c"size") 1))
    {
      (79272 call compilerError "iteration over a range with multi-dimensional iterator")
    }
    if(79302 call _cond_test debugChapelRange[64198])
    {
      (79300 call chpl_debug_writeln "In range follower code: Following " followThis[79154])
    }
    unknown myFollowThis[79311](79310 call followThis[79154] 0)
    (79314 'end of statement')
    if(79338 call _cond_test debugChapelRange[64198])
    {
      (79336 call chpl_debug_writeln "Range = " myFollowThis[79311])
    }
    if(79412 call _cond_test(79352 call && 1(79350 call !(79349 call(79345 call . this[79156] c"hasFirst")))))
    {
      if(79407 call _cond_test(79359 call(79355 call . this[79156] c"isEmpty")))
      {
        if(79392 call _cond_test(79366 call !(79365 call(79361 call . myFollowThis[79311] c"isEmpty"))))
        {
          (79390 call boundsCheckHalt module=[255] HaltWrappers[210085] "size mismatch in zippered iteration")
          (358168 'referenced modules list' HaltWrappers[210085])
        }
      }
      {
        (79404 call boundsCheckHalt module=[255] HaltWrappers[210085] "iteration over a range with no first index")
        (358174 'referenced modules list' HaltWrappers[210085])
      }
    }
    if(79475 call _cond_test(79425 call && 1(79423 call !(79422 call(79418 call . myFollowThis[79311] c"hasFirst")))))
    {
      if(79469 call _cond_test(79443 call !(79441 call &&(79433 call !(79432 call(79428 call . myFollowThis[79311] c"isAmbiguous")))(79440 call(79436 call . myFollowThis[79311] c"isEmpty")))))
      {
        (79467 call boundsCheckHalt module=[255] HaltWrappers[210085] "zippered iteration over a range with no first index")
        (358183 'referenced modules list' HaltWrappers[210085])
      }
    }
    if(80147 call _cond_test(79497 call ||(79489 call &&(79482 call isBoundedRange myFollowThis[79311])(79487 call !(79484 call . myFollowThis[79311] c"stridable")))(79496 call(79492 call . myFollowThis[79311] c"hasLast"))))
    {
      const flwlen[79503] "const"(79500 call . myFollowThis[79311] c"size")
      (79506 'end of statement')
      if(79586 call _cond_test(79515 call && 1(79514 call(79510 call . this[79156] c"hasLast"))))
      {
        if(79580 call _cond_test(79520 call isBoundedRange this[79156]))
        {
          if(79552 call _cond_test(79526 call <(79522 call . this[79156] c"size") flwlen[79503]))
          {
            (79550 call boundsCheckHalt module=[255] HaltWrappers[210085] "zippered iteration over a range with too few indices")
            (358194 'referenced modules list' HaltWrappers[210085])
          }
        }
        {
          (79578 call assert 0 "hasFirst && hasLast do not imply isBoundedRange")
        }
      }
      if(79936 call _cond_test(79598 call ||(79591 call . this[79156] c"stridable")(79595 call . myFollowThis[79311] c"stridable")))
      {
        unknown r[79619](79617 call chpl_by(79608 call chpl_build_bounded_range(79603 call(376095 call . this[79156] c"chpl_intToIdx") 1)(79607 call(376099 call . this[79156] c"chpl_intToIdx") 0))(79615 call _cast(79614 call chpl__rangeStrideType(376103 call . this[79156] c"intIdxType")) 1))
        (79622 'end of statement')
        if(79728 call _cond_test(79626 call != flwlen[79503] 0))
        {
          const stride[79638] "const"(79636 call *(79629 call . this[79156] c"stride")(79633 call . myFollowThis[79311] c"stride"))
          (79641 'end of statement')
          unknown low[79653](79652 call(79644 call . this[79156] c"orderToIndex")(79648 call . myFollowThis[79311] c"first"))
          (79656 'end of statement')
          unknown high[79679](79678 call(376108 call . this[79156] c"chpl_intToIdx")(79675 call +(79663 call _cast(376113 call . this[79156] c"strType")(79661 call chpl__idxToInt low[79653]))(79673 call * stride[79638](79671 call _cast(376119 call . this[79156] c"strType")(79668 call - flwlen[79503] 1)))))
          (79682 'end of statement')
          (79698 call assert(79695 call == high[79679](79694 call(79686 call . this[79156] c"orderToIndex")(79690 call . myFollowThis[79311] c"last"))))
          if(79709 call _cond_test(79702 call < stride[79638] 0))
          {
            (79706 call <=> low[79653] high[79679])
          }
          (79725 call = r[79619](79723 call chpl_by(79717 call chpl_build_bounded_range low[79653] high[79679])(79721 call _cast(376131 call . this[79156] c"strType") stride[79638])))
        }
        if(79755 call _cond_test debugChapelRange[64198])
        {
          (79753 call chpl_debug_writeln "Expanded range = " r[79619])
        }
        {
          unknown _indexOfInterest[79765] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[79766] "expr temp" "temp"
          (79775 'move' _iterator[79766](79773 call _getIterator r[79619]))
          Defer
          {
            {
              (79791 call _freeIterator _iterator[79766])
            }
          }
          { scopeless type
            (79780 'move' _indexOfInterest[79765](79777 call iteratorIndex _iterator[79766]))
          }
          ForLoop[79767]
          {
            unknown i[79784] "index var" "insert auto destroy"
            (79786 'move' i[79784] _indexOfInterest[79765])
            (79763 yield i[79784])
            label _continueLabel[79770]
            _indexOfInterest[79765]
            _iterator[79766]
          }
          label _breakLabel[79771]
        }
      }
      {
        unknown r[79810](79808 call chpl_build_bounded_range(79802 call chpl__intToIdx(376140 call . this[79156] c"idxType") 1)(79807 call chpl__intToIdx(376145 call . this[79156] c"idxType") 0))
        (79813 'end of statement')
        if(79882 call _cond_test(79817 call != flwlen[79503] 0))
        {
          const low[79829] "const"(79828 call(79820 call . this[79156] c"orderToIndex")(79824 call . myFollowThis[79311] c"first"))
          (79832 'end of statement')
          const high[79853] "const"(79852 call(376150 call . this[79156] c"chpl_intToIdx")(79849 call +(79840 call _cast(376155 call . this[79156] c"strType")(79838 call chpl__idxToInt low[79829]))(79847 call _cast(376160 call . this[79156] c"strType")(79844 call - flwlen[79503] 1))))
          (79856 'end of statement')
          (79872 call assert(79869 call == high[79853](79868 call(79860 call . this[79156] c"orderToIndex")(79864 call . myFollowThis[79311] c"last"))))
          (79879 call = r[79810](79877 call chpl_build_bounded_range low[79829] high[79853]))
        }
        if(79893 call _cond_test debugChapelRange[64198])
        {
          (79891 call chpl_debug_writeln "Expanded range = " r[79810])
        }
        {
          unknown _indexOfInterest[79903] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[79904] "expr temp" "temp"
          (79913 'move' _iterator[79904](79911 call _getIterator r[79810]))
          Defer
          {
            {
              (79929 call _freeIterator _iterator[79904])
            }
          }
          { scopeless type
            (79918 'move' _indexOfInterest[79903](79915 call iteratorIndex _iterator[79904]))
          }
          ForLoop[79905]
          {
            unknown i[79922] "index var" "insert auto destroy"
            (79924 'move' i[79922] _indexOfInterest[79903])
            (79901 yield i[79922])
            label _continueLabel[79908]
            _indexOfInterest[79903]
            _iterator[79904]
          }
          label _breakLabel[79909]
        }
      }
    }
    {
      if(79977 call _cond_test(79947 call && 1(79946 call(79942 call . this[79156] c"hasLast"))))
      {
        (79975 call zipLengthHalt module=[255] HaltWrappers[210085] "zippered iteration where a bounded range follows an unbounded iterator")
        (358213 'referenced modules list' HaltWrappers[210085])
      }
      const first[79993] "const"(79992 call(79984 call . this[79156] c"orderToIndex")(79988 call . myFollowThis[79311] c"first"))
      (79996 'end of statement')
      const stride[80007] "const"(80005 call *(79998 call . this[79156] c"stride")(80002 call . myFollowThis[79311] c"stride"))
      (80010 'end of statement')
      if(80143 call _cond_test(80013 call > stride[80007] 0))
      {
        const r[80024] "const"(80022 call chpl_by(80016 call chpl_build_low_bounded_range first[79993])(80020 call _cast(376176 call . this[79156] c"strType") stride[80007]))
        (80027 'end of statement')
        if(80036 call _cond_test debugChapelRange[64198])
        {
          (80034 call chpl_debug_writeln "Expanded range = " r[80024])
        }
        {
          unknown _indexOfInterest[80046] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[80047] "expr temp" "temp"
          (80056 'move' _iterator[80047](80054 call _getIterator r[80024]))
          Defer
          {
            {
              (80072 call _freeIterator _iterator[80047])
            }
          }
          { scopeless type
            (80061 'move' _indexOfInterest[80046](80058 call iteratorIndex _iterator[80047]))
          }
          ForLoop[80048]
          {
            unknown i[80065] "index var" "insert auto destroy"
            (80067 'move' i[80065] _indexOfInterest[80046])
            (80044 yield i[80065])
            label _continueLabel[80051]
            _indexOfInterest[80046]
            _iterator[80047]
          }
          label _breakLabel[80052]
        }
      }
      {
        const r[80088] "const"(80086 call chpl_by(80080 call chpl_build_high_bounded_range first[79993])(80084 call _cast(376186 call . this[79156] c"strType") stride[80007]))
        (80091 'end of statement')
        if(80100 call _cond_test debugChapelRange[64198])
        {
          (80098 call chpl_debug_writeln "Expanded range = " r[80088])
        }
        {
          unknown _indexOfInterest[80110] "an _indexOfInterest or chpl__followIdx variable" "temp"
          unknown _iterator[80111] "expr temp" "temp"
          (80120 'move' _iterator[80111](80118 call _getIterator r[80088]))
          Defer
          {
            {
              (80136 call _freeIterator _iterator[80111])
            }
          }
          { scopeless type
            (80125 'move' _indexOfInterest[80110](80122 call iteratorIndex _iterator[80111]))
          }
          ForLoop[80112]
          {
            unknown i[80129] "index var" "insert auto destroy"
            (80131 'move' i[80129] _indexOfInterest[80110])
            (80108 yield i[80129])
            label _continueLabel[80115]
            _indexOfInterest[80110]
            _iterator[80111]
          }
          label _breakLabel[80116]
        }
      }
    }
  }
  where {
    (79166 call == tag[79149] follower[449])
  }
  function _cast[80160](arg t[80157] :
  string[26], arg x[80166] :
  (80165 call range[64319](?) ?[260])) : _unknown[51]
  {
    unknown ret[80170] string[26]
    (80173 'end of statement')
    if(80192 call _cond_test(80180 call(80176 call . x[80166] c"hasLowBound")))
    {
      (80189 call += ret[80170](80187 call _cast string[26](80183 call . x[80166] c"low")))
    }
    (80215 call += ret[80170] "..")
    if(80235 call _cond_test(80223 call(80219 call . x[80166] c"hasHighBound")))
    {
      (80232 call += ret[80170](80230 call _cast string[26](80226 call . x[80166] c"high")))
    }
    if(80261 call _cond_test(80245 call !=(80241 call . x[80166] c"stride") 1))
    {
      (80258 call += ret[80170](80256 call + " by "(80254 call _cast string[26](80250 call . x[80166] c"stride"))))
    }
    unknown alignCheckRange[80267] x[80166]
    (80270 'end of statement')
    (80278 call(80274 call . alignCheckRange[80267] c"normalizeAlignment"))
    if(80330 call _cond_test(80288 call !(80287 call(80283 call . alignCheckRange[80267] c"isNaturallyAligned"))))
    {
      (80327 call += ret[80170](80325 call + " align "(80323 call _cast string[26](80321 call chpl__mod(80315 call chpl__idxToInt(80311 call . x[80166] c"alignment"))(80318 call . x[80166] c"stride")))))
    }
    (80336 return ret[80170])
  }
  function range[64319](?).normalizeAlignment[80343](arg _mt[80348]:_MT[238], ref arg this[80345]:range[64319](?) :
  range[64319](?)) : _unknown[51] "method" "no doc" "no return value for void"
  {
    if(80406 call _cond_test(80354 call &&(376203 call . this[80345] c"stridable")(80352 call !(376207 call . this[80345] c"aligned"))))
    {
      (80402 call =(376212 call . this[80345] c"_alignment")(80399 IfExpr (80360 call isBoundedRange this[80345]) then
      { scopeless(80367 IfExpr (80363 call >(376217 call . this[80345] c"stride") 0) then
        { scopeless
          (376222 call . this[80345] c"_low")
        } else
        { scopeless
          (376227 call . this[80345] c"_high")
        } )
      } else
      { scopeless(80396 IfExpr (80378 call ==(80371 call . this[80345] c"boundedType") boundedLow[64210]) then
        { scopeless
          (376232 call . this[80345] c"_low")
        } else
        { scopeless(80393 IfExpr (80389 call ==(80382 call . this[80345] c"boundedType") boundedHigh[64212]) then
          { scopeless
            (376237 call . this[80345] c"_high")
          } else
          { scopeless
            0
          } )
        } )
      } ))
    }
  }
  function range[64319](?).chpl__unTranslate[80420](arg _mt[80425]:_MT[238], arg this[80422]:range[64319](?) :
  range[64319](?), arg i[80417] :
  (376241 call . this[80422] c"intIdxType")) : _unknown[51] "inline" "method" "no doc"
  {
    (80431 return(80429 call - this[80422] i[80417]))
  }
  function range[64319](?).chpl__unTranslate[80441](arg _mt[80446]:_MT[238], arg this[80443]:range[64319](?) :
  range[64319](?), arg i[80439]:_any[178](?)) : _unknown[51] "inline" "method" "no doc"
  {
    if(80468 call _cond_test(80452 call isIntType(80450 'typeof' i[80439])))
    {
      (80457 return(80455 call - this[80443] i[80439]))
    }
    {
      (80466 return(80464 call + this[80443](80463 call abs i[80439])))
    }
  }
  function chpl__hasAlignment[80486](arg r[80483] :
  (80482 call range[64319](?) ?[260])) : _unknown[51]
  {
    if(80506 call _cond_test(80501 call &&(80493 call(80489 call . r[80483] c"hasLowBound"))(80499 call >=(80495 call . r[80483] c"stride") 2)))
    {
      (80504 return 1)
    }
    if(80532 call _cond_test(80527 call &&(80517 call(80513 call . r[80483] c"hasHighBound"))(80525 call <=(80519 call . r[80483] c"stride")(80523 call - 2))))
    {
      (80530 return 1)
    }
    (80538 return 0)
  }
  function chpl__mod[80548](arg dividend[80545] :
  integral[199](?), arg modulus[80551] :
  integral[199](?)) : _unknown[51]
  {
    const m[80565] "const"(80564 call(80558 call .(80557 call abs modulus[80551]) c"safeCast")(80562 'typeof' dividend[80545]))
    (80568 'end of statement')
    unknown tmp[80574](80572 call % dividend[80545] m[80565])
    (80577 'end of statement')
    if(80596 call _cond_test(80581 call isInt dividend[80545]))
    {
      if(80591 call _cond_test(80584 call < tmp[80574] 0))
      {
        (80588 call += tmp[80574] m[80565])
      }
    }
    (80602 return tmp[80574])
  }
  function chpl__diffMod[80612](arg minuend[80609] :
  integral[199](?), arg subtrahend[80615] :
  integral[199](?), arg modulus[80619] :
  integral[199](?)) : _unknown[51]
  {
    const m[80641] "const"(80640 call(80634 call .(80633 call abs modulus[80619]) c"safeCast")(80638 'typeof' minuend[80609]))
    (80644 'end of statement')
    unknown minMod[80651](80650 call chpl__mod minuend[80609] m[80641])
    (80654 'end of statement')
    unknown subMod[80660](80659 call chpl__mod subtrahend[80615] m[80641])
    (80663 'end of statement')
    (80682 return(80679 IfExpr (80666 call < minMod[80651] subMod[80660]) then
    { scopeless
      (80673 call - m[80641](80671 call - subMod[80660] minMod[80651]))
    } else
    { scopeless
      (80677 call - minMod[80651] subMod[80660])
    } ))
  }
  where {
    (80628 call ==(80625 'typeof' minuend[80609])(80627 'typeof' subtrahend[80615]))
  }
  { scopeless type
    (80623 'typeof' minuend[80609])
  }
  function chpl__diffMod[80694](arg minuend[80691] :
  integral[199](?), arg subtrahend[80697] :
  integral[199](?), arg modulus[80701] :
  integral[199](?)) : _unknown[51] "no return value for void"
  {
    (80723 call compilerError "chpl__diffMod -- Operand types must match.")
  }
  function chpl__add[80735](arg a[80732] :
  unknown t[80730], arg b[80738] :
  t[80730], arg resultType[80741]:_any[178](?)) : _unknown[51]
  {
    if(80770 call _cond_test(80747 call !(80746 call isIntegralType t[80730])))
    {
      (80768 call compilerError "Values must be of integral type.")
    }
    if(80804 call _cond_test(80796 call &&(80784 call &&(80778 call > a[80732] 0)(80782 call > b[80738] 0))(80794 call > b[80738](80792 call -(80790 call max t[80730]) a[80732]))))
    {
      (80802 return(80801 call max resultType[80741]))
    }
    if(80837 call _cond_test(80829 call &&(80817 call &&(80811 call < a[80732] 0)(80815 call < b[80738] 0))(80827 call < b[80738](80825 call -(80823 call min t[80730]) a[80732]))))
    {
      (80835 return(80834 call min resultType[80741]))
    }
    if(80922 call _cond_test(80845 call isUintType resultType[80741]))
    {
      if(80916 call _cond_test(80908 call ||(80875 call &&(80854 call &&(80848 call < a[80732] 0)(80852 call > b[80738] 0))(80873 call ||(80861 call == a[80732](80860 call min t[80730]))(80871 call >(80866 call abs a[80732])(80870 call abs b[80738]))))(80906 call &&(80885 call &&(80879 call > a[80732] 0)(80883 call < b[80738] 0))(80904 call ||(80892 call == b[80738](80891 call min t[80730]))(80902 call >(80897 call abs b[80738])(80901 call abs a[80732]))))))
      {
        (80914 return(80912 call _cast resultType[80741] 0))
      }
    }
    (80933 return(80931 call _cast resultType[80741](80928 call + a[80732] b[80738])))
  }
  function chpl__addRangeStrides[80941](arg start[80939]:_any[178](?), arg stride[80943]:_any[178](?), arg count[80945]:_any[178](?)) : _unknown[51]
  {
    function convert[80953](arg a[80951]:_any[178](?), arg b[80955]:_any[178](?)) param : _unknown[51]
    {
      (80995 return(80993 call ||(80973 call &&(80963 call ==(80958 'typeof' a[80951])(80962 call int(64)[13] 64))(80971 call ==(80966 'typeof' b[80955])(80970 call uint(64)[115] 64)))(80991 call &&(80981 call ==(80976 'typeof' a[80951])(80980 call uint(64)[115] 64))(80989 call ==(80984 'typeof' b[80955])(80988 call int(64)[13] 64)))))
    }
    function mul[81005](arg a[81003]:_any[178](?), arg b[81007]:_any[178](?)) : _unknown[51]
    {
      (81037 return(81034 IfExpr (81013 call convert a[81003] b[81007]) then
      { scopeless
        (81028 call *(81019 call _cast(81018 call int(64)[13] 64) a[81003])(81026 call _cast(81025 call int(64)[13] 64) b[81007]))
      } else
      { scopeless
        (81032 call * a[81003] b[81007])
      } ))
    }
    function add[81046](arg a[81044]:_any[178](?), arg b[81048]:_any[178](?)) : _unknown[51]
    {
      (81078 return(81075 IfExpr (81054 call convert a[81044] b[81048]) then
      { scopeless
        (81069 call +(81060 call _cast(81059 call int(64)[13] 64) a[81044])(81067 call _cast(81066 call int(64)[13] 64) b[81048]))
      } else
      { scopeless
        (81073 call + a[81044] b[81048])
      } ))
    }
    (81096 return(81094 call _cast(81093 'typeof' start[80939])(81091 call add start[80939](81090 call mul stride[80943] count[80945]))))
  }
  { scopeless type
    (80948 'typeof' start[80939])
  }
  function chpl__extendedEuclidHelper[81105](arg u[81103]:_any[178](?), arg v[81107]:_any[178](?)) : _unknown[51]
  {
    unknown zero[81112] 0(81110 'typeof' u[81103])
    (81115 'end of statement')
    unknown one[81120] 1(81118 'typeof' u[81103])
    (81123 'end of statement')
    unknown U[81130](81128 call _build_tuple one[81120] zero[81112] u[81103])
    (81133 'end of statement')
    unknown V[81140](81138 call _build_tuple zero[81112] one[81120] v[81107])
    (81143 'end of statement')
    {
      unknown tmp[81192] "temp"
      (81220 'move' tmp[81192](81213 call _cond_test(81215 call !=(81217 call V[81140] 2) 0)))
      WhileDo[81197]
      {
        {
          unknown oldU[81152] U[81130]
          (81155 'end of statement')
          unknown q[81167](81165 call /(81160 call U[81130] 2)(81164 call V[81140] 2))
          (81170 'end of statement')
          (81173 call = U[81130] V[81140])
          (81189 call = V[81140](81187 call - oldU[81152](81185 call * V[81140](81183 call _build_tuple q[81167] q[81167] q[81167]))))
        }
        label _continueLabel[81195]
        (81208 'move' tmp[81192](81201 call _cond_test(81203 call !=(81205 call V[81140] 2) 0)))
        tmp[81192]
      }
      label _breakLabel[81196]
    }
    (81234 return(81232 call _build_tuple(81226 call U[81130] 2)(81230 call U[81130] 0)))
  }
  function chpl__extendedEuclid[81247](arg u[81244] :
  (81243 call int(64)[13] 32), arg v[81253] :
  (81252 call int(64)[13] 32)) : _unknown[51] "inline"
  {
    (81261 return(81260 call chpl__extendedEuclidHelper u[81244] v[81253]))
  }
  function chpl__extendedEuclid[81275](arg u[81272] :
  (81271 call int(64)[13] 64), arg v[81281] :
  (81280 call int(64)[13] 64)) : _unknown[51] "inline"
  {
    (81289 return(81288 call chpl__extendedEuclidHelper u[81272] v[81281]))
  }
  function chpl__rangeIdxTypeError[81298](arg idxType[81296]:_any[178](?)) : _unknown[51] "private" "no return value for void"
  {
    (81340 call compilerError "ranges don't support '"(81321 call _cast string[26] idxType[81296]) "' as their idxType")
  }
  function chpl__rangeStrideType[81349](arg idxType[81347]:_any[178](?)) type : _unknown[51] "private"
  {
    if(81386 call _cond_test(81354 call isIntegralType idxType[81347]))
    {
      (81359 return(81358 call chpl__signedType idxType[81347]))
    }
    {
      if(81382 call _cond_test(81370 call ||(81365 call isEnumType idxType[81347])(81369 call isBoolType idxType[81347])))
      {
        (81373 return int(64)[13])
      }
      {
        (81379 call chpl__rangeIdxTypeError idxType[81347])
      }
    }
  }
  function chpl__rangeUnsignedType[81398](arg idxType[81396]:_any[178](?)) type : _unknown[51] "private"
  {
    if(81435 call _cond_test(81403 call isIntegralType idxType[81396]))
    {
      (81408 return(81407 call chpl__unsignedType idxType[81396]))
    }
    {
      if(81431 call _cond_test(81419 call ||(81414 call isEnumType idxType[81396])(81418 call isBoolType idxType[81396])))
      {
        (81422 return uint(64)[115])
      }
      {
        (81428 call chpl__rangeIdxTypeError idxType[81396])
      }
    }
  }
  function chpl__idxTypeToIntIdxType[81447](arg idxType[81445]:_any[178](?)) type : _unknown[51] "no doc"
  {
    if(81506 call _cond_test(81452 call isBoolType idxType[81445]))
    {
      (81454 return int(64)[13])
    }
    {
      if(81502 call _cond_test(81460 call isEnumType idxType[81445]))
      {
        if(81489 call _cond_test(81466 call <(81462 call . idxType[81445] c"size") 2))
        {
          (81487 call compilerError "ranges are not currently supported for enums with fewer than two values")
        }
        (81496 return int(64)[13])
      }
      {
        (81499 return idxType[81445])
      }
    }
  }
  function range[64319](?).chpl_intToIdx[81519](arg _mt[81524]:_MT[238], arg this[81521]:range[64319](?) :
  range[64319](?), arg i[81517]:_any[178](?)) : _unknown[51] "inline" "method" "no doc"
  {
    (81534 return(81533 call chpl__intToIdx(81528 call . this[81521] c"idxType") i[81517]))
  }
  function chpl__intToIdx[81545](arg idxType[81542] :
  integral[199](?), arg i[81548] :
  integral[199](?)) : _unknown[51] "inline"
  {
    if(81565 call _cond_test(81554 call ==(81552 'typeof' i[81548]) idxType[81542]))
    {
      (81557 return i[81548])
    }
    {
      (81563 return(81561 call _cast idxType[81542] i[81548]))
    }
  }
  function chpl__intToIdx[81580](arg idxType[81577] :
  integral[199](?), param arg i[81583] :
  integral[199](?)) : _unknown[51] "inline"
  {
    if(81600 call _cond_test(81589 call ==(81587 'typeof' i[81583]) idxType[81577]))
    {
      (81592 return i[81583])
    }
    {
      (81598 return(81596 call _cast idxType[81577] i[81583]))
    }
  }
  function chpl__intToIdx[81615](arg idxType[81612] :
  enum[187](?), arg i[81618] :
  integral[199](?)) : _unknown[51] "inline"
  {
    (81626 return(81625 call chpl__orderToEnum i[81618] idxType[81612]))
  }
  function chpl__intToIdx[81635](arg idxType[81633]:_any[178](?), arg i[81638] :
  integral[199](?)) : _unknown[51] "inline"
  {
    (81649 return(81647 call _cast bool[10] i[81638]))
  }
  where {
    (81644 call isBoolType idxType[81633])
  }
  function chpl__intToIdx[81659](arg idxType[81657]:_any[178](?), param arg i[81662] :
  integral[199](?)) param : _unknown[51] "inline"
  {
    (81673 return(81671 call _cast bool[10] i[81662]))
  }
  where {
    (81668 call isBoolType idxType[81657])
  }
  function chpl__intToIdx[81683](arg idxType[81681]:_any[178](?), arg i[81686] :
  nothing[7]) : _unknown[51] "inline"
  {
    (81690 return none[57])
  }
  function chpl__idxToInt[81701](arg i[81698] :
  integral[199](?)) : _unknown[51] "inline"
  {
    (81704 return i[81698])
  }
  function chpl__idxToInt[81715](param arg i[81712] :
  integral[199](?)) param : _unknown[51] "inline"
  {
    (81718 return i[81712])
  }
  function chpl__idxToInt[81729](arg i[81726] :
  enum[187](?)) : _unknown[51] "inline"
  {
    (81735 return(81734 call chpl__enumToOrder i[81726]))
  }
  function chpl__idxToInt[81746](arg i[81743] :
  bool[10]) : _unknown[51] "inline"
  {
    (81752 return(81750 call _cast int(64)[13] i[81743]))
  }
  function chpl__idxToInt[81763](param arg i[81760] :
  bool[10]) param : _unknown[51] "inline"
  {
    (81769 return(81767 call _cast int(64)[13] i[81760]))
  }
  (355160 'used modules list'(64187 'use' ChapelBase[307])(64189 'use' SysBasic[223604])(64190 'use' HaltWrappers[210085])(64194 'use' Math[215946])(64196 'use' DSIUtil[230976]))
}